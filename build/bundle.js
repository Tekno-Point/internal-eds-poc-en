/*! For license information please see bundle.js.LICENSE.txt */
(() => {
  let e; let t; let n; let r; const i = {
    320: (e, t, n) => {
      const r = {
        './accordion-dropdown/accordion-dropdown.js': 226, './accordion-group/accordion-group.js': 864, './cards/cards.js': 12, './carousel/carousel-config.js': 801, './carousel/carousel.js': 654, './carousel/swiper-bundle.min.js': 819, './columns/columns.js': 316, './custom-card/custom-card.js': 400, './embed/embed.js': 640, './footer/footer.js': 676, './form/form-fields.js': 146, './form/form.js': 874, './fragment/fragment.js': 273, './header/header.js': 724, './hero/hero.js': 202, './modal/modal.js': 816, './popular-searches/popular-searches.js': 266, './quicklinks/quicklinks.js': 966, './tabs/tabs.js': 602, './teaser/teaser.js': 38, './videoteaser/videoteaser.js': 596, './wrappercreation/wrappercreation.js': 716,
      }; const i = {
        12: 9, 38: 7, 146: 9, 202: 7, 226: 9, 266: 7, 273: 9, 316: 9, 400: 7, 596: 9, 602: 9, 640: 9, 654: 9, 676: 9, 716: 9, 724: 9, 801: 9, 816: 9, 819: 9, 864: 9, 874: 9, 966: 7,
      }; function o(e) { return a(e).then(((e) => n.t(e, 16 | i[e]))); } function a(e) { return Promise.resolve().then((() => { if (!n.o(r, e)) { const t = new Error(`Cannot find module '${e}'`); throw t.code = 'MODULE_NOT_FOUND', t; } return r[e]; })); }o.keys = () => Object.keys(r), o.resolve = a, o.id = 320, e.exports = o;
    },
    226: (e, t, n) => {
      n.r(t), n.d(t, { default: () => a }); const r = n(724); function i(e) { return (function (e) { if (Array.isArray(e)) return o(e); }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(e)) || (function (e, t) { if (e) { if (typeof e === 'string') return o(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? o(e, t) : void 0; } }(e)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function o(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; } function a(e) { const t = []; i(e.children).forEach(((e) => { const n = e.children[0]; const r = document.createElement('summary'); r.className = 'accordion-item-label', r.append.apply(r, i(n.childNodes)); const o = e.children[1]; o.className = 'accordion-item-body'; const a = document.createElement('details'); a.className = 'accordion-item', a.append(r, o), e.replaceWith(a), t.open = !0, t.push(a); })), t.forEach(((n) => { r.isDesktop.matches && e.classList.contains('only-mobile-expandable') ? (n.disabled = !0, n.open = !0, n.ariaDisabled = !0) : n.addEventListener('toggle', (() => { n.open && t.forEach(((e) => { e !== n && (e.open = !1); })); })); })); }
    },
    864: (e, t, n) => {
      n.r(t), n.d(t, { default: () => a }); const r = n(724); function i(e) { return (function (e) { if (Array.isArray(e)) return o(e); }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(e)) || (function (e, t) { if (e) { if (typeof e === 'string') return o(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? o(e, t) : void 0; } }(e)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function o(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; } function a(e) { const t = []; i(e.children).forEach(((e) => { const n = e.children[0]; const r = document.createElement('summary'); r.className = 'accordion-item-label', r.append.apply(r, i(n.childNodes)); const o = e.children[1]; o.className = 'accordion-item-body'; const a = document.createElement('details'); a.className = 'accordion-item', a.append(r, o), e.replaceWith(a), t.open = !0, t.push(a); })), t.forEach(((n) => { r.isDesktop.matches && e.classList.contains('only-mobile-expandable') ? (n.disabled = !0, n.open = !0, n.ariaDisabled = !0) : n.addEventListener('toggle', (() => { n.open && t.forEach(((e) => { e !== n && (e.open = !1); })); })); })); }
    },
    12: (e, t, n) => {
      n.r(t), n.d(t, { default: () => s }); const r = n(927); const i = n(658); function o(e) { return (function (e) { if (Array.isArray(e)) return a(e); }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(e)) || (function (e, t) { if (e) { if (typeof e === 'string') return a(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0; } }(e)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function a(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; } function s(e) { const t = document.createElement('ul'); o(e.children).forEach(((e) => { const n = document.createElement('li'); for ((0, i.U2)(e, n); e.firstElementChild;)n.append(e.firstElementChild); o(n.children).forEach(((e) => { e.children.length === 1 && e.querySelector('picture') ? e.className = 'cards-card-image' : e.className = 'cards-card-body'; })), t.append(n); })), t.querySelectorAll('picture > img').forEach(((e) => { const t = (0, r.gD)(e.src, e.alt, !1, [{ width: '750' }]); (0, i.U2)(e, t.querySelector('img')), e.closest('picture').replaceWith(t); })), e.textContent = '', e.append(t); }
    },
    801: (e, t, n) => {
      n.r(t), n.d(t, { default: () => i }); const r = {
        loop: !0,
        slidesPerView: 3,
        grabCursor: !0,
        autoplay: !1,
        navigation: {},
        pagination: { clickable: !0 },
        breakpoints: {
          300: { slidesPerView: 1.3 }, 780: { slidesPerView: 1.2 }, 992: { slidesPerView: 3 }, 1199: { slidesPerView: 3 },
        },
      }; const i = {
        'one-slide-only': {
          slidesPerView: 1,
          grabCursor: !0,
          autoplay: { delay: 5e7, disableOnInteraction: !1 },
          navigation: {},
          pagination: { clickable: !0 },
          breakpoints: {
            300: { slidesPerView: 1 }, 780: { slidesPerView: 1 }, 992: { slidesPerView: 1 }, 1199: { slidesPerView: 1 },
          },
        },
        'two-slides-only': {
          loop: !0,
          slidesPerView: 2,
          grabCursor: !0,
          navigation: {},
          pagination: { clickable: !0 },
          breakpoints: {
            300: { slidesPerView: 1, grabCursor: !0 }, 780: { slidesPerView: 1, grabCursor: !0 }, 992: { slidesPerView: 2 }, 1199: { slidesPerView: 2 },
          },
        },
        'three-slides-only': r,
        default: r,
      };
    },
    654: (e, t, n) => {
      n.r(t), n.d(t, { default: () => p }); const r = n(658); const i = n(819); const o = n(801); const a = n(640); const s = n(425); const l = { name: 'Facts', props: { factProp: Object }, setup(e) { return { facts: (0, s.QW)(e).factProp.value.facts }; } }; const c = (0, n(262).A)(l, [['render', function (e, t, n, r, i, o) { return (0, s.uX)(), (0, s.CE)(s.FK, null, [t[0] || (t[0] = (0, s.Lk)('h5', null, 'Some Interesting Sushi Factss :', -1)), ((0, s.uX)(!0), (0, s.CE)(s.FK, null, (0, s.pI)(r.facts, ((e) => ((0, s.uX)(), (0, s.CE)('h6', null, (0, s.v_)(e), 1)))), 256))], 64); }]]); function u(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; } const d = { embed: a.default }; function p(e) { const t = Array.from(e.children); const n = t[0]; let a = o.default.default; Array.from(e.classList).forEach(((e) => { o.default[e] && (a = o.default[e]); })); const l = t.slice(1); const p = (0, r.n)('div', { classes: ['swiper-wrapper'] }); const f = (0, r.n)('div', { classes: ['swiper-button-prev'] }); const h = (0, r.n)('div', { classes: ['swiper-button-next'] }); const m = (0, r.n)('div', { classes: ['swiper-pagination'] }); n.remove(), l.forEach(((e) => { let t; let n; const i = (t = Array.from(e.children), n = 4, (function (e) { if (Array.isArray(e)) return e; }(t)) || (function (e, t) { let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']; if (n != null) { let r; let i; let o; let a; const s = []; let l = !0; let c = !1; try { if (o = (n = n.call(e)).next, t === 0) { if (Object(n) !== n) return; l = !1; } else for (;!(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); l = !0); } catch (e) { c = !0, i = e; } finally { try { if (!l && n.return != null && (a = n.return(), Object(a) !== a)) return; } finally { if (c) throw i; } } return s; } }(t, n)) || (function (e, t) { if (e) { if (typeof e === 'string') return u(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? u(e, t) : void 0; } }(t, n)) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }())); const o = i[0]; const a = i[1]; const s = i[2]; const l = i[3]; const c = (0, r.n)('div', { classes: ['swiper-slide'] }); let f = null; o.textContent.trim().split(',').forEach(((e) => { c.classList.add(e.trim()), d[e.trim()] && (f = d[e.trim()]); })), f ? (f(a), c.append(a)) : (c.append(a), c.append(s), c.append(l)), p.append(c), o.remove(); })), a.navigation.nextEl = h, a.navigation.prevEl = f, a.pagination.el = m, e.classList.add('swiper', 'mySwiper'), e.append(p), e.append(h), e.append(f), e.append(m), new IntersectionObserver(((t) => { t.forEach(((t) => { t.isIntersecting && (0, i.default)(e, a); })); })).observe(e); const v = document.createElement('div'); v.className = 'fact__block-style', console.log('inner content of block ', e.innerHTML), (0, s.Ef)(c, { factProp: { facts: ['Vue App with Suii'] } }).mount(v), e.append(v); }
    },
    819: (e, t, n) => {
      function r(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, d(r.key), r); } } function i(e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(((t) => Object.getOwnPropertyDescriptor(e, t).enumerable))), n.push.apply(n, r); } return n; } function o(e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? i(Object(n), !0).forEach(((t) => { u(e, t, n[t]); })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i(Object(n)).forEach(((t) => { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)); })); } return e; } function a(e, t) { return (function (e) { if (Array.isArray(e)) return e; }(e)) || (function (e, t) { let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']; if (n != null) { let r; let i; let o; let a; const s = []; let l = !0; let c = !1; try { if (o = (n = n.call(e)).next, t === 0) { if (Object(n) !== n) return; l = !1; } else for (;!(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); l = !0); } catch (e) { c = !0, i = e; } finally { try { if (!l && n.return != null && (a = n.return(), Object(a) !== a)) return; } finally { if (c) throw i; } } return s; } }(e, t)) || l(e, t) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function s(e) { return (function (e) { if (Array.isArray(e)) return c(e); }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(e)) || l(e) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function l(e, t) { if (e) { if (typeof e === 'string') return c(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? c(e, t) : void 0; } } function c(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; } function u(e, t, n) {
        return (t = d(t)) in e ? Object.defineProperty(e, t, {
          value: n, enumerable: !0, configurable: !0, writable: !0,
        }) : e[t] = n, e;
      } function d(e) { const t = (function (e) { if (p(e) != 'object' || !e) return e; const t = e[Symbol.toPrimitive]; if (void 0 !== t) { const n = t.call(e, 'string'); if (p(n) != 'object') return n; throw new TypeError('@@toPrimitive must return a primitive value.'); } return String(e); }(e)); return p(t) == 'symbol' ? t : `${t}`; } function p(e) { return p = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, p(e); }n.r(t), n.d(t, { default: () => h }); const f = (function () {
        function e(e) { return e !== null && p(e) == 'object' && 'constructor' in e && e.constructor === Object; } function t(n, r) { void 0 === n && (n = {}), void 0 === r && (r = {}), Object.keys(r).forEach(((i) => { void 0 === n[i] ? n[i] = r[i] : e(r[i]) && e(n[i]) && Object.keys(r[i]).length > 0 && t(n[i], r[i]); })); } const n = {
          body: {},
          addEventListener() {},
          removeEventListener() {},
          activeElement: { blur() {}, nodeName: '' },
          querySelector() { return null; },
          querySelectorAll() { return []; },
          getElementById() { return null; },
          createEvent() { return { initEvent() {} }; },
          createElement() {
            return {
              children: [], childNodes: [], style: {}, setAttribute() {}, getElementsByTagName() { return []; },
            };
          },
          createElementNS() { return {}; },
          importNode() { return null; },
          location: {
            hash: '', host: '', hostname: '', href: '', origin: '', pathname: '', protocol: '', search: '',
          },
        }; function i() { const e = typeof document !== 'undefined' ? document : {}; return t(e, n), e; } let l; let c; let d; const f = {
          document: n,
          navigator: { userAgent: '' },
          location: {
            hash: '', host: '', hostname: '', href: '', origin: '', pathname: '', protocol: '', search: '',
          },
          history: {
            replaceState() {}, pushState() {}, go() {}, back() {},
          },
          CustomEvent() { return this; },
          addEventListener() {},
          removeEventListener() {},
          getComputedStyle() { return { getPropertyValue() { return ''; } }; },
          Image() {},
          Date() {},
          screen: {},
          setTimeout() {},
          clearTimeout() {},
          matchMedia() { return {}; },
          requestAnimationFrame(e) { return typeof setTimeout === 'undefined' ? (e(), null) : setTimeout(e, 0); },
          cancelAnimationFrame(e) { typeof setTimeout !== 'undefined' && clearTimeout(e); },
        }; function h() { const e = typeof window !== 'undefined' ? window : {}; return t(e, f), e; } function m(e) { return void 0 === e && (e = ''), e.trim().split(' ').filter(((e) => !!e.trim())); } function v(e, t) { return void 0 === t && (t = 0), setTimeout(e, t); } function g() { return Date.now(); } function y(e, t) { void 0 === t && (t = 'x'); let n; let r; let i; const o = h(); const a = (function (e) { let t; const n = h(); return n.getComputedStyle && (t = n.getComputedStyle(e, null)), !t && e.currentStyle && (t = e.currentStyle), t || (t = e.style), t; }(e)); return o.WebKitCSSMatrix ? ((r = a.transform || a.webkitTransform).split(',').length > 6 && (r = r.split(', ').map(((e) => e.replace(',', '.'))).join(', ')), i = new o.WebKitCSSMatrix(r === 'none' ? '' : r)) : n = (i = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,')).toString().split(','), t === 'x' && (r = o.WebKitCSSMatrix ? i.m41 : n.length === 16 ? parseFloat(n[12]) : parseFloat(n[4])), t === 'y' && (r = o.WebKitCSSMatrix ? i.m42 : n.length === 16 ? parseFloat(n[13]) : parseFloat(n[5])), r || 0; } function b(e) { return p(e) == 'object' && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === 'Object'; } function w() { for (var e, t = Object(arguments.length <= 0 ? void 0 : arguments[0]), n = ['__proto__', 'constructor', 'prototype'], r = 1; r < arguments.length; r += 1) { const i = r < 0 || arguments.length <= r ? void 0 : arguments[r]; if (i != null && (e = i, !(typeof window !== 'undefined' && void 0 !== window.HTMLElement ? e instanceof HTMLElement : e && (e.nodeType === 1 || e.nodeType === 11)))) for (let o = Object.keys(Object(i)).filter(((e) => n.indexOf(e) < 0)), a = 0, s = o.length; a < s; a += 1) { const l = o[a]; const c = Object.getOwnPropertyDescriptor(i, l); void 0 !== c && c.enumerable && (b(t[l]) && b(i[l]) ? i[l].__swiper__ ? t[l] = i[l] : w(t[l], i[l]) : !b(t[l]) && b(i[l]) ? (t[l] = {}, i[l].__swiper__ ? t[l] = i[l] : w(t[l], i[l])) : t[l] = i[l]); } } return t; } function S(e, t, n) { e.style.setProperty(t, n); } function x(e) { let t; const n = e.swiper; const r = e.targetPosition; const i = e.side; const o = h(); const a = -n.translate; let s = null; const l = n.params.speed; n.wrapperEl.style.scrollSnapType = 'none', o.cancelAnimationFrame(n.cssModeFrameID); const c = r > a ? 'next' : 'prev'; const d = function (e, t) { return c === 'next' && e >= t || c === 'prev' && e <= t; }; const p = function () { t = (new Date()).getTime(), s === null && (s = t); const e = Math.max(Math.min((t - s) / l, 1), 0); const c = 0.5 - Math.cos(e * Math.PI) / 2; let f = a + c * (r - a); if (d(f, r) && (f = r), n.wrapperEl.scrollTo(u({}, i, f)), d(f, r)) return n.wrapperEl.style.overflow = 'hidden', n.wrapperEl.style.scrollSnapType = '', setTimeout((() => { n.wrapperEl.style.overflow = '', n.wrapperEl.scrollTo(u({}, i, f)); })), void o.cancelAnimationFrame(n.cssModeFrameID); n.cssModeFrameID = o.requestAnimationFrame(p); }; p(); } function E(e) { return e.querySelector('.swiper-slide-transform') || e.shadowRoot && e.shadowRoot.querySelector('.swiper-slide-transform') || e; } function T(e, t) { void 0 === t && (t = ''); const n = s(e.children); return e instanceof HTMLSlotElement && n.push.apply(n, s(e.assignedElements())), t ? n.filter(((e) => e.matches(t))) : n; } function _(e) { try { return void console.warn(e); } catch (e) {} } function C(e, t) { let n; void 0 === t && (t = []); const r = document.createElement(e); return (n = r.classList).add.apply(n, s(Array.isArray(t) ? t : m(t))), r; } function L(e) { const t = h(); const n = i(); const r = e.getBoundingClientRect(); const o = n.body; const a = e.clientTop || o.clientTop || 0; const s = e.clientLeft || o.clientLeft || 0; const l = e === t ? t.scrollY : e.scrollTop; const c = e === t ? t.scrollX : e.scrollLeft; return { top: r.top + l - a, left: r.left + c - s }; } function k(e, t) { return h().getComputedStyle(e, null).getPropertyValue(t); } function M(e) { let t; let n = e; if (n) { for (t = 0; (n = n.previousSibling) !== null;)n.nodeType === 1 && (t += 1); return t; } } function A(e, t) { for (var n = [], r = e.parentElement; r;)t ? r.matches(t) && n.push(r) : n.push(r), r = r.parentElement; return n; } function O(e, t) { t && e.addEventListener('transitionend', (function n(r) { r.target === e && (t.call(e, r), e.removeEventListener('transitionend', n)); })); } function P(e, t, n) { const r = h(); return n ? e[t === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(r.getComputedStyle(e, null).getPropertyValue(t === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(r.getComputedStyle(e, null).getPropertyValue(t === 'width' ? 'margin-left' : 'margin-bottom')) : e.offsetWidth; } function I(e) { return (Array.isArray(e) ? e : [e]).filter(((e) => !!e)); } function N(e) { return function (t) { return Math.abs(t) > 0 && e.browser && e.browser.need3dFix && Math.abs(t) % 90 == 0 ? t + 0.001 : t; }; } function D() { return l || (l = (function () { const e = h(); const t = i(); return { smoothScroll: t.documentElement && t.documentElement.style && 'scrollBehavior' in t.documentElement.style, touch: !!('ontouchstart' in e || e.DocumentTouch && t instanceof e.DocumentTouch) }; }())), l; } function R(e) { return void 0 === e && (e = {}), c || (c = (function (e) { const t = (void 0 === e ? {} : e).userAgent; const n = D(); const r = h(); const i = r.navigator.platform; const o = t || r.navigator.userAgent; const a = { ios: !1, android: !1 }; const s = r.screen.width; const l = r.screen.height; const c = o.match(/(Android);?[\s\/]+([\d.]+)?/); let u = o.match(/(iPad).*OS\s([\d_]+)/); const d = o.match(/(iPod)(.*OS\s([\d_]+))?/); const p = !u && o.match(/(iPhone\sOS|iOS)\s([\d_]+)/); const f = i === 'Win32'; let m = i === 'MacIntel'; return !u && m && n.touch && ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'].indexOf(''.concat(s, 'x').concat(l)) >= 0 && ((u = o.match(/(Version)\/([\d.]+)/)) || (u = [0, 1, '13_0_0']), m = !1), c && !f && (a.os = 'android', a.android = !0), (u || p || d) && (a.os = 'ios', a.ios = !0), a; }(e))), c; } function j() {
          return d || (d = (function () {
            const e = h(); const t = R(); let n = !1; function r() { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf('safari') >= 0 && t.indexOf('chrome') < 0 && t.indexOf('android') < 0; } if (r()) { const i = String(e.navigator.userAgent); if (i.includes('Version/')) { const o = i.split('Version/')[1].split(' ')[0].split('.').map(((e) => Number(e))); const s = a(o, 2); const l = s[0]; const c = s[1]; n = l < 16 || l === 16 && c < 2; } } const u = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent); const d = r(); return {
              isSafari: n || d, needPerspectiveFix: n, need3dFix: d || u && t.ios, isWebView: u,
            };
          }())), d;
        } const V = {
          on(e, t, n) { const r = this; if (!r.eventsListeners || r.destroyed) return r; if (typeof t !== 'function') return r; const i = n ? 'unshift' : 'push'; return e.split(' ').forEach(((e) => { r.eventsListeners[e] || (r.eventsListeners[e] = []), r.eventsListeners[e][i](t); })), r; }, once(e, t, n) { const r = this; if (!r.eventsListeners || r.destroyed) return r; if (typeof t !== 'function') return r; function i() { r.off(e, i), i.__emitterProxy && delete i.__emitterProxy; for (var n = arguments.length, o = new Array(n), a = 0; a < n; a++)o[a] = arguments[a]; t.apply(r, o); } return i.__emitterProxy = t, r.on(e, i, n); }, onAny(e, t) { const n = this; if (!n.eventsListeners || n.destroyed) return n; if (typeof e !== 'function') return n; const r = t ? 'unshift' : 'push'; return n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[r](e), n; }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const n = t.eventsAnyListeners.indexOf(e); return n >= 0 && t.eventsAnyListeners.splice(n, 1), t; }, off(e, t) { const n = this; return !n.eventsListeners || n.destroyed ? n : n.eventsListeners ? (e.split(' ').forEach(((e) => { void 0 === t ? n.eventsListeners[e] = [] : n.eventsListeners[e] && n.eventsListeners[e].forEach(((r, i) => { (r === t || r.__emitterProxy && r.__emitterProxy === t) && n.eventsListeners[e].splice(i, 1); })); })), n) : n; }, emit() { let e; let t; let n; const r = this; if (!r.eventsListeners || r.destroyed) return r; if (!r.eventsListeners) return r; for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)o[a] = arguments[a]; return typeof o[0] === 'string' || Array.isArray(o[0]) ? (e = o[0], t = o.slice(1, o.length), n = r) : (e = o[0].events, t = o[0].data, n = o[0].context || r), t.unshift(n), (Array.isArray(e) ? e : e.split(' ')).forEach(((e) => { r.eventsAnyListeners && r.eventsAnyListeners.length && r.eventsAnyListeners.forEach(((r) => { r.apply(n, [e].concat(s(t))); })), r.eventsListeners && r.eventsListeners[e] && r.eventsListeners[e].forEach(((e) => { e.apply(n, t); })); })), r; },
        }; const F = function (e, t, n) { t && !e.classList.contains(n) ? e.classList.add(n) : !t && e.classList.contains(n) && e.classList.remove(n); }; const z = function (e, t, n) { t && !e.classList.contains(n) ? e.classList.add(n) : !t && e.classList.contains(n) && e.classList.remove(n); }; const B = function (e, t) { if (e && !e.destroyed && e.params) { const n = t.closest(e.isElement ? 'swiper-slide' : '.'.concat(e.params.slideClass)); if (n) { let r = n.querySelector('.'.concat(e.params.lazyPreloaderClass)); !r && e.isElement && (n.shadowRoot ? r = n.shadowRoot.querySelector('.'.concat(e.params.lazyPreloaderClass)) : requestAnimationFrame((() => { n.shadowRoot && (r = n.shadowRoot.querySelector('.'.concat(e.params.lazyPreloaderClass))) && r.remove(); }))), r && r.remove(); } } }; const q = function (e, t) { if (e.slides[t]) { const n = e.slides[t].querySelector('[loading="lazy"]'); n && n.removeAttribute('loading'); } }; const H = function (e) { if (e && !e.destroyed && e.params) { let t = e.params.lazyPreloadPrevNext; const n = e.slides.length; if (n && t && !(t < 0)) { t = Math.min(t, n); const r = e.params.slidesPerView === 'auto' ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView); const i = e.activeIndex; if (e.params.grid && e.params.grid.rows > 1) { const o = i; const a = [o - t]; return a.push.apply(a, s(Array.from({ length: t }).map(((e, t) => o + r + t)))), void e.slides.forEach(((t, n) => { a.includes(t.column) && q(e, n); })); } const l = i + r - 1; if (e.params.rewind || e.params.loop) for (let c = i - t; c <= l + t; c += 1) { const u = (c % n + n) % n; (u < i || u > l) && q(e, u); } else for (let d = Math.max(i - t, 0); d <= Math.min(l + t, n - 1); d += 1)d !== i && (d > l || d < i) && q(e, d); } } }; const G = {
          updateSize() { let e; let t; const n = this; const r = n.el; e = void 0 !== n.params.width && n.params.width !== null ? n.params.width : r.clientWidth, t = void 0 !== n.params.height && n.params.height !== null ? n.params.height : r.clientHeight, e === 0 && n.isHorizontal() || t === 0 && n.isVertical() || (e = e - parseInt(k(r, 'padding-left') || 0, 10) - parseInt(k(r, 'padding-right') || 0, 10), t = t - parseInt(k(r, 'padding-top') || 0, 10) - parseInt(k(r, 'padding-bottom') || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(n, { width: e, height: t, size: n.isHorizontal() ? e : t })); },
updateSlides() {
 const e = this; function t(t, n) { return parseFloat(t.getPropertyValue(e.getDirectionLabel(n)) || 0); } const n = e.params; const r = e.wrapperEl; const i = e.slidesEl; const o = e.size; const a = e.rtlTranslate; const s = e.wrongRTL; const l = e.virtual && n.virtual.enabled; const c = l ? e.virtual.slides.length : e.slides.length; const u = T(i, ".".concat(e.params.slideClass, ", swiper-slide")); const d = l ? e.virtual.slides.length : u.length; let p = []; const f = []; const h = []; let m = n.slidesOffsetBefore; typeof m === 'function' && (m = n.slidesOffsetBefore.call(e)); let v = n.slidesOffsetAfter; typeof v === 'function' && (v = n.slidesOffsetAfter.call(e)); const g = e.snapGrid.length; const y = e.slidesGrid.length; let b = n.spaceBetween; let w = -m; let x = 0; let E = 0; if (void 0 !== o) {
 typeof b === 'string' && b.indexOf('%') >= 0 ? b = parseFloat(b.replace('%', '')) / 100 * o : typeof b === 'string' && (b = parseFloat(b)), e.virtualSize = -b, u.forEach(((e) => { a ? e.style.marginLeft = '' : e.style.marginRight = '', e.style.marginBottom = '', e.style.marginTop = ''; })), n.centeredSlides && n.cssMode && (S(r, '--swiper-centered-offset-before', ''), S(r, '--swiper-centered-offset-after', '')); let _; const C = n.grid && n.grid.rows > 1 && e.grid; C ? e.grid.initSlides(u) : e.grid && e.grid.unsetSlides(); for (let L = n.slidesPerView === 'auto' && n.breakpoints && Object.keys(n.breakpoints).filter(((e) => void 0 !== n.breakpoints[e].slidesPerView)).length > 0, M = 0; M < d; M += 1) { let A = void 0; if (_ = 0, u[M] && (A = u[M]), C && e.grid.updateSlide(M, A, u), !u[M] || k(A, 'display') !== 'none') { if (n.slidesPerView === 'auto') { L && (u[M].style[e.getDirectionLabel('width')] = ''); const O = getComputedStyle(A); const I = A.style.transform; const N = A.style.webkitTransform; if (I && (A.style.transform = 'none'), N && (A.style.webkitTransform = 'none'), n.roundLengths)_ = e.isHorizontal() ? P(A, 'width', !0) : P(A, 'height', !0); else { const D = t(O, 'width'); const R = t(O, "padding-left"); const j = t(O, "padding-right"); const V = t(O, "margin-left"); const F = t(O, "margin-right"); const z = O.getPropertyValue('box-sizing'); if (z && z === 'border-box')_ = D + V + F; else { const B = A; const q = B.clientWidth; _ = D + R + j + V + F + (B.offsetWidth - q); } }I && (A.style.transform = I), N && (A.style.webkitTransform = N), n.roundLengths && (_ = Math.floor(_)); } else _ = (o - (n.slidesPerView - 1) * b) / n.slidesPerView, n.roundLengths && (_ = Math.floor(_)), u[M] && (u[M].style[e.getDirectionLabel('width')] = ''.concat(_, 'px')); u[M] && (u[M].swiperSlideSize = _), h.push(_), n.centeredSlides ? (w = w + _ / 2 + x / 2 + b, x === 0 && M !== 0 && (w = w - o / 2 - b), M === 0 && (w = w - o / 2 - b), Math.abs(w) < 0.001 && (w = 0), n.roundLengths && (w = Math.floor(w)), E % n.slidesPerGroup == 0 && p.push(w), f.push(w)) : (n.roundLengths && (w = Math.floor(w)), (E - Math.min(e.params.slidesPerGroupSkip, E)) % e.params.slidesPerGroup == 0 && p.push(w), f.push(w), w = w + _ + b), e.virtualSize += _ + b, x = _, E += 1; } } if (e.virtualSize = Math.max(e.virtualSize, o) + v, a && s && (n.effect === 'slide' || n.effect === 'coverflow') && (r.style.width = ''.concat(e.virtualSize + b, 'px')), n.setWrapperSize && (r.style[e.getDirectionLabel('width')] = ''.concat(e.virtualSize + b, 'px')), C && e.grid.updateWrapperSize(_, p), !n.centeredSlides) { for (var H = [], G = 0; G < p.length; G += 1) { let U = p[G]; n.roundLengths && (U = Math.floor(U)), p[G] <= e.virtualSize - o && H.push(U); }p = H, Math.floor(e.virtualSize - o) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - o); } if (l && n.loop) { const $ = h[0] + b; if (n.slidesPerGroup > 1) for (let W = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / n.slidesPerGroup), Y = $ * n.slidesPerGroup, X = 0; X < W; X += 1)p.push(p[p.length - 1] + Y); for (let K = 0; K < e.virtual.slidesBefore + e.virtual.slidesAfter; K += 1)n.slidesPerGroup === 1 && p.push(p[p.length - 1] + $), f.push(f[f.length - 1] + $), e.virtualSize += $; } if (p.length === 0 && (p = [0]), b !== 0) { const J = e.isHorizontal() && a ? 'marginLeft' : e.getDirectionLabel('marginRight'); u.filter(((e, t) => !(n.cssMode && !n.loop) || t !== u.length - 1)).forEach(((e) => { e.style[J] = ''.concat(b, 'px'); })); } if (n.centeredSlides && n.centeredSlidesBounds) { let Q = 0; h.forEach(((e) => { Q += e + (b || 0); })); const Z = (Q -= b) > o ? Q - o : 0; p = p.map(((e) => e <= 0 ? -m : e > Z ? Z + v : e)); } if (n.centerInsufficientSlides) { let ee = 0; h.forEach(((e) => { ee += e + (b || 0); })), ee -= b; const te = (n.slidesOffsetBefore || 0) + (n.slidesOffsetAfter || 0); if (ee + te < o) { const ne = (o - ee - te) / 2; p.forEach(((e, t) => { p[t] = e - ne; })), f.forEach(((e, t) => { f[t] = e + ne; })); } } if (Object.assign(e, {
            slides: u, snapGrid: p, slidesGrid: f, slidesSizesGrid: h, 
}), n.centeredSlides && n.cssMode && !n.centeredSlidesBounds) { S(r, '--swiper-centered-offset-before', `${-p[0] }px`), S(r, '--swiper-centered-offset-after', `${e.size / 2 - h[h.length - 1] / 2 }px`); const re = -e.snapGrid[0]; const ie = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map(((e) => e + re)), e.slidesGrid = e.slidesGrid.map(((e) => e + ie)); } if (d !== c && e.emit('slidesLengthChange'), p.length !== g && (e.params.watchOverflow && e.checkOverflow(), e.emit('snapGridLengthChange')), f.length !== y && e.emit('slidesGridLengthChange'), n.watchSlidesProgress && e.updateSlidesOffset(), e.emit('slidesUpdated'), !(l || n.cssMode || n.effect !== 'slide' && n.effect !== 'fade')) { const oe = ''.concat(n.containerModifierClass, 'backface-hidden'); const ae = e.el.classList.contains(oe); d <= n.maxBackfaceHiddenSlides ? ae || e.el.classList.add(oe) : ae && e.el.classList.remove(oe); } 
} 
},
updateAutoHeight(e) { let t; const n = this; const r = []; const i = n.virtual && n.params.virtual.enabled; let o = 0; typeof e === 'number' ? n.setTransition(e) : !0 === e && n.setTransition(n.params.speed); const a = function (e) { return i ? n.slides[n.getSlideIndexByData(e)] : n.slides[e]; }; if (n.params.slidesPerView !== 'auto' && n.params.slidesPerView > 1) if (n.params.centeredSlides)(n.visibleSlides || []).forEach(((e) => { r.push(e); })); else for (t = 0; t < Math.ceil(n.params.slidesPerView); t += 1) { const s = n.activeIndex + t; if (s > n.slides.length && !i) break; r.push(a(s)); } else r.push(a(n.activeIndex)); for (t = 0; t < r.length; t += 1) if (void 0 !== r[t]) { const l = r[t].offsetHeight; o = l > o ? l : o; }(o || o === 0) && (n.wrapperEl.style.height = ''.concat(o, 'px')); },
updateSlidesOffset() { for (let e = this, t = e.slides, n = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0, r = 0; r < t.length; r += 1)t[r].swiperSlideOffset = (e.isHorizontal() ? t[r].offsetLeft : t[r].offsetTop) - n - e.cssOverflowAdjustment(); },
updateSlidesProgress(e) { void 0 === e && (e = this && this.translate || 0); const t = this; const n = t.params; const r = t.slides; const i = t.rtlTranslate; const o = t.snapGrid; if (r.length !== 0) { void 0 === r[0].swiperSlideOffset && t.updateSlidesOffset(); let a = -e; i && (a = e), t.visibleSlidesIndexes = [], t.visibleSlides = []; let s = n.spaceBetween; typeof s === 'string' && s.indexOf('%') >= 0 ? s = parseFloat(s.replace('%', '')) / 100 * t.size : typeof s === 'string' && (s = parseFloat(s)); for (let l = 0; l < r.length; l += 1) { const c = r[l]; let u = c.swiperSlideOffset; n.cssMode && n.centeredSlides && (u -= r[0].swiperSlideOffset); const d = (a + (n.centeredSlides ? t.minTranslate() : 0) - u) / (c.swiperSlideSize + s); const p = (a - o[0] + (n.centeredSlides ? t.minTranslate() : 0) - u) / (c.swiperSlideSize + s); const f = -(a - u); const h = f + t.slidesSizesGrid[l]; const m = f >= 0 && f <= t.size - t.slidesSizesGrid[l]; const v = f >= 0 && f < t.size - 1 || h > 1 && h <= t.size || f <= 0 && h >= t.size; v && (t.visibleSlides.push(c), t.visibleSlidesIndexes.push(l)), F(c, v, n.slideVisibleClass), F(c, m, n.slideFullyVisibleClass), c.progress = i ? -d : d, c.originalProgress = i ? -p : p; } } },
updateProgress(e) {
 const t = this; if (void 0 === e) { const n = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * n || 0; } const r = t.params; const i = t.maxTranslate() - t.minTranslate(); let o = t.progress; let a = t.isBeginning; let s = t.isEnd; let l = t.progressLoop; const c = a; const u = s; if (i === 0)o = 0, a = !0, s = !0; else { o = (e - t.minTranslate()) / i; const d = Math.abs(e - t.minTranslate()) < 1; const p = Math.abs(e - t.maxTranslate()) < 1; a = d || o <= 0, s = p || o >= 1, d && (o = 0), p && (o = 1); } if (r.loop) { const f = t.getSlideIndexByData(0); const h = t.getSlideIndexByData(t.slides.length - 1); const m = t.slidesGrid[f]; const v = t.slidesGrid[h]; const g = t.slidesGrid[t.slidesGrid.length - 1]; const y = Math.abs(e); (l = y >= m ? (y - m) / g : (y + g - v) / g) > 1 && (l -= 1); }Object.assign(t, {
            progress: o, progressLoop: l, isBeginning: a, isEnd: s, 
}), (r.watchSlidesProgress || r.centeredSlides && r.autoHeight) && t.updateSlidesProgress(e), a && !c && t.emit('reachBeginning toEdge'), s && !u && t.emit('reachEnd toEdge'), (c && !a || u && !s) && t.emit('fromEdge'), t.emit('progress', o); 
},
updateSlidesClasses() { let e; let t; let n; const r = this; const i = r.slides; const o = r.params; const a = r.slidesEl; const s = r.activeIndex; const l = r.virtual && o.virtual.enabled; const c = r.grid && o.grid && o.grid.rows > 1; const u = function (e) { return T(a, '.'.concat(o.slideClass).concat(e, ', swiper-slide').concat(e))[0]; }; if (l) if (o.loop) { let d = s - r.virtual.slidesBefore; d < 0 && (d = r.virtual.slides.length + d), d >= r.virtual.slides.length && (d -= r.virtual.slides.length), e = u('[data-swiper-slide-index="'.concat(d, '"]')); } else e = u('[data-swiper-slide-index="'.concat(s, '"]')); else c ? (e = i.filter(((e) => e.column === s))[0], n = i.filter(((e) => e.column === s + 1))[0], t = i.filter(((e) => e.column === s - 1))[0]) : e = i[s]; e && (c || (n = (function (e, t) { for (var n = []; e.nextElementSibling;) { let r = e.nextElementSibling; t ? r.matches(t) && n.push(r) : n.push(r), e = r; } return n; }(e, '.'.concat(o.slideClass, ', swiper-slide')))[0], o.loop && !n && (n = i[0]), t = (function (e, t) { for (var n = []; e.previousElementSibling;) { let r = e.previousElementSibling; t ? r.matches(t) && n.push(r) : n.push(r), e = r; } return n; }(e, '.'.concat(o.slideClass, ', swiper-slide')))[0], o.loop && !t === 0 && (t = i[i.length - 1]))), i.forEach(((r) => { z(r, r === e, o.slideActiveClass), z(r, r === n, o.slideNextClass), z(r, r === t, o.slidePrevClass); })), r.emitSlidesClasses(); },
updateActiveIndex(e) {
 let t; const n = this; const r = n.rtlTranslate ? n.translate : -n.translate; const i = n.snapGrid; const o = n.params; const a = n.activeIndex; const s = n.realIndex; const l = n.snapIndex; let c = e; const u = function (e) { let t = e - n.virtual.slidesBefore; return t < 0 && (t = n.virtual.slides.length + t), t >= n.virtual.slides.length && (t -= n.virtual.slides.length), t; }; if (void 0 === c && (c = (function (e) { for (var t, n = e.slidesGrid, r = e.params, i = e.rtlTranslate ? e.translate : -e.translate, o = 0; o < n.length; o += 1) void 0 !== n[o + 1] ? i >= n[o] && i < n[o + 1] - (n[o + 1] - n[o]) / 2 ? t = o : i >= n[o] && i < n[o + 1] && (t = o + 1) : i >= n[o] && (t = o); return r.normalizeSlideIndex && (t < 0 || void 0 === t) && (t = 0), t; }(n))), i.indexOf(r) >= 0)t = i.indexOf(r); else { const d = Math.min(o.slidesPerGroupSkip, c); t = d + Math.floor((c - d) / o.slidesPerGroup); } if (t >= i.length && (t = i.length - 1), c !== a || n.params.loop) {if (c === a && n.params.loop && n.virtual && n.params.virtual.enabled)n.realIndex = u(c); else { let p; let f = n.grid && o.grid && o.grid.rows > 1; if (n.virtual && o.virtual.enabled && o.loop)p = u(c); else if (f) { let h = n.slides.filter(((e) => { return e.column === c; }))[0]; let m = parseInt(h.getAttribute('data-swiper-slide-index'), 10); Number.isNaN(m) && (m = Math.max(n.slides.indexOf(h), 0)), p = Math.floor(m / o.grid.rows); } else if (n.slides[c]) { let v = n.slides[c].getAttribute('data-swiper-slide-index'); p = v ? parseInt(v, 10) : c; } else p = c; Object.assign(n, {
 previousSnapIndex: l, snapIndex: t, previousRealIndex: s, realIndex: p, previousIndex: a, activeIndex: c 
}), n.initialized && H(n), n.emit('activeIndexChange'), n.emit('snapIndexChange'), (n.initialized || n.params.runCallbacksOnInit) && (s !== p && n.emit('realIndexChange'), n.emit('slideChange')); }} else t !== l && (n.snapIndex = t, n.emit('snapIndexChange')); 
},
updateClickedSlide(e, t) { const n = this; const r = n.params; let i = e.closest('.'.concat(r.slideClass, ', swiper-slide')); !i && n.isElement && t && t.length > 1 && t.includes(e) && s(t.slice(t.indexOf(e) + 1, t.length)).forEach(((e) => { !i && e.matches && e.matches('.'.concat(r.slideClass, ', swiper-slide')) && (i = e); })); let o; let a = !1; if (i) for (let l = 0; l < n.slides.length; l += 1) if (n.slides[l] === i) { a = !0, o = l; break; } if (!i || !a) return n.clickedSlide = void 0, void (n.clickedIndex = void 0); n.clickedSlide = i, n.virtual && n.params.virtual.enabled ? n.clickedIndex = parseInt(i.getAttribute('data-swiper-slide-index'), 10) : n.clickedIndex = o, r.slideToClickedSlide && void 0 !== n.clickedIndex && n.clickedIndex !== n.activeIndex && n.slideToClickedSlide(); },
        }; const U = {
          getTranslate(e) { void 0 === e && (e = this.isHorizontal() ? 'x' : 'y'); const t = this.params; const n = this.rtlTranslate; const r = this.translate; const i = this.wrapperEl; if (t.virtualTranslate) return n ? -r : r; if (t.cssMode) return r; let o = y(i, e); return o += this.cssOverflowAdjustment(), n && (o = -o), o || 0; }, setTranslate(e, t) { const n = this; const r = n.rtlTranslate; const i = n.params; const o = n.wrapperEl; const a = n.progress; let s = 0; let l = 0; n.isHorizontal() ? s = r ? -e : e : l = e, i.roundLengths && (s = Math.floor(s), l = Math.floor(l)), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? s : l, i.cssMode ? o[n.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = n.isHorizontal() ? -s : -l : i.virtualTranslate || (n.isHorizontal() ? s -= n.cssOverflowAdjustment() : l -= n.cssOverflowAdjustment(), o.style.transform = 'translate3d('.concat(s, 'px, ').concat(l, 'px, 0px)')); const c = n.maxTranslate() - n.minTranslate(); (c === 0 ? 0 : (e - n.minTranslate()) / c) !== a && n.updateProgress(e), n.emit('setTranslate', n.translate, t); }, minTranslate() { return -this.snapGrid[0]; }, maxTranslate() { return -this.snapGrid[this.snapGrid.length - 1]; }, translateTo(e, t, n, r, i) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === n && (n = !0), void 0 === r && (r = !0); const o = this; const a = o.params; const s = o.wrapperEl; if (o.animating && a.preventInteractionOnTransition) return !1; let l; const c = o.minTranslate(); const d = o.maxTranslate(); if (l = r && e > c ? c : r && e < d ? d : e, o.updateProgress(l), a.cssMode) { const p = o.isHorizontal(); if (t === 0)s[p ? 'scrollLeft' : 'scrollTop'] = -l; else { if (!o.support.smoothScroll) return x({ swiper: o, targetPosition: -l, side: p ? 'left' : 'top' }), !0; s.scrollTo(u(u({}, p ? 'left' : 'top', -l), 'behavior', 'smooth')); } return !0; } return t === 0 ? (o.setTransition(0), o.setTranslate(l), n && (o.emit('beforeTransitionStart', t, i), o.emit('transitionEnd'))) : (o.setTransition(t), o.setTranslate(l), n && (o.emit('beforeTransitionStart', t, i), o.emit('transitionStart')), o.animating || (o.animating = !0, o.onTranslateToWrapperTransitionEnd || (o.onTranslateToWrapperTransitionEnd = function (e) { o && !o.destroyed && e.target === this && (o.wrapperEl.removeEventListener('transitionend', o.onTranslateToWrapperTransitionEnd), o.onTranslateToWrapperTransitionEnd = null, delete o.onTranslateToWrapperTransitionEnd, o.animating = !1, n && o.emit('transitionEnd')); }), o.wrapperEl.addEventListener('transitionend', o.onTranslateToWrapperTransitionEnd))), !0; },
        }; function $(e) { const t = e.swiper; const n = e.runCallbacks; const r = e.direction; const i = e.step; const o = t.activeIndex; const a = t.previousIndex; let s = r; if (s || (s = o > a ? 'next' : o < a ? 'prev' : 'reset'), t.emit('transition'.concat(i)), n && o !== a) { if (s === 'reset') return void t.emit('slideResetTransition'.concat(i)); t.emit('slideChangeTransition'.concat(i)), s === 'next' ? t.emit('slideNextTransition'.concat(i)) : t.emit('slidePrevTransition'.concat(i)); } } const W = {
          slideTo(e, t, n, r, i) { void 0 === e && (e = 0), void 0 === n && (n = !0), typeof e === 'string' && (e = parseInt(e, 10)); const o = this; let a = e; a < 0 && (a = 0); const s = o.params; const l = o.snapGrid; const c = o.slidesGrid; const d = o.previousIndex; const p = o.activeIndex; const f = o.rtlTranslate; const h = o.wrapperEl; if (!o.enabled && !r && !i || o.destroyed || o.animating && s.preventInteractionOnTransition) return !1; void 0 === t && (t = o.params.speed); const m = Math.min(o.params.slidesPerGroupSkip, a); let v = m + Math.floor((a - m) / o.params.slidesPerGroup); v >= l.length && (v = l.length - 1); let g; const y = -l[v]; if (s.normalizeSlideIndex) for (let b = 0; b < c.length; b += 1) { const w = -Math.floor(100 * y); const S = Math.floor(100 * c[b]); const E = Math.floor(100 * c[b + 1]); void 0 !== c[b + 1] ? w >= S && w < E - (E - S) / 2 ? a = b : w >= S && w < E && (a = b + 1) : w >= S && (a = b); } if (o.initialized && a !== p) { if (!o.allowSlideNext && (f ? y > o.translate && y > o.minTranslate() : y < o.translate && y < o.minTranslate())) return !1; if (!o.allowSlidePrev && y > o.translate && y > o.maxTranslate() && (p || 0) !== a) return !1; }a !== (d || 0) && n && o.emit('beforeSlideChangeStart'), o.updateProgress(y), g = a > p ? 'next' : a < p ? 'prev' : 'reset'; const T = o.virtual && o.params.virtual.enabled; if ((!T || !i) && (f && -y === o.translate || !f && y === o.translate)) return o.updateActiveIndex(a), s.autoHeight && o.updateAutoHeight(), o.updateSlidesClasses(), s.effect !== 'slide' && o.setTranslate(y), g !== 'reset' && (o.transitionStart(n, g), o.transitionEnd(n, g)), !1; if (s.cssMode) { const _ = o.isHorizontal(); const C = f ? y : -y; if (t === 0)T && (o.wrapperEl.style.scrollSnapType = 'none', o._immediateVirtual = !0), T && !o._cssModeVirtualInitialSet && o.params.initialSlide > 0 ? (o._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => { h[_ ? 'scrollLeft' : 'scrollTop'] = C; }))) : h[_ ? 'scrollLeft' : 'scrollTop'] = C, T && requestAnimationFrame((() => { o.wrapperEl.style.scrollSnapType = '', o._immediateVirtual = !1; })); else { if (!o.support.smoothScroll) return x({ swiper: o, targetPosition: C, side: _ ? 'left' : 'top' }), !0; h.scrollTo(u(u({}, _ ? 'left' : 'top', C), 'behavior', 'smooth')); } return !0; } return o.setTransition(t), o.setTranslate(y), o.updateActiveIndex(a), o.updateSlidesClasses(), o.emit('beforeTransitionStart', t, r), o.transitionStart(n, g), t === 0 ? o.transitionEnd(n, g) : o.animating || (o.animating = !0, o.onSlideToWrapperTransitionEnd || (o.onSlideToWrapperTransitionEnd = function (e) { o && !o.destroyed && e.target === this && (o.wrapperEl.removeEventListener('transitionend', o.onSlideToWrapperTransitionEnd), o.onSlideToWrapperTransitionEnd = null, delete o.onSlideToWrapperTransitionEnd, o.transitionEnd(n, g)); }), o.wrapperEl.addEventListener('transitionend', o.onSlideToWrapperTransitionEnd)), !0; },
          slideToLoop(e, t, n, r) {
            void 0 === e && (e = 0), void 0 === n && (n = !0), typeof e === 'string' && (e = parseInt(e, 10)); const i = this; if (!i.destroyed) {
              void 0 === t && (t = i.params.speed); const o = i.grid && i.params.grid && i.params.grid.rows > 1; let a = e; if (i.params.loop) { if (i.virtual && i.params.virtual.enabled)a += i.virtual.slidesBefore; else {
 let s; if (o) { const l = a * i.params.grid.rows; s = i.slides.filter(((e) => 1 * e.getAttribute('data-swiper-slide-index') === l))[0].column; } else s = i.getSlideIndexByData(a); const c = o ? Math.ceil(i.slides.length / i.params.grid.rows) : i.slides.length; const u = i.params.centeredSlides; let d = i.params.slidesPerView; d === 'auto' ? d = i.slidesPerViewDynamic() : (d = Math.ceil(parseFloat(i.params.slidesPerView, 10)), u && d % 2 == 0 && (d += 1)); let p = c - s < d; if (u && (p = p || s < Math.ceil(d / 2)), r && u && i.params.slidesPerView !== 'auto' && !o && (p = !1), p) {
 const f = u ? s < i.activeIndex ? 'prev' : 'next' : s - i.activeIndex - 1 < i.params.slidesPerView ? 'next' : 'prev'; i.loopFix({
                direction: f, slideTo: !0, activeSlideIndex: f === 'next' ? s + 1 : s - c + 1, slideRealIndex: f === 'next' ? i.realIndex : void 0, 
}); 
} if (o) { const h = a * i.params.grid.rows; a = i.slides.filter(((e) => 1 * e.getAttribute('data-swiper-slide-index') === h))[0].column; } else a = i.getSlideIndexByData(a); 
} } return requestAnimationFrame((() => { i.slideTo(a, t, n, r); })), i;
            }
          },
          slideNext(e, t, n) { void 0 === t && (t = !0); const r = this; const i = r.enabled; const o = r.params; const a = r.animating; if (!i || r.destroyed) return r; void 0 === e && (e = r.params.speed); let s = o.slidesPerGroup; o.slidesPerView === 'auto' && o.slidesPerGroup === 1 && o.slidesPerGroupAuto && (s = Math.max(r.slidesPerViewDynamic('current', !0), 1)); const l = r.activeIndex < o.slidesPerGroupSkip ? 1 : s; const c = r.virtual && o.virtual.enabled; if (o.loop) { if (a && !c && o.loopPreventsSliding) return !1; if (r.loopFix({ direction: 'next' }), r._clientLeft = r.wrapperEl.clientLeft, r.activeIndex === r.slides.length - 1 && o.cssMode) return requestAnimationFrame((() => { r.slideTo(r.activeIndex + l, e, t, n); })), !0; } return o.rewind && r.isEnd ? r.slideTo(0, e, t, n) : r.slideTo(r.activeIndex + l, e, t, n); },
          slidePrev(e, t, n) { void 0 === t && (t = !0); const r = this; const i = r.params; const o = r.snapGrid; const a = r.slidesGrid; const s = r.rtlTranslate; const l = r.enabled; const c = r.animating; if (!l || r.destroyed) return r; void 0 === e && (e = r.params.speed); const u = r.virtual && i.virtual.enabled; if (i.loop) { if (c && !u && i.loopPreventsSliding) return !1; r.loopFix({ direction: 'prev' }), r._clientLeft = r.wrapperEl.clientLeft; } function d(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e); } let p; const f = d(s ? r.translate : -r.translate); const h = o.map(((e) => { return d(e); })); let m = o[h.indexOf(f) - 1]; void 0 === m && i.cssMode && (o.forEach(((e, t) => { f >= e && (p = t); })), void 0 !== p && (m = o[p > 0 ? p - 1 : p])); let v = 0; if (void 0 !== m && ((v = a.indexOf(m)) < 0 && (v = r.activeIndex - 1), i.slidesPerView === 'auto' && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (v = v - r.slidesPerViewDynamic('previous', !0) + 1, v = Math.max(v, 0))), i.rewind && r.isBeginning) { const g = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1; return r.slideTo(g, e, t, n); } return i.loop && r.activeIndex === 0 && i.cssMode ? (requestAnimationFrame((() => { r.slideTo(v, e, t, n); })), !0) : r.slideTo(v, e, t, n); },
          slideReset(e, t, n) { void 0 === t && (t = !0); const r = this; if (!r.destroyed) return void 0 === e && (e = r.params.speed), r.slideTo(r.activeIndex, e, t, n); },
          slideToClosest(e, t, n, r) { void 0 === t && (t = !0), void 0 === r && (r = 0.5); const i = this; if (!i.destroyed) { void 0 === e && (e = i.params.speed); let o = i.activeIndex; const a = Math.min(i.params.slidesPerGroupSkip, o); const s = a + Math.floor((o - a) / i.params.slidesPerGroup); const l = i.rtlTranslate ? i.translate : -i.translate; if (l >= i.snapGrid[s]) { const c = i.snapGrid[s]; l - c > (i.snapGrid[s + 1] - c) * r && (o += i.params.slidesPerGroup); } else { const u = i.snapGrid[s - 1]; l - u <= (i.snapGrid[s] - u) * r && (o -= i.params.slidesPerGroup); } return o = Math.max(o, 0), o = Math.min(o, i.slidesGrid.length - 1), i.slideTo(o, e, t, n); } },
          slideToClickedSlide() { const e = this; if (!e.destroyed) { let t; const n = e.params; const r = e.slidesEl; const i = 'auto' === n.slidesPerView ? e.slidesPerViewDynamic() : n.slidesPerView; let o = e.clickedIndex; const a = e.isElement ? 'swiper-slide' : '.'.concat(n.slideClass); if (n.loop) { if (e.animating) return; t = parseInt(e.clickedSlide.getAttribute('data-swiper-slide-index'), 10), n.centeredSlides ? o < e.loopedSlides - i / 2 || o > e.slides.length - e.loopedSlides + i / 2 ? (e.loopFix(), o = e.getSlideIndex(T(r, ''.concat(a, '[data-swiper-slide-index="').concat(t, '"]'))[0]), v((() => { e.slideTo(o); }))) : e.slideTo(o) : o > e.slides.length - i ? (e.loopFix(), o = e.getSlideIndex(T(r, ''.concat(a, '[data-swiper-slide-index="').concat(t, '"]'))[0]), v((() => { e.slideTo(o); }))) : e.slideTo(o); } else e.slideTo(o); } },
        }; const Y = {
          loopCreate(e) { const t = this; const n = t.params; const r = t.slidesEl; if (!(!n.loop || t.virtual && t.params.virtual.enabled)) { const i = function () { T(r, '.'.concat(n.slideClass, ', swiper-slide')).forEach(((e, t) => { e.setAttribute('data-swiper-slide-index', t); })); }; const o = t.grid && n.grid && n.grid.rows > 1; const a = n.slidesPerGroup * (o ? n.grid.rows : 1); const s = t.slides.length % a != 0; const l = o && t.slides.length % n.grid.rows != 0; const c = function (e) { for (let r = 0; r < e; r += 1) { const i = t.isElement ? C('swiper-slide', [n.slideBlankClass]) : C('div', [n.slideClass, n.slideBlankClass]); t.slidesEl.append(i); } }; s ? (n.loopAddBlankSlides ? (c(a - t.slides.length % a), t.recalcSlides(), t.updateSlides()) : _('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)'), i()) : l ? (n.loopAddBlankSlides ? (c(n.grid.rows - t.slides.length % n.grid.rows), t.recalcSlides(), t.updateSlides()) : _('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)'), i()) : i(), t.loopFix({ slideRealIndex: e, direction: n.centeredSlides ? void 0 : 'next' }); } },
          loopFix(e) {
            const t = void 0 === e ? {} : e; const n = t.slideRealIndex; const r = t.slideTo; const i = void 0 === r || r; const a = t.direction; const s = t.setTranslate; let l = t.activeSlideIndex; const c = t.byController; const u = t.byMousewheel; const d = this; if (d.params.loop) {
              d.emit('beforeLoopFix'); const p = d.slides; const f = d.allowSlidePrev; const h = d.allowSlideNext; const m = d.slidesEl; const v = d.params; const g = v.centeredSlides; if (d.allowSlidePrev = !0, d.allowSlideNext = !0, d.virtual && v.virtual.enabled) return i && (v.centeredSlides || d.snapIndex !== 0 ? v.centeredSlides && d.snapIndex < v.slidesPerView ? d.slideTo(d.virtual.slides.length + d.snapIndex, 0, !1, !0) : d.snapIndex === d.snapGrid.length - 1 && d.slideTo(d.virtual.slidesBefore, 0, !1, !0) : d.slideTo(d.virtual.slides.length, 0, !1, !0)), d.allowSlidePrev = f, d.allowSlideNext = h, void d.emit('loopFix'); let y = v.slidesPerView; y === 'auto' ? y = d.slidesPerViewDynamic() : (y = Math.ceil(parseFloat(v.slidesPerView, 10)), g && y % 2 == 0 && (y += 1)); const b = v.slidesPerGroupAuto ? y : v.slidesPerGroup; let w = b; w % b != 0 && (w += b - w % b), w += v.loopAdditionalSlides, d.loopedSlides = w; const S = d.grid && v.grid && v.grid.rows > 1; p.length < y + w ? _('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters') : S && v.grid.fill === 'row' && _('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`'); const x = []; const E = []; let T = d.activeIndex; void 0 === l ? l = d.getSlideIndex(p.filter(((e) => e.classList.contains(v.slideActiveClass)))[0]) : T = l; const C = a === 'next' || !a; const L = 'prev' === a || !a; let k = 0; let M = 0; const A = S ? Math.ceil(p.length / v.grid.rows) : p.length; const O = (S ? p[l].column : l) + (g && void 0 === s ? -y / 2 + 0.5 : 0); if (O < w) { k = Math.max(w - O, b); for (let P = 0; P < w - O; P += 1) { const I = P - Math.floor(P / A) * A; if (S) for (let N = A - I - 1, D = p.length - 1; D >= 0; D -= 1)p[D].column === N && x.push(D); else x.push(A - I - 1); } } else if (O + y > A - w) { M = Math.max(O - (A - 2 * w), b); for (var R = function () { const e = j - Math.floor(j / A) * A; S ? p.forEach(((t, n) => { t.column === e && E.push(n); })) : E.push(e); }, j = 0; j < M; j += 1)R(); } if (d.__preventObserver__ = !0, requestAnimationFrame((() => { d.__preventObserver__ = !1; })), L && x.forEach(((e) => { p[e].swiperLoopMoveDOM = !0, m.prepend(p[e]), p[e].swiperLoopMoveDOM = !1; })), C && E.forEach(((e) => { p[e].swiperLoopMoveDOM = !0, m.append(p[e]), p[e].swiperLoopMoveDOM = !1; })), d.recalcSlides(), v.slidesPerView === 'auto' ? d.updateSlides() : S && (x.length > 0 && L || E.length > 0 && C) && d.slides.forEach(((e, t) => { d.grid.updateSlide(t, e, d.slides); })), v.watchSlidesProgress && d.updateSlidesOffset(), i) if (x.length > 0 && L) { if (void 0 === n) { const V = d.slidesGrid[T]; const F = d.slidesGrid[T + k] - V; u ? d.setTranslate(d.translate - F) : (d.slideTo(T + Math.ceil(k), 0, !1, !0), s && (d.touchEventsData.startTranslate = d.touchEventsData.startTranslate - F, d.touchEventsData.currentTranslate = d.touchEventsData.currentTranslate - F)); } else if (s) { const z = S ? x.length / v.grid.rows : x.length; d.slideTo(d.activeIndex + z, 0, !1, !0), d.touchEventsData.currentTranslate = d.translate; } } else if (E.length > 0 && C) if (void 0 === n) { const B = d.slidesGrid[T]; const q = d.slidesGrid[T - M] - B; u ? d.setTranslate(d.translate - q) : (d.slideTo(T - M, 0, !1, !0), s && (d.touchEventsData.startTranslate = d.touchEventsData.startTranslate - q, d.touchEventsData.currentTranslate = d.touchEventsData.currentTranslate - q)); } else { const H = S ? E.length / v.grid.rows : E.length; d.slideTo(d.activeIndex - H, 0, !1, !0); } if (d.allowSlidePrev = f, d.allowSlideNext = h, d.controller && d.controller.control && !c) {
                const G = {
                  slideRealIndex: n, direction: a, setTranslate: s, activeSlideIndex: l, byController: !0, 
}; Array.isArray(d.controller.control) ? d.controller.control.forEach(((e) => { !e.destroyed && e.params.loop && e.loopFix(o(o({}, G), {}, { slideTo: e.params.slidesPerView === v.slidesPerView && i })); })) : d.controller.control instanceof d.constructor && d.controller.control.params.loop && d.controller.control.loopFix(o(o({}, G), {}, { slideTo: d.controller.control.params.slidesPerView === v.slidesPerView && i }));
              }d.emit('loopFix');
            }
          },
          loopDestroy() { const e = this; const t = e.params; const n = e.slidesEl; if (!(!t.loop || e.virtual && e.params.virtual.enabled)) { e.recalcSlides(); const r = []; e.slides.forEach(((e) => { const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute('data-swiper-slide-index') : e.swiperSlideIndex; r[t] = e; })), e.slides.forEach(((e) => { e.removeAttribute('data-swiper-slide-index'); })), r.forEach(((e) => { n.append(e); })), e.recalcSlides(), e.slideTo(e.realIndex, 0); } }, 
}; function X(e, t, n) { const r = h(); const i = e.params; const o = i.edgeSwipeDetection; const a = i.edgeSwipeThreshold; return !o || !(n <= a || n >= r.innerWidth - a) || o === 'prevent' && (t.preventDefault(), !0); } function K(e) {
          const t = this; const n = i(); let r = e; r.originalEvent && (r = r.originalEvent); const o = t.touchEventsData; if (r.type === 'pointerdown') { if (o.pointerId !== null && o.pointerId !== r.pointerId) return; o.pointerId = r.pointerId; } else r.type === 'touchstart' && r.targetTouches.length === 1 && (o.touchId = r.targetTouches[0].identifier); if (r.type !== 'touchstart') {
            const a = t.params; const l = t.touches; if (t.enabled && (a.simulateTouch || r.pointerType !== 'mouse') && (!t.animating || !a.preventInteractionOnTransition)) {
              !t.animating && a.cssMode && a.loop && t.loopFix(); let c = r.target; if ((a.touchEventsTarget !== 'wrapper' || (function (e, t) { const n = t.contains(e); return !n && t instanceof HTMLSlotElement ? s(t.assignedElements()).includes(e) : n; }(c, t.wrapperEl))) && !('which' in r && r.which === 3 || 'button' in r && r.button > 0 || o.isTouched && o.isMoved)) {
                const u = !!a.noSwipingClass && a.noSwipingClass !== ''; const d = r.composedPath ? r.composedPath() : r.path; u && r.target && r.target.shadowRoot && d && (c = d[0]); const p = a.noSwipingSelector ? a.noSwipingSelector : '.'.concat(a.noSwipingClass); const f = !(!r.target || !r.target.shadowRoot); if (a.noSwiping && (f ? (function (e, t) { return void 0 === t && (t = this), (function t(n) { if (!n || n === i() || n === h()) return null; n.assignedSlot && (n = n.assignedSlot); const r = n.closest(e); return r || n.getRootNode ? r || t(n.getRootNode().host) : null; }(t)); }(p, c)) : c.closest(p)))t.allowClick = !0; else if (!a.swipeHandler || c.closest(a.swipeHandler)) {
                  l.currentX = r.pageX, l.currentY = r.pageY; const m = l.currentX; const v = l.currentY; if (X(t, r, m)) {
                    Object.assign(o, {
                      isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0,
                    }), l.startX = m, l.startY = v, o.touchStartTime = g(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, a.threshold > 0 && (o.allowThresholdMove = !1); let y = !0; c.matches(o.focusableElements) && (y = !1, c.nodeName === 'SELECT' && (o.isTouched = !1)), n.activeElement && n.activeElement.matches(o.focusableElements) && n.activeElement !== c && n.activeElement.blur(); const b = y && t.allowTouchMove && a.touchStartPreventDefault; !a.touchStartForcePreventDefault && !b || c.isContentEditable || r.preventDefault(), a.freeMode && a.freeMode.enabled && t.freeMode && t.animating && !a.cssMode && t.freeMode.onTouchStart(), t.emit('touchStart', r);
                  }
                }
              }
            }
          } else X(t, r, r.targetTouches[0].pageX);
        } function J(e) {
          const t = i(); const n = this; const r = n.touchEventsData; const o = n.params; const a = n.touches; const l = n.rtlTranslate; if (n.enabled && (o.simulateTouch || e.pointerType !== 'mouse')) {
            let c; let u = e; if (u.originalEvent && (u = u.originalEvent), u.type === 'pointermove') { if (r.touchId !== null) return; if (u.pointerId !== r.pointerId) return; } if (u.type === 'touchmove') { if (c = s(u.changedTouches).filter(((e) => e.identifier === r.touchId))[0], !c || c.identifier !== r.touchId) return; } else c = u; if (r.isTouched) {
              const d = c.pageX; const p = c.pageY; if (u.preventedByNestedSwiper) return a.startX = d, void (a.startY = p); if (!n.allowTouchMove) {
                return u.target.matches(r.focusableElements) || (n.allowClick = !1), void (r.isTouched && (Object.assign(a, {
                  startX: d, startY: p, currentX: d, currentY: p,
                }), r.touchStartTime = g()));
              } if (o.touchReleaseOnEdges && !o.loop) if (n.isVertical()) { if (p < a.startY && n.translate <= n.maxTranslate() || p > a.startY && n.translate >= n.minTranslate()) return r.isTouched = !1, void (r.isMoved = !1); } else if (d < a.startX && n.translate <= n.maxTranslate() || d > a.startX && n.translate >= n.minTranslate()) return; if (t.activeElement && u.target === t.activeElement && u.target.matches(r.focusableElements)) return r.isMoved = !0, void (n.allowClick = !1); r.allowTouchCallbacks && n.emit('touchMove', u), a.previousX = a.currentX, a.previousY = a.currentY, a.currentX = d, a.currentY = p; let f; const h = a.currentX - a.startX; const m = a.currentY - a.startY; if (!(n.params.threshold && Math.sqrt(h ** 2 + m ** 2) < n.params.threshold)) {
                if (void 0 === r.isScrolling && (n.isHorizontal() && a.currentY === a.startY || n.isVertical() && a.currentX === a.startX ? r.isScrolling = !1 : h * h + m * m >= 25 && (f = 180 * Math.atan2(Math.abs(m), Math.abs(h)) / Math.PI, r.isScrolling = n.isHorizontal() ? f > o.touchAngle : 90 - f > o.touchAngle)), r.isScrolling && n.emit('touchMoveOpposite', u), void 0 === r.startMoving && (a.currentX === a.startX && a.currentY === a.startY || (r.startMoving = !0)), r.isScrolling || u.type === 'touchmove' && r.preventTouchMoveFromPointerMove)r.isTouched = !1; else if (r.startMoving) {
                  n.allowClick = !1, !o.cssMode && u.cancelable && u.preventDefault(), o.touchMoveStopPropagation && !o.nested && u.stopPropagation(); let v = n.isHorizontal() ? h : m; let y = n.isHorizontal() ? a.currentX - a.previousX : a.currentY - a.previousY; o.oneWayMovement && (v = Math.abs(v) * (l ? 1 : -1), y = Math.abs(y) * (l ? 1 : -1)), a.diff = v, v *= o.touchRatio, l && (v = -v, y = -y); const b = n.touchesDirection; n.swipeDirection = v > 0 ? 'prev' : 'next', n.touchesDirection = y > 0 ? 'prev' : 'next'; const w = n.params.loop && !o.cssMode; const S = n.touchesDirection === 'next' && n.allowSlideNext || n.touchesDirection === 'prev' && n.allowSlidePrev; if (!r.isMoved) { if (w && S && n.loopFix({ direction: n.swipeDirection }), r.startTranslate = n.getTranslate(), n.setTransition(0), n.animating) { const x = new window.CustomEvent('transitionend', { bubbles: !0, cancelable: !0, detail: { bySwiperTouchMove: !0 } }); n.wrapperEl.dispatchEvent(x); }r.allowMomentumBounce = !1, !o.grabCursor || !0 !== n.allowSlideNext && !0 !== n.allowSlidePrev || n.setGrabCursor(!0), n.emit('sliderFirstMove', u); } if ((new Date()).getTime(), r.isMoved && r.allowThresholdMove && b !== n.touchesDirection && w && S && Math.abs(v) >= 1) {
 return Object.assign(a, {
                    startX: d, startY: p, currentX: d, currentY: p, startTranslate: r.currentTranslate,
                  }), r.loopSwapReset = !0, void (r.startTranslate = r.currentTranslate); 
} n.emit('sliderMove', u), r.isMoved = !0, r.currentTranslate = v + r.startTranslate; let E = !0; let T = o.resistanceRatio; if (o.touchReleaseOnEdges && (T = 0), v > 0 ? (w && S && r.allowThresholdMove && r.currentTranslate > (o.centeredSlides ? n.minTranslate() - n.slidesSizesGrid[n.activeIndex + 1] - (o.slidesPerView !== 'auto' && n.slides.length - o.slidesPerView >= 2 ? n.slidesSizesGrid[n.activeIndex + 1] + n.params.spaceBetween : 0) - n.params.spaceBetween : n.minTranslate()) && n.loopFix({ direction: 'prev', setTranslate: !0, activeSlideIndex: 0 }), r.currentTranslate > n.minTranslate() && (E = !1, o.resistance && (r.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + r.startTranslate + v) ** T))) : v < 0 && (w && S && r.allowThresholdMove && r.currentTranslate < (o.centeredSlides ? n.maxTranslate() + n.slidesSizesGrid[n.slidesSizesGrid.length - 1] + n.params.spaceBetween + (o.slidesPerView !== 'auto' && n.slides.length - o.slidesPerView >= 2 ? n.slidesSizesGrid[n.slidesSizesGrid.length - 1] + n.params.spaceBetween : 0) : n.maxTranslate()) && n.loopFix({ direction: 'next', setTranslate: !0, activeSlideIndex: n.slides.length - (o.slidesPerView === 'auto' ? n.slidesPerViewDynamic() : Math.ceil(parseFloat(o.slidesPerView, 10))) }), r.currentTranslate < n.maxTranslate() && (E = !1, o.resistance && (r.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - r.startTranslate - v) ** T))), E && (u.preventedByNestedSwiper = !0), !n.allowSlideNext && n.swipeDirection === 'next' && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && n.swipeDirection === 'prev' && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), n.allowSlidePrev || n.allowSlideNext || (r.currentTranslate = r.startTranslate), o.threshold > 0) { if (!(Math.abs(v) > o.threshold || r.allowThresholdMove)) return void (r.currentTranslate = r.startTranslate); if (!r.allowThresholdMove) return r.allowThresholdMove = !0, a.startX = a.currentX, a.startY = a.currentY, r.currentTranslate = r.startTranslate, void (a.diff = n.isHorizontal() ? a.currentX - a.startX : a.currentY - a.startY); }o.followFinger && !o.cssMode && ((o.freeMode && o.freeMode.enabled && n.freeMode || o.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), o.freeMode && o.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(r.currentTranslate), n.setTranslate(r.currentTranslate));
                }
              }
            } else r.startMoving && r.isScrolling && n.emit('touchMoveOpposite', u);
          }
        } function Q(e) { let t; const n = this; const r = n.touchEventsData; let i = e; if (i.originalEvent && (i = i.originalEvent), i.type === 'touchend' || i.type === 'touchcancel') { if (t = s(i.changedTouches).filter(((e) => e.identifier === r.touchId))[0], !t || t.identifier !== r.touchId) return; } else { if (r.touchId !== null) return; if (i.pointerId !== r.pointerId) return; t = i; } if (!['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(i.type) || ['pointercancel', 'contextmenu'].includes(i.type) && (n.browser.isSafari || n.browser.isWebView)) { r.pointerId = null, r.touchId = null; const o = n.params; const a = n.touches; const l = n.rtlTranslate; const c = n.slidesGrid; if (n.enabled && (o.simulateTouch || i.pointerType !== 'mouse')) { if (r.allowTouchCallbacks && n.emit('touchEnd', i), r.allowTouchCallbacks = !1, !r.isTouched) return r.isMoved && o.grabCursor && n.setGrabCursor(!1), r.isMoved = !1, void (r.startMoving = !1); o.grabCursor && r.isMoved && r.isTouched && (!0 === n.allowSlideNext || !0 === n.allowSlidePrev) && n.setGrabCursor(!1); let u; const d = g(); const p = d - r.touchStartTime; if (n.allowClick) { const f = i.path || i.composedPath && i.composedPath(); n.updateClickedSlide(f && f[0] || i.target, f), n.emit('tap click', i), p < 300 && d - r.lastClickTime < 300 && n.emit('doubleTap doubleClick', i); } if (r.lastClickTime = g(), v((() => { n.destroyed || (n.allowClick = !0); })), !r.isTouched || !r.isMoved || !n.swipeDirection || a.diff === 0 && !r.loopSwapReset || r.currentTranslate === r.startTranslate && !r.loopSwapReset) return r.isTouched = !1, r.isMoved = !1, void (r.startMoving = !1); if (r.isTouched = !1, r.isMoved = !1, r.startMoving = !1, u = o.followFinger ? l ? n.translate : -n.translate : -r.currentTranslate, !o.cssMode) if (o.freeMode && o.freeMode.enabled)n.freeMode.onTouchEnd({ currentPos: u }); else { for (var h = u >= -n.maxTranslate() && !n.params.loop, m = 0, y = n.slidesSizesGrid[0], b = 0; b < c.length; b += b < o.slidesPerGroupSkip ? 1 : o.slidesPerGroup) { const w = b < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup; void 0 !== c[b + w] ? (h || u >= c[b] && u < c[b + w]) && (m = b, y = c[b + w] - c[b]) : (h || u >= c[b]) && (m = b, y = c[c.length - 1] - c[c.length - 2]); } let S = null; let x = null; o.rewind && (n.isBeginning ? x = o.virtual && o.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1 : n.isEnd && (S = 0)); const E = (u - c[m]) / y; const T = m < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup; if (p > o.longSwipesMs) { if (!o.longSwipes) return void n.slideTo(n.activeIndex); n.swipeDirection === 'next' && (E >= o.longSwipesRatio ? n.slideTo(o.rewind && n.isEnd ? S : m + T) : n.slideTo(m)), n.swipeDirection === 'prev' && (E > 1 - o.longSwipesRatio ? n.slideTo(m + T) : x !== null && E < 0 && Math.abs(E) > o.longSwipesRatio ? n.slideTo(x) : n.slideTo(m)); } else { if (!o.shortSwipes) return void n.slideTo(n.activeIndex); !n.navigation || i.target !== n.navigation.nextEl && i.target !== n.navigation.prevEl ? (n.swipeDirection === 'next' && n.slideTo(S !== null ? S : m + T), n.swipeDirection === 'prev' && n.slideTo(x !== null ? x : m)) : i.target === n.navigation.nextEl ? n.slideTo(m + T) : n.slideTo(m); } } } } } function Z() { const e = this; const t = e.params; const n = e.el; if (!n || n.offsetWidth !== 0) { t.breakpoints && e.setBreakpoint(); const r = e.allowSlideNext; const i = e.allowSlidePrev; const o = e.snapGrid; const a = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); const s = a && t.loop; !(t.slidesPerView === 'auto' || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || s ? e.params.loop && !a ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume(); }), 500)), e.allowSlidePrev = i, e.allowSlideNext = r, e.params.watchOverflow && o !== e.snapGrid && e.checkOverflow(); } } function ee(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))); } function te() { const e = this; const t = e.wrapperEl; const n = e.rtlTranslate; if (e.enabled) { e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, e.translate === 0 && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); (r === 0 ? 0 : (e.translate - e.minTranslate()) / r) !== e.progress && e.updateProgress(n ? -e.translate : e.translate), e.emit('setTranslate', e.translate, !1); } } function ne(e) { const t = this; B(t, e.target), t.params.cssMode || t.params.slidesPerView !== 'auto' && !t.params.autoHeight || t.update(); } function re() { const e = this; e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = 'auto')); } const ie = function (e, t) { const n = i(); const r = e.params; const o = e.el; const a = e.wrapperEl; const s = e.device; const l = !!r.nested; const c = t === 'on' ? 'addEventListener' : 'removeEventListener'; const u = t; o && typeof o !== 'string' && (n[c]('touchstart', e.onDocumentTouchStart, { passive: !1, capture: l }), o[c]('touchstart', e.onTouchStart, { passive: !1 }), o[c]('pointerdown', e.onTouchStart, { passive: !1 }), n[c]('touchmove', e.onTouchMove, { passive: !1, capture: l }), n[c]('pointermove', e.onTouchMove, { passive: !1, capture: l }), n[c]('touchend', e.onTouchEnd, { passive: !0 }), n[c]('pointerup', e.onTouchEnd, { passive: !0 }), n[c]('pointercancel', e.onTouchEnd, { passive: !0 }), n[c]('touchcancel', e.onTouchEnd, { passive: !0 }), n[c]('pointerout', e.onTouchEnd, { passive: !0 }), n[c]('pointerleave', e.onTouchEnd, { passive: !0 }), n[c]('contextmenu', e.onTouchEnd, { passive: !0 }), (r.preventClicks || r.preventClicksPropagation) && o[c]('click', e.onClick, !0), r.cssMode && a[c]('scroll', e.onScroll), r.updateOnWindowResize ? e[u](s.ios || s.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', Z, !0) : e[u]('observerUpdate', Z, !0), o[c]('load', e.onLoad, { capture: !0 })); }; const oe = function (e, t) { return e.grid && t.grid && t.grid.rows > 1; }; const ae = {
          init: !0, direction: 'horizontal', oneWayMovement: !1, swiperElementNodeName: 'SWIPER-CONTAINER', touchEventsTarget: 'wrapper', initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: 'swiper', enabled: !0, focusableElements: 'input, select, option, textarea, button, video, label', width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: 'slide', breakpoints: void 0, breakpointsBase: 'window', spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: 0.5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: 0.85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: 'swiper-no-swiping', noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: 'swiper-', slideClass: 'swiper-slide', slideBlankClass: 'swiper-slide-blank', slideActiveClass: 'swiper-slide-active', slideVisibleClass: 'swiper-slide-visible', slideFullyVisibleClass: 'swiper-slide-fully-visible', slideNextClass: 'swiper-slide-next', slidePrevClass: 'swiper-slide-prev', wrapperClass: 'swiper-wrapper', lazyPreloaderClass: 'swiper-lazy-preloader', lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1,
        }; function se(e, t) { return function (n) { void 0 === n && (n = {}); const r = Object.keys(n)[0]; const i = n[r]; p(i) == 'object' && i !== null ? (!0 === e[r] && (e[r] = { enabled: !0 }), r === 'navigation' && e[r] && e[r].enabled && !e[r].prevEl && !e[r].nextEl && (e[r].auto = !0), ['pagination', 'scrollbar'].indexOf(r) >= 0 && e[r] && e[r].enabled && !e[r].el && (e[r].auto = !0), r in e && 'enabled' in i ? (p(e[r]) != 'object' || 'enabled' in e[r] || (e[r].enabled = !0), e[r] || (e[r] = { enabled: !1 }), w(t, n)) : w(t, n)) : w(t, n); }; } const le = {
          eventsEmitter: V,
          update: G,
          translate: U,
          transition: {
            setTransition(e, t) { const n = this; n.params.cssMode || (n.wrapperEl.style.transitionDuration = ''.concat(e, 'ms'), n.wrapperEl.style.transitionDelay = e === 0 ? '0ms' : ''), n.emit('setTransition', e, t); },
            transitionStart(e, t) {
              void 0 === e && (e = !0); const n = this; const r = n.params; r.cssMode || (r.autoHeight && n.updateAutoHeight(), $({
                swiper: n, runCallbacks: e, direction: t, step: 'Start',
              }));
            },
            transitionEnd(e, t) {
              void 0 === e && (e = !0); const n = this; const r = n.params; n.animating = !1, r.cssMode || (n.setTransition(0), $({
                swiper: n, runCallbacks: e, direction: t, step: 'End',
              }));
            }
          },
          slide: W,
          loop: Y,
          grabCursor: { setGrabCursor(e) { const t = this; if (!(!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)) { const n = t.params.touchEventsTarget === 'container' ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), n.style.cursor = 'move', n.style.cursor = e ? 'grabbing' : 'grab', t.isElement && requestAnimationFrame((() => { t.__preventObserver__ = !1; })); } }, unsetGrabCursor() { const e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e[e.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '', e.isElement && requestAnimationFrame((() => { e.__preventObserver__ = !1; }))); } },
          events: { attachEvents() { const e = this; const t = e.params; e.onTouchStart = K.bind(e), e.onTouchMove = J.bind(e), e.onTouchEnd = Q.bind(e), e.onDocumentTouchStart = re.bind(e), t.cssMode && (e.onScroll = te.bind(e)), e.onClick = ee.bind(e), e.onLoad = ne.bind(e), ie(e, 'on'); }, detachEvents() { ie(this, 'off'); } },
          breakpoints: { setBreakpoint() { const e = this; const t = e.realIndex; const n = e.initialized; const r = e.params; const i = e.el; const o = r.breakpoints; if (o && (!o || Object.keys(o).length !== 0)) { const a = e.getBreakpoint(o, e.params.breakpointsBase, e.el); if (a && e.currentBreakpoint !== a) { const s = (a in o ? o[a] : void 0) || e.originalParams; const l = oe(e, r); const c = oe(e, s); const u = e.params.grabCursor; const d = s.grabCursor; const p = r.enabled; l && !c ? (i.classList.remove(''.concat(r.containerModifierClass, 'grid'), ''.concat(r.containerModifierClass, 'grid-column')), e.emitContainerClasses()) : !l && c && (i.classList.add(''.concat(r.containerModifierClass, 'grid')), (s.grid.fill && s.grid.fill === 'column' || !s.grid.fill && r.grid.fill === 'column') && i.classList.add(''.concat(r.containerModifierClass, 'grid-column')), e.emitContainerClasses()), u && !d ? e.unsetGrabCursor() : !u && d && e.setGrabCursor(), ['navigation', 'pagination', 'scrollbar'].forEach(((t) => { if (void 0 !== s[t]) { const n = r[t] && r[t].enabled; const i = s[t] && s[t].enabled; n && !i && e[t].disable(), !n && i && e[t].enable(); } })); const f = s.direction && s.direction !== r.direction; const h = r.loop && (s.slidesPerView !== r.slidesPerView || f); const m = r.loop; f && n && e.changeDirection(), w(e.params, s); const v = e.params.enabled; const g = e.params.loop; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), p && !v ? e.disable() : !p && v && e.enable(), e.currentBreakpoint = a, e.emit('_beforeBreakpoint', s), n && (h ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !m && g ? (e.loopCreate(t), e.updateSlides()) : m && !g && e.loopDestroy()), e.emit('breakpoint', s); } } }, getBreakpoint(e, t, n) { if (void 0 === t && (t = 'window'), e && (t !== 'container' || n)) { let r = !1; const i = h(); const o = 'window' === t ? i.innerHeight : n.clientHeight; const a = Object.keys(e).map(((e) => { if (typeof e == 'string' && e.indexOf('@') === 0) { const t = parseFloat(e.substr(1)); return { value: o * t, point: e }; } return { value: e, point: e }; })); a.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let s = 0; s < a.length; s += 1) { const l = a[s]; const c = l.point; const u = l.value; t === 'window' ? i.matchMedia('(min-width: '.concat(u, 'px)')).matches && (r = c) : u <= n.clientWidth && (r = c); } return r || 'max'; } } },
          checkOverflow: { checkOverflow() { const e = this; const t = e.isLocked; const n = e.params; const r = n.slidesOffsetBefore; if (r) { const i = e.slides.length - 1; const o = e.slidesGrid[i] + e.slidesSizesGrid[i] + 2 * r; e.isLocked = e.size > o; } else e.isLocked = e.snapGrid.length === 1; !0 === n.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === n.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? 'lock' : 'unlock'); } },
          classes: { addClasses() { let e; const t = this; const n = t.classNames; const r = t.params; const i = t.rtl; const o = t.el; const a = t.device; const l = (function (e, t) { let n = []; return e.forEach(((e) => { 'object' == p(e) ? Object.keys(e).forEach(((r) => { e[r] && n.push(t + r); })) : 'string' === typeof e && n.push(t + e); })), n; }(['initialized', r.direction, { 'free-mode': t.params.freeMode && r.freeMode.enabled }, { autoheight: r.autoHeight }, { rtl: i }, { grid: r.grid && r.grid.rows > 1 }, { 'grid-column': r.grid && r.grid.rows > 1 && 'column' === r.grid.fill }, { android: a.android }, { ios: a.ios }, { 'css-mode': r.cssMode }, { centered: r.cssMode && r.centeredSlides }, { 'watch-progress': r.watchSlidesProgress }], r.containerModifierClass)); n.push.apply(n, s(l)), (e = o.classList).add.apply(e, s(n)), t.emitContainerClasses(); }, removeClasses() { let e; const t = this.el; const n = this.classNames; t && typeof t !== 'string' && ((e = t.classList).remove.apply(e, s(n)), this.emitContainerClasses()); } },
        }; const ce = {}; const ue = (function () {
          function e() {
            let t; let n; let r; let o; !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, e)); for (var l = arguments.length, c = new Array(l), u = 0; u < l; u++)c[u] = arguments[u]; c.length === 1 && c[0].constructor && Object.prototype.toString.call(c[0]).slice(8, -1) === 'Object' ? o = c[0] : (r = (t = a(c, 2))[0], o = t[1]), o || (o = {}), o = w({}, o), r && !o.el && (o.el = r); const d = i(); if (o.el && typeof o.el === 'string' && d.querySelectorAll(o.el).length > 1) { const p = []; return d.querySelectorAll(o.el).forEach(((t) => { const n = w({}, o, { el: t }); p.push(new e(n)); })), p; } const f = this; f.__swiper__ = !0, f.support = D(), f.device = R({ userAgent: o.userAgent }), f.browser = j(), f.eventsListeners = {}, f.eventsAnyListeners = [], f.modules = s(f.__modules__), o.modules && Array.isArray(o.modules) && (n = f.modules).push.apply(n, s(o.modules)); const h = {}; f.modules.forEach(((e) => {
              e({
                params: o, swiper: f, extendParams: se(o, h), on: f.on.bind(f), once: f.once.bind(f), off: f.off.bind(f), emit: f.emit.bind(f),
              });
            })); const m = w({}, ae, h); return f.params = w({}, m, ce, o), f.originalParams = w({}, f.params), f.passedParams = w({}, o), f.params && f.params.on && Object.keys(f.params.on).forEach(((e) => { f.on(e, f.params.on[e]); })), f.params && f.params.onAny && f.onAny(f.params.onAny), Object.assign(f, {
              enabled: f.params.enabled,
              el: r,
              classNames: [],
              slides: [],
              slidesGrid: [],
              snapGrid: [],
              slidesSizesGrid: [],
              isHorizontal() { return f.params.direction === 'horizontal'; },
              isVertical() { return f.params.direction === 'vertical'; },
              activeIndex: 0,
              realIndex: 0,
              isBeginning: !0,
              isEnd: !1,
              translate: 0,
              previousTranslate: 0,
              progress: 0,
              velocity: 0,
              animating: !1,
              cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23; },
              allowSlideNext: f.params.allowSlideNext,
              allowSlidePrev: f.params.allowSlidePrev,
              touchEventsData: {
                isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: f.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null,
              },
              allowClick: !0,
              allowTouchMove: f.params.allowTouchMove,
              touches: {
                startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0,
              },
              imagesToLoad: [],
              imagesLoaded: 0,
            }), f.emit('_swiper'), f.params.init && f.init(), f;
          } return (function (e, t, n) { return t && r(e.prototype, t), n && r(e, n), Object.defineProperty(e, 'prototype', { writable: !1 }), e; }(e, [{ key: 'getDirectionLabel', value(e) { return this.isHorizontal() ? e : {
 width: 'height', 'margin-top': 'margin-left', 'margin-bottom ': 'margin-right', 'margin-left': 'margin-top', 'margin-right': 'margin-bottom', 'padding-left': 'padding-top', 'padding-right': 'padding-bottom', marginRight: 'marginBottom' 
}[e]; } }, { key: 'getSlideIndex', value(e) { let t = this.slidesEl; let n = this.params; let r = M(T(t, '.'.concat(n.slideClass, ', swiper-slide'))[0]); return M(e) - r; } }, { key: 'getSlideIndexByData', value(e) { return this.getSlideIndex(this.slides.filter(((t) => { return 1 * t.getAttribute('data-swiper-slide-index') === e; }))[0]); } }, { key: 'recalcSlides', value() { let e = this.slidesEl; let t = this.params; this.slides = T(e, '.'.concat(t.slideClass, ', swiper-slide')); } }, { key: 'enable', value() { let e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit('enable')); } }, { key: 'disable', value() { let e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit('disable')); } }, { key: 'setProgress', value(e, t) { let n = this; e = Math.min(Math.max(e, 0), 1); let r = n.minTranslate(); let i = (n.maxTranslate() - r) * e + r; n.translateTo(i, void 0 === t ? 0 : t), n.updateActiveIndex(), n.updateSlidesClasses(); } }, { key: 'emitContainerClasses', value() { let e = this; if (e.params._emitClasses && e.el) { let t = e.el.className.split(' ').filter(((t) => { return t.indexOf('swiper') === 0 || t.indexOf(e.params.containerModifierClass) === 0 })); e.emit('_containerClasses', t.join(' ')); } } }, { key: 'getSlideClasses', value(e) { let t = this; return t.destroyed ? '' : e.className.split(' ').filter(((e) => { return e.indexOf('swiper-slide') === 0 || e.indexOf(t.params.slideClass) === 0 })).join(' '); } }, { key: 'emitSlidesClasses', value() { let e = this; if (e.params._emitClasses && e.el) { let t = []; e.slides.forEach(((n) => { let r = e.getSlideClasses(n); t.push({ slideEl: n, classNames: r }), e.emit('_slideClass', n, r); })), e.emit('_slideClasses', t); } } }, { key: 'slidesPerViewDynamic', value(e, t) { void 0 === e && (e = 'current'), void 0 === t && (t = !1); let n = this.params; let r = this.slides; let i = this.slidesGrid; let o = this.slidesSizesGrid; let a = this.size; let s = this.activeIndex; let l = 1; if (typeof n.slidesPerView=='number') return n.slidesPerView; if (n.centeredSlides) { for (var c, u = r[s] ? Math.ceil(r[s].swiperSlideSize) : 0, d = s + 1; d < r.length; d += 1)r[d] && !c && (l += 1, (u += Math.ceil(r[d].swiperSlideSize)) > a && (c = !0)); for (let p = s - 1; p >= 0; p -= 1)r[p] && !c && (l += 1, (u += r[p].swiperSlideSize) > a && (c = !0)); } else if (e==='current') for (let f = s + 1; f < r.length; f += 1)(t ? i[f] + o[f] - i[s] < a : i[f] - i[s] < a) && (l += 1); else for (let h = s - 1; h >= 0; h -= 1)i[s] - i[h] < a && (l += 1); return l; } }, { key: 'update', value() { let e = this; if (e && !e.destroyed) { let t; let n = e.snapGrid; let r = e.params; if (r.breakpoints && e.setBreakpoint(), s(e.el.querySelectorAll('[loading="lazy"]')).forEach(((t) => { t.complete && B(e, t); })), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), r.freeMode && r.freeMode.enabled && !r.cssMode)o(), r.autoHeight && e.updateAutoHeight(); else { if ((r.slidesPerView==='auto' || r.slidesPerView > 1) && e.isEnd && !r.centeredSlides) { let i = e.virtual && r.virtual.enabled ? e.virtual.slides : e.slides; t = e.slideTo(i.length - 1, 0, !1, !0); } else t = e.slideTo(e.activeIndex, 0, !1, !0); t || o(); }r.watchOverflow && n !== e.snapGrid && e.checkOverflow(), e.emit('update'); } function o() { let t = e.rtlTranslate ? -1 * e.translate : e.translate; let n = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(n), e.updateActiveIndex(), e.updateSlidesClasses(); } } }, { key: 'changeDirection', value(e, t) { void 0 === t && (t = !0); let n = this; let r = n.params.direction; return e || (e = 'horizontal' === r ? 'vertical' : 'horizontal'), e === r || 'horizontal' !== e && 'vertical' !== e || (n.el.classList.remove(''.concat(n.params.containerModifierClass).concat(r)), n.el.classList.add(''.concat(n.params.containerModifierClass).concat(e)), n.emitContainerClasses(), n.params.direction = e, n.slides.forEach(((t) => { 'vertical' === e ? t.style.width = '' : t.style.height = '' })), n.emit('changeDirection'), t && n.update()), n; } }, { key: 'changeLanguageDirection', value(e) { let t = this; t.rtl && 'rtl' === e || !t.rtl && 'ltr' === e || (t.rtl = 'rtl' === e, t.rtlTranslate = 'horizontal' === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(''.concat(t.params.containerModifierClass, 'rtl')), t.el.dir = 'rtl') : (t.el.classList.remove(''.concat(t.params.containerModifierClass, 'rtl')), t.el.dir = 'ltr'), t.update()); } }, { key: 'mount', value(e) { let t = this; if (t.mounted) return !0; let n = e || t.params.el; if (typeof n=='string' && (n = document.querySelector(n)), !n) return !1; n.swiper = t, n.parentNode && n.parentNode.host && n.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0); let r = function () { return '.'.concat((t.params.wrapperClass || '').trim().split(' ').join('.')); }; let i = n && n.shadowRoot && n.shadowRoot.querySelector ? n.shadowRoot.querySelector(r()) : T(n, r())[0]; return !i && t.params.createElements && (i = C('div', t.params.wrapperClass), n.append(i), T(n, '.'.concat(t.params.slideClass)).forEach(((e) => { i.append(e); }))), Object.assign(t, {
 el: n, wrapperEl: i, slidesEl: t.isElement && !n.parentNode.host.slideSlots ? n.parentNode.host : i, hostEl: t.isElement ? n.parentNode.host : n, mounted: !0, rtl: 'rtl' === n.dir.toLowerCase() || 'rtl' === k(n, 'direction'), rtlTranslate: 'horizontal' === t.params.direction && (n.dir.toLowerCase()==='rtl' || 'rtl' === k(n, 'direction')), wrongRTL: '-webkit-box' === k(i, 'display') 
}), !0; } }, { key: 'init', value(e) { let t = this; if (t.initialized) return t; if (!1 === t.mount(e)) return t; t.emit('beforeInit'), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(); let n = s(t.el.querySelectorAll('[loading="lazy"]')); return t.isElement && n.push.apply(n, s(t.hostEl.querySelectorAll('[loading="lazy"]'))), n.forEach(((e) => { e.complete ? B(t, e) : e.addEventListener('load', ((e) => { B(t, e.target); })); })), H(t), t.initialized = !0, H(t), t.emit('init'), t.emit('afterInit'), t; } }, { key: 'destroy', value(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); let n = this; let r = n.params; let i = n.el; let o = n.wrapperEl; let a = n.slides; return void 0 === n.params || n.destroyed || (n.emit('beforeDestroy'), n.initialized = !1, n.detachEvents(), r.loop && n.loopDestroy(), t && (n.removeClasses(), i && 'string' !== typeof i && i.removeAttribute('style'), o && o.removeAttribute('style'), a && a.length && a.forEach(((e) => { e.classList.remove(r.slideVisibleClass, r.slideFullyVisibleClass, r.slideActiveClass, r.slideNextClass, r.slidePrevClass), e.removeAttribute('style'), e.removeAttribute('data-swiper-slide-index'); }))), n.emit('destroy'), Object.keys(n.eventsListeners).forEach(((e) => { n.off(e); })), !1 !== e && (n.el && 'string' !== typeof n.el && (n.el.swiper = null), (function (e) { var t = e; Object.keys(t).forEach(((e) =>{ try { t[e] = null } catch (e) {} try { delete t[e] } catch (e) {} })) }(n))), n.destroyed = !0), null; } }], [{ key: 'extendDefaults', value(e) { w(ce, e); } }, { key: 'extendedDefaults', get() { return ce; } }, { key: 'defaults', get() { return ae; } }, { key: 'installModule', value(t) { e.prototype.__modules__ || (e.prototype.__modules__ = []); let n = e.prototype.__modules__; 'function' === typeof t && n.indexOf(t) < 0 && n.push(t); } }, { key: 'use', value(t) { return Array.isArray(t) ? (t.forEach(((t) => { return e.installModule(t); })), e) : (e.installModule(t), e); } }]));
        }()); function de(e, t, n, r) { return e.params.createElements && Object.keys(r).forEach(((i) => { if (!n[i] && !0 === n.auto) { let o = T(e.el, '.'.concat(r[i]))[0]; o || ((o = C('div', r[i])).className = r[i], e.el.append(o)), n[i] = o, t[i] = o; } })), n; } function pe(e) { return void 0 === e && (e = ''), '.'.concat(e.trim().replace(/([\.:!+\/])/g, '\\$1').replace(/ /g, '.')); } function fe(e) { const t = this; const n = t.params; const r = t.slidesEl; n.loop && t.loopDestroy(); const i = function (e) { if (typeof e === 'string') { const t = document.createElement('div'); t.innerHTML = e, r.append(t.children[0]), t.innerHTML = ''; } else r.append(e); }; if (p(e) == 'object' && 'length' in e) for (let o = 0; o < e.length; o += 1)e[o] && i(e[o]); else i(e); t.recalcSlides(), n.loop && t.loopCreate(), n.observer && !t.isElement || t.update(); } function he(e) { const t = this; const n = t.params; const r = t.activeIndex; const i = t.slidesEl; n.loop && t.loopDestroy(); let o = r + 1; const a = function (e) { if (typeof e === 'string') { const t = document.createElement('div'); t.innerHTML = e, i.prepend(t.children[0]), t.innerHTML = ''; } else i.prepend(e); }; if (p(e) == 'object' && 'length' in e) { for (let s = 0; s < e.length; s += 1)e[s] && a(e[s]); o = r + e.length; } else a(e); t.recalcSlides(), n.loop && t.loopCreate(), n.observer && !t.isElement || t.update(), t.slideTo(o, 0, !1); } function me(e, t) { const n = this; const r = n.params; const i = n.activeIndex; const o = n.slidesEl; let a = i; r.loop && (a -= n.loopedSlides, n.loopDestroy(), n.recalcSlides()); const s = n.slides.length; if (e <= 0)n.prependSlide(t); else if (e >= s)n.appendSlide(t); else { for (var l = a > e ? a + 1 : a, c = [], u = s - 1; u >= e; u -= 1) { const d = n.slides[u]; d.remove(), c.unshift(d); } if (p(t) == 'object' && 'length' in t) { for (let f = 0; f < t.length; f += 1)t[f] && o.append(t[f]); l = a > e ? a + t.length : a; } else o.append(t); for (let h = 0; h < c.length; h += 1)o.append(c[h]); n.recalcSlides(), r.loop && n.loopCreate(), r.observer && !n.isElement || n.update(), r.loop ? n.slideTo(l + n.loopedSlides, 0, !1) : n.slideTo(l, 0, !1); } } function ve(e) { const t = this; const n = t.params; let r = t.activeIndex; n.loop && (r -= t.loopedSlides, t.loopDestroy()); let i; let o = r; if (p(e) == 'object' && 'length' in e) { for (let a = 0; a < e.length; a += 1)i = e[a], t.slides[i] && t.slides[i].remove(), i < o && (o -= 1); o = Math.max(o, 0); } else i = e, t.slides[i] && t.slides[i].remove(), i < o && (o -= 1), o = Math.max(o, 0); t.recalcSlides(), n.loop && t.loopCreate(), n.observer && !t.isElement || t.update(), n.loop ? t.slideTo(o + t.loopedSlides, 0, !1) : t.slideTo(o, 0, !1); } function ge() { for (var e = [], t = 0; t < this.slides.length; t += 1)e.push(t); this.removeSlide(e); } function ye(e) { let t; const n = e.effect; const r = e.swiper; const i = e.on; const o = e.setTranslate; const a = e.setTransition; const s = e.overwriteParams; const l = e.perspective; const c = e.recreateShadows; const u = e.getEffectParams; i('beforeInit', (() => { if (r.params.effect === n) { r.classNames.push(''.concat(r.params.containerModifierClass).concat(n)), l && l() && r.classNames.push(''.concat(r.params.containerModifierClass, '3d')); const e = s ? s() : {}; Object.assign(r.params, e), Object.assign(r.originalParams, e); } })), i('setTranslate', (() => { r.params.effect === n && o(); })), i('setTransition', ((e, t) => { r.params.effect === n && a(t); })), i('transitionEnd', (() => { if (r.params.effect === n && c) { if (!u || !u().slideShadows) return; r.slides.forEach(((e) => { e.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(((e) => e.remove())); })), c(); } })), i('virtualUpdate', (() => { r.params.effect === n && (r.slides.length || (t = !0), requestAnimationFrame((() => { t && r.slides && r.slides.length && (o(), t = !1); }))); })); } function be(e, t) { const n = E(t); return n !== t && (n.style.backfaceVisibility = 'hidden', n.style['-webkit-backface-visibility'] = 'hidden'), n; } function we(e) { const t = e.swiper; const n = e.duration; const r = e.transformElements; const i = e.allSlides; const o = t.activeIndex; if (t.params.virtualTranslate && n !== 0) { let a; let s = !1; a = i ? r : r.filter(((e) => { const n = e.classList.contains('swiper-slide-transform') ? (function (e) { return e.parentElement ? e.parentElement : t.slides.filter(((t) => t.shadowRoot && t.shadowRoot === e.parentNode))[0]; }(e)) : e; return t.getSlideIndex(n) === o; })), a.forEach(((e) => { O(e, (() => { if (!s && t && !t.destroyed) { s = !0, t.animating = !1; const e = new window.CustomEvent('transitionend', { bubbles: !0, cancelable: !0 }); t.wrapperEl.dispatchEvent(e); } })); })); } } function Se(e, t, n) { const r = 'swiper-slide-shadow'.concat(n ? '-'.concat(n) : '').concat(e ? ' swiper-slide-shadow-'.concat(e) : ''); const i = E(t); let o = i.querySelector('.'.concat(r.split(' ').join('.'))); return o || (o = C('div', r.split(' ')), i.append(o)), o; }Object.keys(le).forEach(((e) => { Object.keys(le[e]).forEach(((t) => { ue.prototype[t] = le[e][t]; })); })), ue.use([function (e) { const t = e.swiper; const n = e.on; const r = e.emit; const i = h(); let o = null; let a = null; const s = function () { t && !t.destroyed && t.initialized && (r('beforeResize'), r('resize')); }; const l = function () { t && !t.destroyed && t.initialized && r('orientationchange'); }; n('init', (() => { t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (o = new ResizeObserver(((e) => { a = i.requestAnimationFrame((() => { const n = t.width; const r = t.height; let i = n; let o = r; e.forEach(((e) => { const n = e.contentBoxSize; const r = e.contentRect; const a = e.target; a && a !== t.el || (i = r ? r.width : (n[0] || n).inlineSize, o = r ? r.height : (n[0] || n).blockSize); })), i === n && o === r || s(); })); })), o.observe(t.el)) : (i.addEventListener('resize', s), i.addEventListener('orientationchange', l)); })), n('destroy', (() => { a && i.cancelAnimationFrame(a), o && o.unobserve && t.el && (o.unobserve(t.el), o = null), i.removeEventListener('resize', s), i.removeEventListener('orientationchange', l); })); }, function (e) { const t = e.swiper; const n = e.extendParams; const r = e.on; const i = e.emit; const o = []; const a = h(); const s = function (e, n) { void 0 === n && (n = {}); const r = new (a.MutationObserver || a.WebkitMutationObserver)(((e) => { if (!t.__preventObserver__) if (e.length !== 1) { const n = function () { i('observerUpdate', e[0]); }; a.requestAnimationFrame ? a.requestAnimationFrame(n) : a.setTimeout(n, 0); } else i('observerUpdate', e[0]); })); r.observe(e, { attributes: void 0 === n.attributes || n.attributes, childList: t.isElement || (void 0 === n.childList || n).childList, characterData: void 0 === n.characterData || n.characterData }), o.push(r); }; n({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), r('init', (() => { if (t.params.observer) { if (t.params.observeParents) for (let e = A(t.hostEl), n = 0; n < e.length; n += 1)s(e[n]); s(t.hostEl, { childList: t.params.observeSlideChildren }), s(t.wrapperEl, { attributes: !1 }); } })), r('destroy', (() => { o.forEach(((e) => { e.disconnect(); })), o.splice(0, o.length); })); }]); const xe = [function (e) {
          let t; const n = e.swiper; const r = e.extendParams; const o = e.on; const a = e.emit; r({
            virtual: {
              enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0,
            },
          }); const l = i(); n.virtual = {
            cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [],
          }; const c = l.createElement('div'); function u(e, t) { let r; const i = n.params.virtual; return i.cache && n.virtual.cache[t] ? n.virtual.cache[t] : (i.renderSlide ? typeof (r = i.renderSlide.call(n, e, t)) === 'string' && (c.innerHTML = r, r = c.children[0]) : r = n.isElement ? C('swiper-slide') : C('div', n.params.slideClass), r.setAttribute('data-swiper-slide-index', t), i.renderSlide || (r.innerHTML = e), i.cache && (n.virtual.cache[t] = r), r); } function d(e, t) {
            const r = n.params; const i = r.slidesPerView; const o = r.slidesPerGroup; const s = r.centeredSlides; const l = r.loop; const c = r.initialSlide; if (!(t && !l && c > 0)) {
              const d = n.params.virtual; const p = d.addSlidesBefore; const f = d.addSlidesAfter; const h = n.virtual; const m = h.from; const v = h.to; const g = h.slides; const y = h.slidesGrid; const b = h.offset; n.params.cssMode || n.updateActiveIndex(); let w; let S; let x; const E = n.activeIndex || 0; w = n.rtlTranslate ? 'right' : n.isHorizontal() ? 'left' : 'top', s ? (S = Math.floor(i / 2) + o + f, x = Math.floor(i / 2) + o + p) : (S = i + (o - 1) + f, x = (l ? i : o) + p); let _ = E - x; let C = E + S; l || (_ = Math.max(_, 0), C = Math.min(C, g.length - 1)); let L = (n.slidesGrid[_] || 0) - (n.slidesGrid[0] || 0); if (l && E >= x ? (_ -= x, s || (L += n.slidesGrid[0])) : l && E < x && (_ = -x, s && (L += n.slidesGrid[0])), Object.assign(n.virtual, {
                from: _, to: C, offset: L, slidesGrid: n.slidesGrid, slidesBefore: x, slidesAfter: S,
              }), m === _ && v === C && !e) return n.slidesGrid !== y && L !== b && n.slides.forEach(((e) => { e.style[w] = `${L - Math.abs(n.cssOverflowAdjustment())}px`; })), n.updateProgress(), void a('virtualUpdate'); if (n.params.virtual.renderExternal) {
 return n.params.virtual.renderExternal.call(n, {
                offset: L, from: _, to: C, slides: (function () { for (var e = [], t = _; t <= C; t += 1)e.push(g[t]); return e; }()),
              }), void (n.params.virtual.renderExternalUpdate ? F() : a('virtualUpdate')); 
} const k = []; const M = []; const A = function (e) { let t = e; return e < 0 ? t = g.length + e : t >= g.length && (t -= g.length), t; }; if (e)n.slides.filter(((e) => e.matches('.'.concat(n.params.slideClass, ', swiper-slide')))).forEach(((e) => { e.remove(); })); else for (var O = function () { if (P < _ || P > C) { const e = A(P); n.slides.filter(((t) => t.matches('.'.concat(n.params.slideClass, '[data-swiper-slide-index="').concat(e, '"], swiper-slide[data-swiper-slide-index="').concat(e, '"]')))).forEach(((e) => { e.remove(); })); } }, P = m; P <= v; P += 1)O(); for (let I = l ? -g.length : 0, N = l ? 2 * g.length : g.length, D = I; D < N; D += 1) if (D >= _ && D <= C) { const R = A(D); void 0 === v || e ? M.push(R) : (D > v && M.push(R), D < m && k.push(R)); } if (M.forEach(((e) => { n.slidesEl.append(u(g[e], e)); })), l) for (let j = k.length - 1; j >= 0; j -= 1) { const V = k[j]; n.slidesEl.prepend(u(g[V], V)); } else k.sort(((e, t) => t - e)), k.forEach(((e) => { n.slidesEl.prepend(u(g[e], e)); })); T(n.slidesEl, '.swiper-slide, swiper-slide').forEach(((e) => { e.style[w] = `${L - Math.abs(n.cssOverflowAdjustment())}px`; })), F();
            } function F() { n.updateSlides(), n.updateProgress(), n.updateSlidesClasses(), a('virtualUpdate'); }
          }o('beforeInit', (() => { if (n.params.virtual.enabled) { let e; if (void 0 === n.passedParams.virtual.slides) { const t = s(n.slidesEl.children).filter(((e) => e.matches('.'.concat(n.params.slideClass, ', swiper-slide')))); t && t.length && (n.virtual.slides = s(t), e = !0, t.forEach(((e, t) => { e.setAttribute('data-swiper-slide-index', t), n.virtual.cache[t] = e, e.remove(); }))); }e || (n.virtual.slides = n.params.virtual.slides), n.classNames.push(''.concat(n.params.containerModifierClass, 'virtual')), n.params.watchSlidesProgress = !0, n.originalParams.watchSlidesProgress = !0, d(!1, !0); } })), o('setTranslate', (() => { n.params.virtual.enabled && (n.params.cssMode && !n._immediateVirtual ? (clearTimeout(t), t = setTimeout((() => { d(); }), 100)) : d()); })), o('init update resize', (() => { n.params.virtual.enabled && n.params.cssMode && S(n.wrapperEl, '--swiper-virtual-size', ''.concat(n.virtualSize, 'px')); })), Object.assign(n.virtual, {
            appendSlide(e) { if (p(e) == 'object' && 'length' in e) for (let t = 0; t < e.length; t += 1)e[t] && n.virtual.slides.push(e[t]); else n.virtual.slides.push(e); d(!0); }, prependSlide(e) { const t = n.activeIndex; let r = t + 1; let i = 1; if (Array.isArray(e)) { for (let o = 0; o < e.length; o += 1)e[o] && n.virtual.slides.unshift(e[o]); r = t + e.length, i = e.length; } else n.virtual.slides.unshift(e); if (n.params.virtual.cache) { const a = n.virtual.cache; const s = {}; Object.keys(a).forEach(((e) => { const t = a[e]; const n = t.getAttribute('data-swiper-slide-index'); n && t.setAttribute('data-swiper-slide-index', parseInt(n, 10) + i), s[parseInt(e, 10) + i] = t; })), n.virtual.cache = s; }d(!0), n.slideTo(r, 0); }, removeSlide(e) { if (e != null) { let t = n.activeIndex; if (Array.isArray(e)) for (let r = e.length - 1; r >= 0; r -= 1)n.params.virtual.cache && (delete n.virtual.cache[e[r]], Object.keys(n.virtual.cache).forEach(((t) => { t > e && (n.virtual.cache[t - 1] = n.virtual.cache[t], n.virtual.cache[t - 1].setAttribute('data-swiper-slide-index', t - 1), delete n.virtual.cache[t]); }))), n.virtual.slides.splice(e[r], 1), e[r] < t && (t -= 1), t = Math.max(t, 0); else n.params.virtual.cache && (delete n.virtual.cache[e], Object.keys(n.virtual.cache).forEach(((t) => { t > e && (n.virtual.cache[t - 1] = n.virtual.cache[t], n.virtual.cache[t - 1].setAttribute('data-swiper-slide-index', t - 1), delete n.virtual.cache[t]); }))), n.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0); d(!0), n.slideTo(t, 0); } }, removeAllSlides() { n.virtual.slides = [], n.params.virtual.cache && (n.virtual.cache = {}), d(!0), n.slideTo(0, 0); }, update: d,
          });
        }, function (e) { const t = e.swiper; const n = e.extendParams; const r = e.on; const o = e.emit; const a = i(); const s = h(); function l(e) { if (t.enabled) { const n = t.rtlTranslate; let r = e; r.originalEvent && (r = r.originalEvent); const i = r.keyCode || r.charCode; const l = t.params.keyboard.pageUpDown; const c = l && i === 33; const u = l && i === 34; const d = i === 37; const p = i === 39; const f = i === 38; const h = i === 40; if (!t.allowSlideNext && (t.isHorizontal() && p || t.isVertical() && h || u)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && d || t.isVertical() && f || c)) return !1; if (!(r.shiftKey || r.altKey || r.ctrlKey || r.metaKey || a.activeElement && a.activeElement.nodeName && (a.activeElement.nodeName.toLowerCase() === 'input' || a.activeElement.nodeName.toLowerCase() === 'textarea'))) { if (t.params.keyboard.onlyInViewport && (c || u || d || p || f || h)) { let m = !1; if (A(t.el, '.'.concat(t.params.slideClass, ', swiper-slide')).length > 0 && A(t.el, '.'.concat(t.params.slideActiveClass)).length === 0) return; const v = t.el; const g = v.clientWidth; const y = v.clientHeight; const b = s.innerWidth; const w = s.innerHeight; const S = L(v); n && (S.left -= v.scrollLeft); for (let x = [[S.left, S.top], [S.left + g, S.top], [S.left, S.top + y], [S.left + g, S.top + y]], E = 0; E < x.length; E += 1) { const T = x[E]; if (T[0] >= 0 && T[0] <= b && T[1] >= 0 && T[1] <= w) { if (T[0] === 0 && T[1] === 0) continue; m = !0; } } if (!m) return; }t.isHorizontal() ? ((c || u || d || p) && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), ((u || p) && !n || (c || d) && n) && t.slideNext(), ((c || d) && !n || (u || p) && n) && t.slidePrev()) : ((c || u || f || h) && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), (u || h) && t.slideNext(), (c || f) && t.slidePrev()), o('keyPress', i); } } } function c() { t.keyboard.enabled || (a.addEventListener('keydown', l), t.keyboard.enabled = !0); } function u() { t.keyboard.enabled && (a.removeEventListener('keydown', l), t.keyboard.enabled = !1); }t.keyboard = { enabled: !1 }, n({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), r('init', (() => { t.params.keyboard.enabled && c(); })), r('destroy', (() => { t.keyboard.enabled && u(); })), Object.assign(t.keyboard, { enable: c, disable: u }); }, function (e) {
          let t; const n = e.swiper; const r = e.extendParams; const i = e.on; const o = e.emit; const a = h(); r({
            mousewheel: {
              enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: 'container', thresholdDelta: null, thresholdTime: null, noMousewheelClass: 'swiper-no-mousewheel',
            },
          }), n.mousewheel = { enabled: !1 }; let s; let l = g(); const c = []; function u() { n.enabled && (n.mouseEntered = !0); } function d() { n.enabled && (n.mouseEntered = !1); } function p(e) { return !(n.params.mousewheel.thresholdDelta && e.delta < n.params.mousewheel.thresholdDelta || n.params.mousewheel.thresholdTime && g() - l < n.params.mousewheel.thresholdTime || !(e.delta >= 6 && g() - l < 60) && (e.direction < 0 ? n.isEnd && !n.params.loop || n.animating || (n.slideNext(), o('scroll', e.raw)) : n.isBeginning && !n.params.loop || n.animating || (n.slidePrev(), o('scroll', e.raw)), l = (new a.Date()).getTime(), 1)); } function f(e) {
            let r = e; if (n.enabled && !e.target.closest('.'.concat(n.params.mousewheel.noMousewheelClass))) {
              const i = n.params.mousewheel; n.params.cssMode && r.preventDefault(); let a = n.el; n.params.mousewheel.eventsTarget !== 'container' && (a = document.querySelector(n.params.mousewheel.eventsTarget)); const l = a && a.contains(r.target); if (!n.mouseEntered && !l && !i.releaseOnEdges) return !0; r.originalEvent && (r = r.originalEvent); let u = 0; const d = n.rtlTranslate ? -1 : 1; const f = (function (e) {
 let t = 0; let n = 0; let r = 0; let i = 0; return 'detail' in e && (n = e.detail), 'wheelDelta' in e && (n = -e.wheelDelta / 120), 'wheelDeltaY' in e && (n = -e.wheelDeltaY / 120), 'wheelDeltaX' in e && (t = -e.wheelDeltaX / 120), 'axis' in e && e.axis === e.HORIZONTAL_AXIS && (t = n, n = 0), r = 10 * t, i = 10 * n, 'deltaY' in e && (i = e.deltaY), 'deltaX' in e && (r = e.deltaX), e.shiftKey && !r && (r = i, i = 0), (r || i) && e.deltaMode && (e.deltaMode === 1 ? (r *= 40, i *= 40) : (r *= 800, i *= 800)), r && !t && (t = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), {
                spinX: t, spinY: n, pixelX: r, pixelY: i, 
}; 
}(r)); if (i.forceToAxis) if (n.isHorizontal()) { if (!(Math.abs(f.pixelX) > Math.abs(f.pixelY))) return !0; u = -f.pixelX * d; } else { if (!(Math.abs(f.pixelY) > Math.abs(f.pixelX))) return !0; u = -f.pixelY; } else u = Math.abs(f.pixelX) > Math.abs(f.pixelY) ? -f.pixelX * d : -f.pixelY; if (u === 0) return !0; i.invert && (u = -u); let h = n.getTranslate() + u * i.sensitivity; if (h >= n.minTranslate() && (h = n.minTranslate()), h <= n.maxTranslate() && (h = n.maxTranslate()), (!!n.params.loop || !(h === n.minTranslate() || h === n.maxTranslate())) && n.params.nested && r.stopPropagation(), n.params.freeMode && n.params.freeMode.enabled) { const m = { time: g(), delta: Math.abs(u), direction: Math.sign(u) }; const y = s && m.time < s.time + 500 && m.delta <= s.delta && m.direction === s.direction; if (!y) { s = void 0; let b = n.getTranslate() + u * i.sensitivity; const w = n.isBeginning; const S = n.isEnd; if (b >= n.minTranslate() && (b = n.minTranslate()), b <= n.maxTranslate() && (b = n.maxTranslate()), n.setTransition(0), n.setTranslate(b), n.updateProgress(), n.updateActiveIndex(), n.updateSlidesClasses(), (!w && n.isBeginning || !S && n.isEnd) && n.updateSlidesClasses(), n.params.loop && n.loopFix({ direction: m.direction < 0 ? 'next' : 'prev', byMousewheel: !0 }), n.params.freeMode.sticky) { clearTimeout(t), t = void 0, c.length >= 15 && c.shift(); const x = c.length ? c[c.length - 1] : void 0; const E = c[0]; if (c.push(m), x && (m.delta > x.delta || m.direction !== x.direction))c.splice(0); else if (c.length >= 15 && m.time - E.time < 500 && E.delta - m.delta >= 1 && m.delta <= 6) { const T = u > 0 ? 0.8 : 0.2; s = m, c.splice(0), t = v((() => { !n.destroyed && n.params && n.slideToClosest(n.params.speed, !0, void 0, T); }), 0); }t || (t = v((() => { !n.destroyed && n.params && (s = m, c.splice(0), n.slideToClosest(n.params.speed, !0, void 0, 0.5)); }), 500)); } if (y || o('scroll', r), n.params.autoplay && n.params.autoplayDisableOnInteraction && n.autoplay.stop(), i.releaseOnEdges && (b === n.minTranslate() || b === n.maxTranslate())) return !0; } } else {
                const _ = {
                  time: g(), delta: Math.abs(u), direction: Math.sign(u), raw: e,
                }; c.length >= 2 && c.shift(); const C = c.length ? c[c.length - 1] : void 0; if (c.push(_), C ? (_.direction !== C.direction || _.delta > C.delta || _.time > C.time + 150) && p(_) : p(_), (function (e) { const t = n.params.mousewheel; if (e.direction < 0) { if (n.isEnd && !n.params.loop && t.releaseOnEdges) return !0; } else if (n.isBeginning && !n.params.loop && t.releaseOnEdges) return !0; return !1; }(_))) return !0;
              } return r.preventDefault ? r.preventDefault() : r.returnValue = !1, !1;
            }
          } function m(e) { let t = n.el; n.params.mousewheel.eventsTarget !== 'container' && (t = document.querySelector(n.params.mousewheel.eventsTarget)), t[e]('mouseenter', u), t[e]('mouseleave', d), t[e]('wheel', f); } function y() { return n.params.cssMode ? (n.wrapperEl.removeEventListener('wheel', f), !0) : !n.mousewheel.enabled && (m('addEventListener'), n.mousewheel.enabled = !0, !0); } function b() { return n.params.cssMode ? (n.wrapperEl.addEventListener(event, f), !0) : !!n.mousewheel.enabled && (m('removeEventListener'), n.mousewheel.enabled = !1, !0); }i('init', (() => { !n.params.mousewheel.enabled && n.params.cssMode && b(), n.params.mousewheel.enabled && y(); })), i('destroy', (() => { n.params.cssMode && y(), n.mousewheel.enabled && b(); })), Object.assign(n.mousewheel, { enable: y, disable: b });
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; const i = e.emit; function o(e) { let n; return e && typeof e === 'string' && t.isElement && (n = t.el.querySelector(e)) ? n : (e && (typeof e === 'string' && (n = s(document.querySelectorAll(e))), t.params.uniqueNavElements && typeof e === 'string' && n && n.length > 1 && t.el.querySelectorAll(e).length === 1 ? n = t.el.querySelector(e) : n && n.length === 1 && (n = n[0])), e && !n ? e : n); } function a(e, n) { const r = t.params.navigation; (e = I(e)).forEach(((e) => { let i; e && ((i = e.classList)[n ? 'add' : 'remove'].apply(i, s(r.disabledClass.split(' '))), e.tagName === 'BUTTON' && (e.disabled = n), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? 'add' : 'remove'](r.lockClass)); })); } function l() { const e = t.navigation; const n = e.nextEl; const r = e.prevEl; if (t.params.loop) return a(r, !1), void a(n, !1); a(r, t.isBeginning && !t.params.rewind), a(n, t.isEnd && !t.params.rewind); } function c(e) { e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), i('navigationPrev')); } function u(e) { e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), i('navigationNext')); } function d() { const e = t.params.navigation; if (t.params.navigation = de(t, t.originalParams.navigation, t.params.navigation, { nextEl: 'swiper-button-next', prevEl: 'swiper-button-prev' }), e.nextEl || e.prevEl) { let n = o(e.nextEl); let r = o(e.prevEl); Object.assign(t.navigation, { nextEl: n, prevEl: r }), n = I(n), r = I(r); const i = function (n, r) { let i; n && n.addEventListener('click', r === 'next' ? u : c), !t.enabled && n && (i = n.classList).add.apply(i, s(e.lockClass.split(' '))); }; n.forEach(((e) => i(e, 'next'))), r.forEach(((e) => i(e, 'prev'))); } } function p() { const e = t.navigation; let n = e.nextEl; let r = e.prevEl; n = I(n), r = I(r); const i = function (e, n) { let r; e.removeEventListener('click', n === 'next' ? u : c), (r = e.classList).remove.apply(r, s(t.params.navigation.disabledClass.split(' '))); }; n.forEach(((e) => i(e, 'next'))), r.forEach(((e) => i(e, 'prev'))); }n({
            navigation: {
              nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: 'swiper-button-disabled', hiddenClass: 'swiper-button-hidden', lockClass: 'swiper-button-lock', navigationDisabledClass: 'swiper-navigation-disabled',
            },
          }), t.navigation = { nextEl: null, prevEl: null }, r('init', (() => { !1 === t.params.navigation.enabled ? f() : (d(), l()); })), r('toEdge fromEdge lock unlock', (() => { l(); })), r('destroy', (() => { p(); })), r('enable disable', (() => { const e = t.navigation; let n = e.nextEl; let r = e.prevEl; n = I(n), r = I(r), t.enabled ? l() : [].concat(s(n), s(r)).filter(((e) => !!e)).forEach(((e) => e.classList.add(t.params.navigation.lockClass))); })), r('click', ((e, n) => { const r = t.navigation; let o = r.nextEl; let a = r.prevEl; o = I(o), a = I(a); const l = n.target; let c = a.includes(l) || o.includes(l); if (t.isElement && !c) { const u = n.path || n.composedPath && n.composedPath(); u && (c = u.find(((e) => o.includes(e) || a.includes(e)))); } if (t.params.navigation.hideOnClick && !c) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === l || t.pagination.el.contains(l))) return; let d; o.length ? d = o[0].classList.contains(t.params.navigation.hiddenClass) : a.length && (d = a[0].classList.contains(t.params.navigation.hiddenClass)), i(!0 === d ? 'navigationShow' : 'navigationHide'), [].concat(s(o), s(a)).filter(((e) => !!e)).forEach(((e) => e.classList.toggle(t.params.navigation.hiddenClass))); } })); var f = function () { let e; (e = t.el.classList).add.apply(e, s(t.params.navigation.navigationDisabledClass.split(' '))), p(); }; Object.assign(t.navigation, {
            enable() { let e; (e = t.el.classList).remove.apply(e, s(t.params.navigation.navigationDisabledClass.split(' '))), d(), l(); }, disable: f, update: l, init: d, destroy: p,
          });
        }, function (e) {
          let t; const n = e.swiper; const r = e.extendParams; const i = e.on; const o = e.emit; const a = 'swiper-pagination'; r({
            pagination: {
              el: null, bulletElement: 'span', clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: 'bullets', dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent(e) { return e; }, formatFractionTotal(e) { return e; }, bulletClass: ''.concat(a, '-bullet'), bulletActiveClass: ''.concat(a, '-bullet-active'), modifierClass: ''.concat(a, '-'), currentClass: ''.concat(a, '-current'), totalClass: ''.concat(a, '-total'), hiddenClass: ''.concat(a, '-hidden'), progressbarFillClass: ''.concat(a, '-progressbar-fill'), progressbarOppositeClass: ''.concat(a, '-progressbar-opposite'), clickableClass: ''.concat(a, '-clickable'), lockClass: ''.concat(a, '-lock'), horizontalClass: ''.concat(a, '-horizontal'), verticalClass: ''.concat(a, '-vertical'), paginationDisabledClass: ''.concat(a, '-disabled'),
            },
          }), n.pagination = { el: null, bullets: [] }; let l = 0; function c() { return !n.params.pagination.el || !n.pagination.el || Array.isArray(n.pagination.el) && n.pagination.el.length === 0; } function u(e, t) { const r = n.params.pagination.bulletActiveClass; e && (e = e[`${t === 'prev' ? 'previous' : 'next'}ElementSibling`]) && (e.classList.add(''.concat(r, '-').concat(t)), (e = e[`${t === 'prev' ? 'previous' : 'next'}ElementSibling`]) && e.classList.add(''.concat(r, '-').concat(t, '-').concat(t))); } function d(e) { const t = e.target.closest(pe(n.params.pagination.bulletClass)); if (t) { e.preventDefault(); let r; let i; let o; const a = M(t) * n.params.slidesPerGroup; if (n.params.loop) { if (n.realIndex === a) return; const s = (r = n.realIndex, i = a, (i %= o = n.slides.length) == 1 + (r %= o) ? 'next' : i === r - 1 ? 'previous' : void 0); s === 'next' ? n.slideNext() : s === 'previous' ? n.slidePrev() : n.slideToLoop(a); } else n.slideTo(a); } } function p() { const e = n.rtl; const r = n.params.pagination; if (!c()) { let i; let a; let d = n.pagination.el; d = I(d); const p = n.virtual && n.params.virtual.enabled ? n.virtual.slides.length : n.slides.length; const f = n.params.loop ? Math.ceil(p / n.params.slidesPerGroup) : n.snapGrid.length; if (n.params.loop ? (a = n.previousRealIndex || 0, i = n.params.slidesPerGroup > 1 ? Math.floor(n.realIndex / n.params.slidesPerGroup) : n.realIndex) : void 0 !== n.snapIndex ? (i = n.snapIndex, a = n.previousSnapIndex) : (a = n.previousIndex || 0, i = n.activeIndex || 0), r.type === 'bullets' && n.pagination.bullets && n.pagination.bullets.length > 0) { let h; let m; let v; const g = n.pagination.bullets; if (r.dynamicBullets && (t = P(g[0], n.isHorizontal() ? 'width' : 'height', !0), d.forEach(((e) => { e.style[n.isHorizontal() ? 'width' : 'height'] = `${t * (r.dynamicMainBullets + 4)}px`; })), r.dynamicMainBullets > 1 && void 0 !== a && ((l += i - (a || 0)) > r.dynamicMainBullets - 1 ? l = r.dynamicMainBullets - 1 : l < 0 && (l = 0)), h = Math.max(i - l, 0), v = ((m = h + (Math.min(g.length, r.dynamicMainBullets) - 1)) + h) / 2), g.forEach(((e) => { let t; const n = s(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(((e) => ''.concat(r.bulletActiveClass).concat(e)))).map(((e) => typeof e === 'string' && e.includes(' ') ? e.split(' ') : e)).flat(); (t = e.classList).remove.apply(t, s(n)); })), d.length > 1)g.forEach(((e) => { let t; let o; const a = M(e); a === i ? (t = e.classList).add.apply(t, s(r.bulletActiveClass.split(' '))) : n.isElement && e.setAttribute('part', 'bullet'), r.dynamicBullets && (a >= h && a <= m && (o = e.classList).add.apply(o, s(''.concat(r.bulletActiveClass, '-main').split(' '))), a === h && u(e, 'prev'), a === m && u(e, 'next')); })); else { let y; const b = g[i]; if (b && (y = b.classList).add.apply(y, s(r.bulletActiveClass.split(' '))), n.isElement && g.forEach(((e, t) => { e.setAttribute('part', t === i ? 'bullet-active' : 'bullet'); })), r.dynamicBullets) { for (var w = g[h], S = g[m], x = h; x <= m; x += 1) { var E; g[x] && (E = g[x].classList).add.apply(E, s(''.concat(r.bulletActiveClass, '-main').split(' '))); }u(w, 'prev'), u(S, 'next'); } } if (r.dynamicBullets) { const T = Math.min(g.length, r.dynamicMainBullets + 4); const _ = (t * T - t) / 2 - v * t; const C = e ? 'right' : 'left'; g.forEach(((e) => { e.style[n.isHorizontal() ? C : 'top'] = ''.concat(_, 'px'); })); } }d.forEach(((e, t) => { if (r.type === 'fraction' && (e.querySelectorAll(pe(r.currentClass)).forEach(((e) => { e.textContent = r.formatFractionCurrent(i + 1); })), e.querySelectorAll(pe(r.totalClass)).forEach(((e) => { e.textContent = r.formatFractionTotal(f); }))), r.type === 'progressbar') { let a; a = r.progressbarOpposite ? n.isHorizontal() ? 'vertical' : 'horizontal' : n.isHorizontal() ? 'horizontal' : 'vertical'; const s = (i + 1) / f; let l = 1; let c = 1; a === 'horizontal' ? l = s : c = s, e.querySelectorAll(pe(r.progressbarFillClass)).forEach(((e) => { e.style.transform = 'translate3d(0,0,0) scaleX('.concat(l, ') scaleY(').concat(c, ')'), e.style.transitionDuration = ''.concat(n.params.speed, 'ms'); })); }r.type === 'custom' && r.renderCustom ? (e.innerHTML = r.renderCustom(n, i + 1, f), t === 0 && o('paginationRender', e)) : (t === 0 && o('paginationRender', e), o('paginationUpdate', e)), n.params.watchOverflow && n.enabled && e.classList[n.isLocked ? 'add' : 'remove'](r.lockClass); })); } } function f() { const e = n.params.pagination; if (!c()) { const t = n.virtual && n.params.virtual.enabled ? n.virtual.slides.length : n.grid && n.params.grid.rows > 1 ? n.slides.length / Math.ceil(n.params.grid.rows) : n.slides.length; let r = n.pagination.el; r = I(r); let i = ''; if (e.type === 'bullets') { let a = n.params.loop ? Math.ceil(t / n.params.slidesPerGroup) : n.snapGrid.length; n.params.freeMode && n.params.freeMode.enabled && a > t && (a = t); for (let l = 0; l < a; l += 1)e.renderBullet ? i += e.renderBullet.call(n, l, e.bulletClass) : i += '<'.concat(e.bulletElement, ' ').concat(n.isElement ? 'part="bullet"' : '', ' class="').concat(e.bulletClass, '"></').concat(e.bulletElement, '>'); }e.type === 'fraction' && (i = e.renderFraction ? e.renderFraction.call(n, e.currentClass, e.totalClass) : '<span class="'.concat(e.currentClass, '"></span> / <span class="').concat(e.totalClass, '"></span>')), e.type === 'progressbar' && (i = e.renderProgressbar ? e.renderProgressbar.call(n, e.progressbarFillClass) : '<span class="'.concat(e.progressbarFillClass, '"></span>')), n.pagination.bullets = [], r.forEach(((t) => { let r; e.type !== 'custom' && (t.innerHTML = i || ''), e.type === 'bullets' && (r = n.pagination.bullets).push.apply(r, s(t.querySelectorAll(pe(e.bulletClass)))); })), e.type !== 'custom' && o('paginationRender', r[0]); } } function h() { n.params.pagination = de(n, n.originalParams.pagination, n.params.pagination, { el: 'swiper-pagination' }); let e; const t = n.params.pagination; t.el && (typeof t.el === 'string' && n.isElement && (e = n.el.querySelector(t.el)), e || typeof t.el !== 'string' || (e = s(document.querySelectorAll(t.el))), e || (e = t.el), e && e.length !== 0 && (n.params.uniqueNavElements && typeof t.el === 'string' && Array.isArray(e) && e.length > 1 && (e = s(n.el.querySelectorAll(t.el))).length > 1 && (e = e.filter(((e) => A(e, '.swiper')[0] === n.el))[0]), Array.isArray(e) && e.length === 1 && (e = e[0]), Object.assign(n.pagination, { el: e }), (e = I(e)).forEach(((e) => { let r; t.type === 'bullets' && t.clickable && (r = e.classList).add.apply(r, s((t.clickableClass || '').split(' '))), e.classList.add(t.modifierClass + t.type), e.classList.add(n.isHorizontal() ? t.horizontalClass : t.verticalClass), t.type === 'bullets' && t.dynamicBullets && (e.classList.add(''.concat(t.modifierClass).concat(t.type, '-dynamic')), l = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), t.type === 'progressbar' && t.progressbarOpposite && e.classList.add(t.progressbarOppositeClass), t.clickable && e.addEventListener('click', d), n.enabled || e.classList.add(t.lockClass); })))); } function m() { const e = n.params.pagination; if (!c()) { let t = n.pagination.el; t && (t = I(t)).forEach(((t) => { let r; t.classList.remove(e.hiddenClass), t.classList.remove(e.modifierClass + e.type), t.classList.remove(n.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && ((r = t.classList).remove.apply(r, s((e.clickableClass || '').split(' '))), t.removeEventListener('click', d)); })), n.pagination.bullets && n.pagination.bullets.forEach(((t) => { let n; return (n = t.classList).remove.apply(n, s(e.bulletActiveClass.split(' '))); })); } }i('changeDirection', (() => { if (n.pagination && n.pagination.el) { const e = n.params.pagination; let t = n.pagination.el; (t = I(t)).forEach(((t) => { t.classList.remove(e.horizontalClass, e.verticalClass), t.classList.add(n.isHorizontal() ? e.horizontalClass : e.verticalClass); })); } })), i('init', (() => { !1 === n.params.pagination.enabled ? v() : (h(), f(), p()); })), i('activeIndexChange', (() => { void 0 === n.snapIndex && p(); })), i('snapIndexChange', (() => { p(); })), i('snapGridLengthChange', (() => { f(), p(); })), i('destroy', (() => { m(); })), i('enable disable', (() => { let e = n.pagination.el; e && (e = I(e)).forEach(((e) => e.classList[n.enabled ? 'remove' : 'add'](n.params.pagination.lockClass))); })), i('lock unlock', (() => { p(); })), i('click', ((e, t) => { const r = t.target; const i = I(n.pagination.el); if (n.params.pagination.el && n.params.pagination.hideOnClick && i && i.length > 0 && !r.classList.contains(n.params.pagination.bulletClass)) { if (n.navigation && (n.navigation.nextEl && r === n.navigation.nextEl || n.navigation.prevEl && r === n.navigation.prevEl)) return; const a = i[0].classList.contains(n.params.pagination.hiddenClass); o(!0 === a ? 'paginationShow' : 'paginationHide'), i.forEach(((e) => e.classList.toggle(n.params.pagination.hiddenClass))); } })); var v = function () { n.el.classList.add(n.params.pagination.paginationDisabledClass); let e = n.pagination.el; e && (e = I(e)).forEach(((e) => e.classList.add(n.params.pagination.paginationDisabledClass))), m(); }; Object.assign(n.pagination, {
            enable() { n.el.classList.remove(n.params.pagination.paginationDisabledClass); let e = n.pagination.el; e && (e = I(e)).forEach(((e) => e.classList.remove(n.params.pagination.paginationDisabledClass))), h(), f(), p(); }, disable: v, render: f, update: p, init: h, destroy: m,
          });
        }, function (e) {
          let t; let n; let r; let o; const a = e.swiper; const l = e.extendParams; const c = e.on; const u = e.emit; const d = i(); let p = !1; let f = null; let h = null; function g() { if (a.params.scrollbar.el && a.scrollbar.el) { const e = a.scrollbar; const t = a.rtlTranslate; const i = e.dragEl; const o = e.el; const s = a.params.scrollbar; const l = a.params.loop ? a.progressLoop : a.progress; let c = n; let u = (r - n) * l; t ? (u = -u) > 0 ? (c = n - u, u = 0) : -u + n > r && (c = r + u) : u < 0 ? (c = n + u, u = 0) : u + n > r && (c = r - u), a.isHorizontal() ? (i.style.transform = 'translate3d('.concat(u, 'px, 0, 0)'), i.style.width = ''.concat(c, 'px')) : (i.style.transform = 'translate3d(0px, '.concat(u, 'px, 0)'), i.style.height = ''.concat(c, 'px')), s.hide && (clearTimeout(f), o.style.opacity = 1, f = setTimeout((() => { o.style.opacity = 0, o.style.transitionDuration = '400ms'; }), 1e3)); } } function y() { if (a.params.scrollbar.el && a.scrollbar.el) { const e = a.scrollbar; const t = e.dragEl; const i = e.el; t.style.width = '', t.style.height = '', r = a.isHorizontal() ? i.offsetWidth : i.offsetHeight, o = a.size / (a.virtualSize + a.params.slidesOffsetBefore - (a.params.centeredSlides ? a.snapGrid[0] : 0)), n = a.params.scrollbar.dragSize === 'auto' ? r * o : parseInt(a.params.scrollbar.dragSize, 10), a.isHorizontal() ? t.style.width = ''.concat(n, 'px') : t.style.height = ''.concat(n, 'px'), i.style.display = o >= 1 ? 'none' : '', a.params.scrollbar.hide && (i.style.opacity = 0), a.params.watchOverflow && a.enabled && e.el.classList[a.isLocked ? 'add' : 'remove'](a.params.scrollbar.lockClass); } } function b(e) { return a.isHorizontal() ? e.clientX : e.clientY; } function w(e) { let i; const o = a.scrollbar; const s = a.rtlTranslate; const l = o.el; i = (b(e) - L(l)[a.isHorizontal() ? 'left' : 'top'] - (t !== null ? t : n / 2)) / (r - n), i = Math.max(Math.min(i, 1), 0), s && (i = 1 - i); const c = a.minTranslate() + (a.maxTranslate() - a.minTranslate()) * i; a.updateProgress(c), a.setTranslate(c), a.updateActiveIndex(), a.updateSlidesClasses(); } function S(e) { const n = a.params.scrollbar; const r = a.scrollbar; const i = a.wrapperEl; const o = r.el; const s = r.dragEl; p = !0, t = e.target === s ? b(e) - e.target.getBoundingClientRect()[a.isHorizontal() ? 'left' : 'top'] : null, e.preventDefault(), e.stopPropagation(), i.style.transitionDuration = '100ms', s.style.transitionDuration = '100ms', w(e), clearTimeout(h), o.style.transitionDuration = '0ms', n.hide && (o.style.opacity = 1), a.params.cssMode && (a.wrapperEl.style['scroll-snap-type'] = 'none'), u('scrollbarDragStart', e); } function x(e) { const t = a.scrollbar; const n = a.wrapperEl; const r = t.el; const i = t.dragEl; p && (e.preventDefault && e.cancelable ? e.preventDefault() : e.returnValue = !1, w(e), n.style.transitionDuration = '0ms', r.style.transitionDuration = '0ms', i.style.transitionDuration = '0ms', u('scrollbarDragMove', e)); } function E(e) { const t = a.params.scrollbar; const n = a.scrollbar; const r = a.wrapperEl; const i = n.el; p && (p = !1, a.params.cssMode && (a.wrapperEl.style['scroll-snap-type'] = '', r.style.transitionDuration = ''), t.hide && (clearTimeout(h), h = v((() => { i.style.opacity = 0, i.style.transitionDuration = '400ms'; }), 1e3)), u('scrollbarDragEnd', e), t.snapOnRelease && a.slideToClosest()); } function T(e) { const t = a.scrollbar; const n = a.params; const r = t.el; if (r) { const i = r; const o = !!n.passiveListeners && { passive: !1, capture: !1 }; const s = !!n.passiveListeners && { passive: !0, capture: !1 }; if (i) { const l = e === 'on' ? 'addEventListener' : 'removeEventListener'; i[l]('pointerdown', S, o), d[l]('pointermove', x, o), d[l]('pointerup', E, s); } } } function _() { let e; const t = a.scrollbar; const n = a.el; a.params.scrollbar = de(a, a.originalParams.scrollbar, a.params.scrollbar, { el: 'swiper-scrollbar' }); const r = a.params.scrollbar; if (r.el) { let i; let o; if (typeof r.el === 'string' && a.isElement && (i = a.el.querySelector(r.el)), i || typeof r.el !== 'string')i || (i = r.el); else if (!(i = d.querySelectorAll(r.el)).length) return; a.params.uniqueNavElements && typeof r.el === 'string' && i.length > 1 && n.querySelectorAll(r.el).length === 1 && (i = n.querySelector(r.el)), i.length > 0 && (i = i[0]), i.classList.add(a.isHorizontal() ? r.horizontalClass : r.verticalClass), i && ((o = i.querySelector(pe(a.params.scrollbar.dragClass))) || (o = C('div', a.params.scrollbar.dragClass), i.append(o))), Object.assign(t, { el: i, dragEl: o }), r.draggable && a.params.scrollbar.el && a.scrollbar.el && T('on'), i && (e = i.classList)[a.enabled ? 'remove' : 'add'].apply(e, s(m(a.params.scrollbar.lockClass))); } } function k() { let e; const t = a.params.scrollbar; const n = a.scrollbar.el; n && (e = n.classList).remove.apply(e, s(m(a.isHorizontal() ? t.horizontalClass : t.verticalClass))), a.params.scrollbar.el && a.scrollbar.el && T('off'); }l({
            scrollbar: {
              el: null, dragSize: 'auto', hide: !1, draggable: !1, snapOnRelease: !0, lockClass: 'swiper-scrollbar-lock', dragClass: 'swiper-scrollbar-drag', scrollbarDisabledClass: 'swiper-scrollbar-disabled', horizontalClass: 'swiper-scrollbar-horizontal', verticalClass: 'swiper-scrollbar-vertical',
            },
          }), a.scrollbar = { el: null, dragEl: null }, c('changeDirection', (() => { if (a.scrollbar && a.scrollbar.el) { const e = a.params.scrollbar; let t = a.scrollbar.el; (t = I(t)).forEach(((t) => { t.classList.remove(e.horizontalClass, e.verticalClass), t.classList.add(a.isHorizontal() ? e.horizontalClass : e.verticalClass); })); } })), c('init', (() => { !1 === a.params.scrollbar.enabled ? M() : (_(), y(), g()); })), c('update resize observerUpdate lock unlock changeDirection', (() => { y(); })), c('setTranslate', (() => { g(); })), c('setTransition', ((e, t) => { !(function (e) { a.params.scrollbar.el && a.scrollbar.el && (a.scrollbar.dragEl.style.transitionDuration = ''.concat(e, 'ms')); }(t)); })), c('enable disable', (() => { let e; const t = a.scrollbar.el; t && (e = t.classList)[a.enabled ? 'remove' : 'add'].apply(e, s(m(a.params.scrollbar.lockClass))); })), c('destroy', (() => { k(); })); var M = function () { let e; let t; (e = a.el.classList).add.apply(e, s(m(a.params.scrollbar.scrollbarDisabledClass))), a.scrollbar.el && (t = a.scrollbar.el.classList).add.apply(t, s(m(a.params.scrollbar.scrollbarDisabledClass))), k(); }; Object.assign(a.scrollbar, {
            enable() { let e; let t; (e = a.el.classList).remove.apply(e, s(m(a.params.scrollbar.scrollbarDisabledClass))), a.scrollbar.el && (t = a.scrollbar.el.classList).remove.apply(t, s(m(a.params.scrollbar.scrollbarDisabledClass))), _(), y(), g(); }, disable: M, updateSize: y, setTranslate: g, init: _, destroy: k,
          });
        }, function (e) { const t = e.swiper; const n = e.extendParams; const r = e.on; n({ parallax: { enabled: !1 } }); const i = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]'; const o = function (e, n) { const r = t.rtl ? -1 : 1; const i = e.getAttribute('data-swiper-parallax') || "0"; let o = e.getAttribute('data-swiper-parallax-x'); let a = e.getAttribute('data-swiper-parallax-y'); const s = e.getAttribute('data-swiper-parallax-scale'); const l = e.getAttribute('data-swiper-parallax-opacity'); const c = e.getAttribute('data-swiper-parallax-rotate'); if (o || a ? (o = o || '0', a = a || '0') : t.isHorizontal() ? (o = i, a = '0') : (a = i, o = '0'), o = o.indexOf('%') >= 0 ? `${parseInt(o, 10) * n * r }%` : `${o * n * r }px`, a = a.indexOf('%') >= 0 ? `${parseInt(a, 10) * n }%` : `${a * n }px`, l != null) { const u = l - (l - 1) * (1 - Math.abs(n)); e.style.opacity = u; } let d = 'translate3d('.concat(o, ', ').concat(a, ', 0px)'); s != null && (d += ' scale('.concat(s - (s - 1) * (1 - Math.abs(n)), ')')), c && c != null && (d += ' rotate('.concat(c * n * -1, 'deg)')), e.style.transform = d; }; const a = function () { const e = t.el; const n = t.slides; const r = t.progress; const a = t.snapGrid; const l = (t.isElement, T(e, i)); t.isElement && l.push.apply(l, s(T(t.hostEl, i))), l.forEach(((e) => { o(e, r); })), n.forEach(((e, n) => { let s = e.progress; t.params.slidesPerGroup > 1 && t.params.slidesPerView !== 'auto' && (s += Math.ceil(n / 2) - r * (a.length - 1)), s = Math.min(Math.max(s, -1), 1), e.querySelectorAll(''.concat(i, ', [data-swiper-parallax-rotate]')).forEach(((e) => { o(e, s); })); })); }; r('beforeInit', (() => { t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0); })), r('init', (() => { t.params.parallax.enabled && a(); })), r('setTranslate', (() => { t.params.parallax.enabled && a(); })), r('setTransition', ((e, n) => { t.params.parallax.enabled && (function (e) { void 0 === e && (e = t.params.speed); const n = t.el; const r = t.hostEl; const o = s(n.querySelectorAll(i)); t.isElement && o.push.apply(o, s(r.querySelectorAll(i))), o.forEach(((t) => { let n = parseInt(t.getAttribute('data-swiper-parallax-duration'), 10) || e; e === 0 && (n = 0), t.style.transitionDuration = ''.concat(n, 'ms'); })); }(n)); })); }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; const i = e.emit; const o = h(); n({
            zoom: {
              enabled: !1, limitToOriginalSize: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: 'swiper-zoom-container', zoomedSlideClass: 'swiper-slide-zoomed',
            },
          }), t.zoom = { enabled: !1 }; let l; let c; let u; let d = 1; let p = !1; const f = []; const m = {
            originX: 0, originY: 0, slideEl: void 0, slideWidth: void 0, slideHeight: void 0, imageEl: void 0, imageWrapEl: void 0, maxRatio: 3, 
}; const v = {
            isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {}, 
}; const g = {
            x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0, 
}; let b = 1; function w() { if (f.length < 2) return 1; const e = f[0].pageX; const t = f[0].pageY; const n = f[1].pageX; const r = f[1].pageY; return Math.sqrt((n - e) ** 2 + (r - t) ** 2); } function S() { const e = t.params.zoom; const n = m.imageWrapEl.getAttribute('data-swiper-zoom') || e.maxRatio; if (e.limitToOriginalSize && m.imageEl && m.imageEl.naturalWidth) { const r = m.imageEl.naturalWidth / m.imageEl.offsetWidth; return Math.min(r, n); } return n; } function x(e) { const n = t.isElement ? 'swiper-slide' : '.'.concat(t.params.slideClass); return !!e.target.matches(n) || t.slides.filter(((t) => t.contains(e.target))).length > 0; } function E(e) { if (e.pointerType === 'mouse' && f.splice(0, f.length), x(e)) { const n = t.params.zoom; if (l = !1, c = !1, f.push(e), !(f.length < 2)) { if (l = !0, m.scaleStart = w(), !m.slideEl) { m.slideEl = e.target.closest('.'.concat(t.params.slideClass, ', swiper-slide')), m.slideEl || (m.slideEl = t.slides[t.activeIndex]); let r = m.slideEl.querySelector('.'.concat(n.containerClass)); if (r && (r = r.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0]), m.imageEl = r, m.imageWrapEl = r ? A(m.imageEl, '.'.concat(n.containerClass))[0] : void 0, !m.imageWrapEl) return void (m.imageEl = void 0); m.maxRatio = S(); } if (m.imageEl) { const i = (function () { if (f.length < 2) return { x: null, y: null }; const e = m.imageEl.getBoundingClientRect(); return [(f[0].pageX + (f[1].pageX - f[0].pageX) / 2 - e.x - o.scrollX) / d, (f[0].pageY + (f[1].pageY - f[0].pageY) / 2 - e.y - o.scrollY) / d]; }()); const s = a(i, 2); const u = s[0]; const h = s[1]; m.originX = u, m.originY = h, m.imageEl.style.transitionDuration = '0ms'; }p = !0; } } } function _(e) { if (x(e)) { const n = t.params.zoom; const r = t.zoom; const i = f.findIndex(((t) => t.pointerId === e.pointerId)); i >= 0 && (f[i] = e), f.length < 2 || (c = !0, m.scaleMove = w(), m.imageEl && (r.scale = m.scaleMove / m.scaleStart * d, r.scale > m.maxRatio && (r.scale = m.maxRatio - 1 + (r.scale - m.maxRatio + 1) ** 0.5), r.scale < n.minRatio && (r.scale = n.minRatio + 1 - (n.minRatio - r.scale + 1) ** 0.5), m.imageEl.style.transform = 'translate3d(0,0,0) scale('.concat(r.scale, ')'))); } } function C(e) { if (x(e) && (e.pointerType !== 'mouse' || e.type !== 'pointerout')) { const n = t.params.zoom; const r = t.zoom; const i = f.findIndex(((t) => t.pointerId === e.pointerId)); i >= 0 && f.splice(i, 1), l && c && (l = !1, c = !1, m.imageEl && (r.scale = Math.max(Math.min(r.scale, m.maxRatio), n.minRatio), m.imageEl.style.transitionDuration = ''.concat(t.params.speed, 'ms'), m.imageEl.style.transform = 'translate3d(0,0,0) scale('.concat(r.scale, ')'), d = r.scale, p = !1, r.scale > 1 && m.slideEl ? m.slideEl.classList.add(''.concat(n.zoomedSlideClass)) : r.scale <= 1 && m.slideEl && m.slideEl.classList.remove(''.concat(n.zoomedSlideClass)), r.scale === 1 && (m.originX = 0, m.originY = 0, m.slideEl = void 0))); } } function k() { t.touchEventsData.preventTouchMoveFromPointerMove = !1; } function M(e) { if (x(e) && (function (e) { const n = '.'.concat(t.params.zoom.containerClass); return !!e.target.matches(n) || s(t.hostEl.querySelectorAll(n)).filter(((t) => t.contains(e.target))).length > 0; }(e))) { const n = t.zoom; if (m.imageEl && v.isTouched && m.slideEl) { v.isMoved || (v.width = m.imageEl.offsetWidth || m.imageEl.clientWidth, v.height = m.imageEl.offsetHeight || m.imageEl.clientHeight, v.startX = y(m.imageWrapEl, 'x') || 0, v.startY = y(m.imageWrapEl, 'y') || 0, m.slideWidth = m.slideEl.offsetWidth, m.slideHeight = m.slideEl.offsetHeight, m.imageWrapEl.style.transitionDuration = '0ms'); const r = v.width * n.scale; const i = v.height * n.scale; if (v.minX = Math.min(m.slideWidth / 2 - r / 2, 0), v.maxX = -v.minX, v.minY = Math.min(m.slideHeight / 2 - i / 2, 0), v.maxY = -v.minY, v.touchesCurrent.x = f.length > 0 ? f[0].pageX : e.pageX, v.touchesCurrent.y = f.length > 0 ? f[0].pageY : e.pageY, Math.max(Math.abs(v.touchesCurrent.x - v.touchesStart.x), Math.abs(v.touchesCurrent.y - v.touchesStart.y)) > 5 && (t.allowClick = !1), !v.isMoved && !p) { if (t.isHorizontal() && (Math.floor(v.minX) === Math.floor(v.startX) && v.touchesCurrent.x < v.touchesStart.x || Math.floor(v.maxX) === Math.floor(v.startX) && v.touchesCurrent.x > v.touchesStart.x)) return v.isTouched = !1, void k(); if (!t.isHorizontal() && (Math.floor(v.minY) === Math.floor(v.startY) && v.touchesCurrent.y < v.touchesStart.y || Math.floor(v.maxY) === Math.floor(v.startY) && v.touchesCurrent.y > v.touchesStart.y)) return v.isTouched = !1, void k(); }e.cancelable && e.preventDefault(), e.stopPropagation(), clearTimeout(u), t.touchEventsData.preventTouchMoveFromPointerMove = !0, u = setTimeout((() => { k(); })), v.isMoved = !0; const o = (n.scale - d) / (m.maxRatio - t.params.zoom.minRatio); const a = m.originX; const l = m.originY; v.currentX = v.touchesCurrent.x - v.touchesStart.x + v.startX + o * (v.width - 2 * a), v.currentY = v.touchesCurrent.y - v.touchesStart.y + v.startY + o * (v.height - 2 * l), v.currentX < v.minX && (v.currentX = v.minX + 1 - (v.minX - v.currentX + 1) ** 0.8), v.currentX > v.maxX && (v.currentX = v.maxX - 1 + (v.currentX - v.maxX + 1) ** 0.8), v.currentY < v.minY && (v.currentY = v.minY + 1 - (v.minY - v.currentY + 1) ** 0.8), v.currentY > v.maxY && (v.currentY = v.maxY - 1 + (v.currentY - v.maxY + 1) ** 0.8), g.prevPositionX || (g.prevPositionX = v.touchesCurrent.x), g.prevPositionY || (g.prevPositionY = v.touchesCurrent.y), g.prevTime || (g.prevTime = Date.now()), g.x = (v.touchesCurrent.x - g.prevPositionX) / (Date.now() - g.prevTime) / 2, g.y = (v.touchesCurrent.y - g.prevPositionY) / (Date.now() - g.prevTime) / 2, Math.abs(v.touchesCurrent.x - g.prevPositionX) < 2 && (g.x = 0), Math.abs(v.touchesCurrent.y - g.prevPositionY) < 2 && (g.y = 0), g.prevPositionX = v.touchesCurrent.x, g.prevPositionY = v.touchesCurrent.y, g.prevTime = Date.now(), m.imageWrapEl.style.transform = 'translate3d('.concat(v.currentX, 'px, ').concat(v.currentY, 'px,0)'); } } } function O() { const e = t.zoom; m.slideEl && t.activeIndex !== t.slides.indexOf(m.slideEl) && (m.imageEl && (m.imageEl.style.transform = 'translate3d(0,0,0) scale(1)'), m.imageWrapEl && (m.imageWrapEl.style.transform = 'translate3d(0,0,0)'), m.slideEl.classList.remove(''.concat(t.params.zoom.zoomedSlideClass)), e.scale = 1, d = 1, m.slideEl = void 0, m.imageEl = void 0, m.imageWrapEl = void 0, m.originX = 0, m.originY = 0); } function P(e) { const n = t.zoom; const r = t.params.zoom; if (!m.slideEl) { e && e.target && (m.slideEl = e.target.closest('.'.concat(t.params.slideClass, ', swiper-slide'))), m.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.slideEl = T(t.slidesEl, '.'.concat(t.params.slideActiveClass))[0] : m.slideEl = t.slides[t.activeIndex]); let i = m.slideEl.querySelector('.'.concat(r.containerClass)); i && (i = i.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0]), m.imageEl = i, m.imageWrapEl = i ? A(m.imageEl, '.'.concat(r.containerClass))[0] : void 0; } if (m.imageEl && m.imageWrapEl) { let a; let s; let l; let c; let u; let p; let f; let h; let g; let y; let b; let w; let x; let E; let _; let C; t.params.cssMode && (t.wrapperEl.style.overflow = 'hidden', t.wrapperEl.style.touchAction = 'none'), m.slideEl.classList.add(''.concat(r.zoomedSlideClass)), void 0 === v.touchesStart.x && e ? (a = e.pageX, s = e.pageY) : (a = v.touchesStart.x, s = v.touchesStart.y); const k = typeof e === 'number' ? e : null; d === 1 && k && (a = void 0, s = void 0, v.touchesStart.x = void 0, v.touchesStart.y = void 0); const M = S(); n.scale = k || M, d = k || M, !e || d === 1 && k ? (u = 0, p = 0) : (_ = m.slideEl.offsetWidth, C = m.slideEl.offsetHeight, l = L(m.slideEl).left + o.scrollX + _ / 2 - a, c = L(m.slideEl).top + o.scrollY + C / 2 - s, f = m.imageEl.offsetWidth || m.imageEl.clientWidth, h = m.imageEl.offsetHeight || m.imageEl.clientHeight, g = f * n.scale, y = h * n.scale, x = -(b = Math.min(_ / 2 - g / 2, 0)), E = -(w = Math.min(C / 2 - y / 2, 0)), (u = l * n.scale) < b && (u = b), u > x && (u = x), (p = c * n.scale) < w && (p = w), p > E && (p = E)), k && n.scale === 1 && (m.originX = 0, m.originY = 0), m.imageWrapEl.style.transitionDuration = '300ms', m.imageWrapEl.style.transform = 'translate3d('.concat(u, 'px, ').concat(p, 'px,0)'), m.imageEl.style.transitionDuration = '300ms', m.imageEl.style.transform = 'translate3d(0,0,0) scale('.concat(n.scale, ')'); } } function I() { const e = t.zoom; const n = t.params.zoom; if (!m.slideEl) { t.params.virtual && t.params.virtual.enabled && t.virtual ? m.slideEl = T(t.slidesEl, '.'.concat(t.params.slideActiveClass))[0] : m.slideEl = t.slides[t.activeIndex]; let r = m.slideEl.querySelector('.'.concat(n.containerClass)); r && (r = r.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0]), m.imageEl = r, m.imageWrapEl = r ? A(m.imageEl, '.'.concat(n.containerClass))[0] : void 0; }m.imageEl && m.imageWrapEl && (t.params.cssMode && (t.wrapperEl.style.overflow = '', t.wrapperEl.style.touchAction = ''), e.scale = 1, d = 1, v.touchesStart.x = void 0, v.touchesStart.y = void 0, m.imageWrapEl.style.transitionDuration = '300ms', m.imageWrapEl.style.transform = 'translate3d(0,0,0)', m.imageEl.style.transitionDuration = '300ms', m.imageEl.style.transform = 'translate3d(0,0,0) scale(1)', m.slideEl.classList.remove(''.concat(n.zoomedSlideClass)), m.slideEl = void 0, m.originX = 0, m.originY = 0); } function N(e) { const n = t.zoom; n.scale && n.scale !== 1 ? I() : P(e); } function D() { return { passiveListener: !!t.params.passiveListeners && { passive: !0, capture: !1 }, activeListenerWithCapture: !t.params.passiveListeners || { passive: !1, capture: !0 } }; } function R() { const e = t.zoom; if (!e.enabled) { e.enabled = !0; const n = D(); const r = n.passiveListener; const i = n.activeListenerWithCapture; t.wrapperEl.addEventListener('pointerdown', E, r), t.wrapperEl.addEventListener('pointermove', _, i), ['pointerup', 'pointercancel', 'pointerout'].forEach(((e) => { t.wrapperEl.addEventListener(e, C, r); })), t.wrapperEl.addEventListener('pointermove', M, i); } } function j() { const e = t.zoom; if (e.enabled) { e.enabled = !1; const n = D(); const r = n.passiveListener; const i = n.activeListenerWithCapture; t.wrapperEl.removeEventListener('pointerdown', E, r), t.wrapperEl.removeEventListener('pointermove', _, i), ['pointerup', 'pointercancel', 'pointerout'].forEach(((e) => { t.wrapperEl.removeEventListener(e, C, r); })), t.wrapperEl.removeEventListener('pointermove', M, i); } }Object.defineProperty(t.zoom, 'scale', { get() { return b; }, set(e) { if (b !== e) { const t = m.imageEl; const n = m.slideEl; i('zoomChange', e, t, n); }b = e; } }), r('init', (() => { t.params.zoom.enabled && R(); })), r('destroy', (() => { j(); })), r('touchStart', ((e, n) => { t.zoom.enabled && (function (e) { const n = t.device; if (m.imageEl && !v.isTouched) { n.android && e.cancelable && e.preventDefault(), v.isTouched = !0; const r = f.length > 0 ? f[0] : e; v.touchesStart.x = r.pageX, v.touchesStart.y = r.pageY; } }(n)); })), r('touchEnd', ((e, n) => { t.zoom.enabled && (function () { const e = t.zoom; if (m.imageEl) { if (!v.isTouched || !v.isMoved) return v.isTouched = !1, void (v.isMoved = !1); v.isTouched = !1, v.isMoved = !1; let n = 300; let r = 300; const i = g.x * n; const o = v.currentX + i; const a = g.y * r; const s = v.currentY + a; g.x !== 0 && (n = Math.abs((o - v.currentX) / g.x)), g.y !== 0 && (r = Math.abs((s - v.currentY) / g.y)); const l = Math.max(n, r); v.currentX = o, v.currentY = s; const c = v.width * e.scale; const u = v.height * e.scale; v.minX = Math.min(m.slideWidth / 2 - c / 2, 0), v.maxX = -v.minX, v.minY = Math.min(m.slideHeight / 2 - u / 2, 0), v.maxY = -v.minY, v.currentX = Math.max(Math.min(v.currentX, v.maxX), v.minX), v.currentY = Math.max(Math.min(v.currentY, v.maxY), v.minY), m.imageWrapEl.style.transitionDuration = ''.concat(l, 'ms'), m.imageWrapEl.style.transform = 'translate3d('.concat(v.currentX, 'px, ').concat(v.currentY, 'px,0)'); } }()); })), r('doubleTap', ((e, n) => { !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && N(n); })), r('transitionEnd', (() => { t.zoom.enabled && t.params.zoom.enabled && O(); })), r('slideChange', (() => { t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && O(); })), Object.assign(t.zoom, {
            enable: R, disable: j, in: P, out: I, toggle: N,
          });
        }, function (e) { const t = e.swiper; const n = e.extendParams; const r = e.on; function i(e, t) { let n; let r; const i = (function () { let e; let t; let n; return function (r, i) { for (t = -1, e = r.length; e - t > 1;)r[n = e + t >> 1] <= i ? t = n : e = n; return e; }; }()); return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (r = i(this.x, e), n = r - 1, (e - this.x[n]) * (this.y[r] - this.y[n]) / (this.x[r] - this.x[n]) + this.y[n]) : 0; }, this; } function o() { t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline); }n({ controller: { control: void 0, inverse: !1, by: 'slide' } }), t.controller = { control: void 0 }, r('beforeInit', (() => { typeof window !== 'undefined' && (typeof t.params.controller.control === 'string' || t.params.controller.control instanceof HTMLElement) ? (typeof t.params.controller.control === 'string' ? s(document.querySelectorAll(t.params.controller.control)) : [t.params.controller.control]).forEach(((e) => { if (t.controller.control || (t.controller.control = []), e && e.swiper)t.controller.control.push(e.swiper); else if (e) { const n = ''.concat(t.params.eventsPrefix, 'init'); const r = function (i) { t.controller.control.push(i.detail[0]), t.update(), e.removeEventListener(n, r); }; e.addEventListener(n, r); } })) : t.controller.control = t.params.controller.control; })), r('update', (() => { o(); })), r('resize', (() => { o(); })), r('observerUpdate', (() => { o(); })), r('setTranslate', ((e, n, r) => { t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(n, r); })), r('setTransition', ((e, n, r) => { t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(n, r); })), Object.assign(t.controller, { setTranslate(e, n) { let r; let o; const a = t.controller.control; const s = t.constructor; function l(e) { if (!e.destroyed) { const n = t.rtlTranslate ? -t.translate : t.translate; t.params.controller.by === 'slide' && ((function (e) { t.controller.spline = t.params.loop ? new i(t.slidesGrid, e.slidesGrid) : new i(t.snapGrid, e.snapGrid); }(e)), o = -t.controller.spline.interpolate(-n)), o && t.params.controller.by !== 'container' || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), !Number.isNaN(r) && Number.isFinite(r) || (r = 1), o = (n - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (o = e.maxTranslate() - o), e.updateProgress(o), e.setTranslate(o, t), e.updateActiveIndex(), e.updateSlidesClasses(); } } if (Array.isArray(a)) for (let c = 0; c < a.length; c += 1)a[c] !== n && a[c] instanceof s && l(a[c]); else a instanceof s && n !== a && l(a); }, setTransition(e, n) { let r; const i = t.constructor; const o = t.controller.control; function a(n) { n.destroyed || (n.setTransition(e, t), e !== 0 && (n.transitionStart(), n.params.autoHeight && v((() => { n.updateAutoHeight(); })), O(n.wrapperEl, (() => { o && n.transitionEnd(); })))); } if (Array.isArray(o)) for (r = 0; r < o.length; r += 1)o[r] !== n && o[r] instanceof i && a(o[r]); else o instanceof i && n !== o && a(o); } }); }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; n({
            a11y: {
              enabled: !0, notificationClass: 'swiper-notification', prevSlideMessage: 'Previous slide', nextSlideMessage: 'Next slide', firstSlideMessage: 'This is the first slide', lastSlideMessage: 'This is the last slide', paginationBulletMessage: 'Go to slide {{index}}', slideLabelMessage: '{{index}} / {{slidesLength}}', containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: 'group', id: null, scrollOnFocus: !0,
            },
          }), t.a11y = { clicked: !1 }; let o; let a; let s = null; let l = (new Date()).getTime(); function c(e) { const t = s; t.length !== 0 && (t.innerHTML = '', t.innerHTML = e); } function u(e) { (e = I(e)).forEach(((e) => { e.setAttribute('tabIndex', '0'); })); } function d(e) { (e = I(e)).forEach(((e) => { e.setAttribute('tabIndex', '-1'); })); } function p(e, t) { (e = I(e)).forEach(((e) => { e.setAttribute('role', t); })); } function f(e, t) { (e = I(e)).forEach(((e) => { e.setAttribute('aria-roledescription', t); })); } function h(e, t) { (e = I(e)).forEach(((e) => { e.setAttribute('aria-label', t); })); } function m(e) { (e = I(e)).forEach(((e) => { e.setAttribute('aria-disabled', !0); })); } function v(e) { (e = I(e)).forEach(((e) => { e.setAttribute('aria-disabled', !1); })); } function g(e) { if (e.keyCode === 13 || e.keyCode === 32) { const n = t.params.a11y; const r = e.target; if (!t.pagination || !t.pagination.el || r !== t.pagination.el && !t.pagination.el.contains(e.target) || e.target.matches(pe(t.params.pagination.bulletClass))) { if (t.navigation && t.navigation.prevEl && t.navigation.nextEl) { const i = I(t.navigation.prevEl); I(t.navigation.nextEl).includes(r) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? c(n.lastSlideMessage) : c(n.nextSlideMessage)), i.includes(r) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? c(n.firstSlideMessage) : c(n.prevSlideMessage)); }t.pagination && r.matches(pe(t.params.pagination.bulletClass)) && r.click(); } } } function y() { return t.pagination && t.pagination.bullets && t.pagination.bullets.length; } function b() { return y() && t.params.pagination.clickable; } const w = function (e, t, n) { u(e), e.tagName !== 'BUTTON' && (p(e, 'button'), e.addEventListener('keydown', g)), h(e, n), (function (e, t) { (e = I(e)).forEach(((e) => { e.setAttribute('aria-controls', t); })); }(e, t)); }; const S = function (e) { a && a !== e.target && !a.contains(e.target) && (o = !0), t.a11y.clicked = !0; }; const x = function () { o = !1, requestAnimationFrame((() => { requestAnimationFrame((() => { t.destroyed || (t.a11y.clicked = !1); })); })); }; const E = function (e) { l = (new Date()).getTime(); }; const T = function (e) { if (!t.a11y.clicked && t.params.a11y.scrollOnFocus && !((new Date()).getTime() - l < 100)) { const n = e.target.closest('.'.concat(t.params.slideClass, ', swiper-slide')); if (n && t.slides.includes(n)) { a = n; const r = t.slides.indexOf(n) === t.activeIndex; const i = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(n); r || i || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, requestAnimationFrame((() => { o || (t.params.loop ? t.slideToLoop(parseInt(n.getAttribute('data-swiper-slide-index')), 0) : t.slideTo(t.slides.indexOf(n), 0), o = !1); }))); } } }; const _ = function () { const e = t.params.a11y; e.itemRoleDescriptionMessage && f(t.slides, e.itemRoleDescriptionMessage), e.slideRole && p(t.slides, e.slideRole); const n = t.slides.length; e.slideLabelMessage && t.slides.forEach(((r, i) => { const o = t.params.loop ? parseInt(r.getAttribute('data-swiper-slide-index'), 10) : i; h(r, e.slideLabelMessage.replace(/\{\{index\}\}/, o + 1).replace(/\{\{slidesLength\}\}/, n)); })); }; r('beforeInit', (() => { (s = C('span', t.params.a11y.notificationClass)).setAttribute('aria-live', 'assertive'), s.setAttribute('aria-atomic', 'true'); })), r('afterInit', (() => { t.params.a11y.enabled && (function () { const e = t.params.a11y; t.el.append(s); const n = t.el; e.containerRoleDescriptionMessage && f(n, e.containerRoleDescriptionMessage), e.containerMessage && h(n, e.containerMessage); let r; let o; const a = t.wrapperEl; const l = e.id || a.getAttribute('id') || 'swiper-wrapper-'.concat((void 0 === (r = 16) && (r = 16), 'x'.repeat(r).replace(/x/g, (() => { return Math.round(16 * Math.random()).toString(16); })))); const c = t.params.autoplay && t.params.autoplay.enabled ? 'off' : 'polite'; o = l, I(a).forEach(((e) => { e.setAttribute('id', o); })), (function (e, t) { (e = I(e)).forEach(((e) => { e.setAttribute('aria-live', t); })); }(a, c)), _(); const u = t.navigation ? t.navigation : {}; let d = u.nextEl; let p = u.prevEl; d = I(d), p = I(p), d && d.forEach(((t) => w(t, l, e.nextSlideMessage))), p && p.forEach(((t) => w(t, l, e.prevSlideMessage))), b() && I(t.pagination.el).forEach(((e) => { e.addEventListener('keydown', g); })), i().addEventListener('visibilitychange', E), t.el.addEventListener('focus', T, !0), t.el.addEventListener('focus', T, !0), t.el.addEventListener('pointerdown', S, !0), t.el.addEventListener('pointerup', x, !0); }()); })), r('slidesLengthChange snapGridLengthChange slidesGridLengthChange', (() => { t.params.a11y.enabled && _(); })), r('fromEdge toEdge afterInit lock unlock', (() => { t.params.a11y.enabled && (function () { if (!t.params.loop && !t.params.rewind && t.navigation) { const e = t.navigation; const n = e.nextEl; const r = e.prevEl; r && (t.isBeginning ? (m(r), d(r)) : (v(r), u(r))), n && (t.isEnd ? (m(n), d(n)) : (v(n), u(n))); } }()); })), r('paginationUpdate', (() => { t.params.a11y.enabled && (function () { const e = t.params.a11y; y() && t.pagination.bullets.forEach(((n) => { t.params.pagination.clickable && (u(n), t.params.pagination.renderBullet || (p(n, 'button'), h(n, e.paginationBulletMessage.replace(/\{\{index\}\}/, M(n) + 1)))), n.matches(pe(t.params.pagination.bulletActiveClass)) ? n.setAttribute('aria-current', 'true') : n.removeAttribute('aria-current'); })); }()); })), r('destroy', (() => { t.params.a11y.enabled && (function () { s && s.remove(); const e = t.navigation ? t.navigation : {}; let n = e.nextEl; let r = e.prevEl; n = I(n), r = I(r), n && n.forEach(((e) => e.removeEventListener('keydown', g))), r && r.forEach(((e) => e.removeEventListener('keydown', g))), b() && I(t.pagination.el).forEach(((e) => { e.removeEventListener('keydown', g); })), i().removeEventListener('visibilitychange', E), t.el && typeof t.el !== 'string' && (t.el.removeEventListener('focus', T, !0), t.el.removeEventListener('pointerdown', S, !0), t.el.removeEventListener('pointerup', x, !0)); }()); }));
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; n({
            history: {
              enabled: !1, root: '', replaceState: !1, key: 'slides', keepQuery: !1,
            },
          }); let i = !1; let o = {}; const a = function (e) {
            return e.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-')
              .replace(/^-+/, '')
              .replace(/-+$/, '');
          }; const s = function (e) { const t = h(); const n = (e ? new URL(e) : t.location).pathname.slice(1).split('/').filter(((e) =>{ return "" !== e })); const r = n.length; return { key: n[r - 2], value: n[r - 1] }; }; const l = function (e, n) { const r = h(); if (i && t.params.history.enabled) { let o; o = t.params.url ? new URL(t.params.url) : r.location; const s = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector('[data-swiper-slide-index="'.concat(n, '"]')) : t.slides[n]; let l = a(s.getAttribute('data-history')); if (t.params.history.root.length > 0) { let c = t.params.history.root; c[c.length - 1] === '/' && (c = c.slice(0, c.length - 1)), l = ''.concat(c, '/').concat(e ? ''.concat(e, '/') : '').concat(l); } else o.pathname.includes(e) || (l = ''.concat(e ? ''.concat(e, '/') : '').concat(l)); t.params.history.keepQuery && (l += o.search); const u = r.history.state; u && u.value === l || (t.params.history.replaceState ? r.history.replaceState({ value: l }, null, l) : r.history.pushState({ value: l }, null, l)); } }; const c = function (e, n, r) { if (n) for (let i = 0, o = t.slides.length; i < o; i += 1) { const s = t.slides[i]; if (a(s.getAttribute('data-history')) === n) { const l = t.getSlideIndex(s); t.slideTo(l, e, r); } } else t.slideTo(0, e, r); }; const u = function () { o = s(t.params.url), c(t.params.speed, o.value, !1); }; r('init', (() => { t.params.history.enabled && (function () { const e = h(); if (t.params.history) { if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0); i = !0, (o = s(t.params.url)).key || o.value ? (c(0, o.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener('popstate', u)) : t.params.history.replaceState || e.addEventListener('popstate', u); } }()); })), r('destroy', (() => { t.params.history.enabled && (function () { const e = h(); t.params.history.replaceState || e.removeEventListener('popstate', u); }()); })), r('transitionEnd _freeModeNoMomentumRelease', (() => { i && l(t.params.history.key, t.activeIndex); })), r('slideChange', (() => { i && t.params.cssMode && l(t.params.history.key, t.activeIndex); }));
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.emit; const o = e.on; let a = !1; const s = i(); const l = h(); n({
            hashNavigation: {
              enabled: !1, replaceState: !1, watchState: !1, getSlideIndex(e, n) { if (t.virtual && t.params.virtual.enabled) { const r = t.slides.filter(((e) => e.getAttribute('data-hash') === n))[0]; return r ? parseInt(r.getAttribute('data-swiper-slide-index'), 10) : 0; } return t.getSlideIndex(T(t.slidesEl, '.'.concat(t.params.slideClass, '[data-hash="').concat(n, '"], swiper-slide[data-hash="').concat(n, '"]'))[0]); },
            },
          }); const c = function () { r('hashChange'); const e = s.location.hash.replace('#', ''); const n = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector('[data-swiper-slide-index="'.concat(t.activeIndex, '"]')) : t.slides[t.activeIndex]; if (e !== (n ? n.getAttribute('data-hash') : '')) { const i = t.params.hashNavigation.getSlideIndex(t, e); if (void 0 === i || Number.isNaN(i)) return; t.slideTo(i); } }; const u = function () { if (a && t.params.hashNavigation.enabled) { const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector('[data-swiper-slide-index="'.concat(t.activeIndex, '"]')) : t.slides[t.activeIndex]; const n = e ? e.getAttribute('data-hash') || e.getAttribute('data-history') : ''; t.params.hashNavigation.replaceState && l.history && l.history.replaceState ? (l.history.replaceState(null, null, '#'.concat(n) || 0), r('hashSet')) : (s.location.hash = n || '', r('hashSet')); } }; o('init', (() => { t.params.hashNavigation.enabled && (function () { if (!(!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled)) { a = !0; const e = s.location.hash.replace('#', ''); if (e) { const n = t.params.hashNavigation.getSlideIndex(t, e); t.slideTo(n || 0, 0, t.params.runCallbacksOnInit, !0); }t.params.hashNavigation.watchState && l.addEventListener('hashchange', c); } }()); })), o('destroy', (() => { t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && l.removeEventListener('hashchange', c); })), o('transitionEnd _freeModeNoMomentumRelease', (() => { a && u(); })), o('slideChange', (() => { a && t.params.cssMode && u(); }));
        }, function (e) {
          let t; let n; const r = e.swiper; const o = e.extendParams; const a = e.on; const s = e.emit; const l = e.params; r.autoplay = { running: !1, paused: !1, timeLeft: 0 }, o({
            autoplay: {
              enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !1, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1,
            },
          }); let c; let u; let d; let p; let f; let h; let m; let v; let g = l && l.autoplay ? l.autoplay.delay : 3e3; let y = l && l.autoplay ? l.autoplay.delay : 3e3; let b = (new Date()).getTime(); function w(e) { r && !r.destroyed && r.wrapperEl && e.target === r.wrapperEl && (r.wrapperEl.removeEventListener('transitionend', w), v || e.detail && e.detail.bySwiperTouchMove || C()); } const S = function () { if (!r.destroyed && r.autoplay.running) { r.autoplay.paused ? u = !0 : u && (y = c, u = !1); const e = r.autoplay.paused ? c : b + y - (new Date()).getTime(); r.autoplay.timeLeft = e, s('autoplayTimeLeft', e, e / g), n = requestAnimationFrame((() => { S(); })); } }; const x = function (e) { if (!r.destroyed && r.autoplay.running) { cancelAnimationFrame(n), S(); let i = void 0 === e ? r.params.autoplay.delay : e; g = r.params.autoplay.delay, y = r.params.autoplay.delay; const o = (function () { var e; if (e = r.virtual && r.params.virtual.enabled ? r.slides.filter(((e) =>{ return e.classList.contains('swiper-slide-active') }))[0] : r.slides[r.activeIndex]) return parseInt(e.getAttribute('data-swiper-autoplay'), 10) }()); !Number.isNaN(o) && o > 0 && void 0 === e && (i = o, g = o, y = o), c = i; const a = r.params.speed; const l = function () { r && !r.destroyed && (r.params.autoplay.reverseDirection ? !r.isBeginning || r.params.loop || r.params.rewind ? (r.slidePrev(a, !0, !0), s('autoplay')) : r.params.autoplay.stopOnLastSlide || (r.slideTo(r.slides.length - 1, a, !0, !0), s('autoplay')) : !r.isEnd || r.params.loop || r.params.rewind ? (r.slideNext(a, !0, !0), s('autoplay')) : r.params.autoplay.stopOnLastSlide || (r.slideTo(0, a, !0, !0), s('autoplay')), r.params.cssMode && (b = (new Date()).getTime(), requestAnimationFrame((() => { x(); })))); }; return i > 0 ? (clearTimeout(t), t = setTimeout((() => { l(); }), i)) : requestAnimationFrame((() => { l(); })), i; } }; const E = function () { b = (new Date()).getTime(), r.autoplay.running = !0, x(), s('autoplayStart'); }; const T = function () { r.autoplay.running = !1, clearTimeout(t), cancelAnimationFrame(n), s('autoplayStop'); }; const _ = function (e, n) { if (!r.destroyed && r.autoplay.running) { clearTimeout(t), e || (m = !0); const i = function () { s('autoplayPause'), r.params.autoplay.waitForTransition ? r.wrapperEl.addEventListener('transitionend', w) : C(); }; if (r.autoplay.paused = !0, n) return h && (c = r.params.autoplay.delay), h = !1, void i(); const o = c || r.params.autoplay.delay; c = o - ((new Date()).getTime() - b), r.isEnd && c < 0 && !r.params.loop || (c < 0 && (c = 0), i()); } }; var C = function () { r.isEnd && c < 0 && !r.params.loop || r.destroyed || !r.autoplay.running || (b = (new Date()).getTime(), m ? (m = !1, x(c)) : x(), r.autoplay.paused = !1, s('autoplayResume')); }; const L = function () { if (!r.destroyed && r.autoplay.running) { const e = i(); e.visibilityState === 'hidden' && (m = !0, _(!0)), e.visibilityState === 'visible' && C(); } }; const k = function (e) { e.pointerType === 'mouse' && (m = !0, v = !0, r.animating || r.autoplay.paused || _(!0)); }; const M = function (e) { e.pointerType === 'mouse' && (v = !1, r.autoplay.paused && C()); }; a('init', (() => { r.params.autoplay.enabled && (r.params.autoplay.pauseOnMouseEnter && (r.el.addEventListener('pointerenter', k), r.el.addEventListener('pointerleave', M)), i().addEventListener('visibilitychange', L), E()); })), a('destroy', (() => { r.el && typeof r.el !== 'string' && (r.el.removeEventListener('pointerenter', k), r.el.removeEventListener('pointerleave', M)), i().removeEventListener('visibilitychange', L), r.autoplay.running && T(); })), a('_freeModeStaticRelease', (() => { (p || m) && C(); })), a('_freeModeNoMomentumRelease', (() => { r.params.autoplay.disableOnInteraction ? T() : _(!0, !0); })), a('beforeTransitionStart', ((e, t, n) => { !r.destroyed && r.autoplay.running && (n || !r.params.autoplay.disableOnInteraction ? _(!0, !0) : T()); })), a('sliderFirstMove', (() => { !r.destroyed && r.autoplay.running && (r.params.autoplay.disableOnInteraction ? T() : (d = !0, p = !1, m = !1, f = setTimeout((() => { m = !0, p = !0, _(!0); }), 200))); })), a('touchEnd', (() => { if (!r.destroyed && r.autoplay.running && d) { if (clearTimeout(f), clearTimeout(t), r.params.autoplay.disableOnInteraction) return p = !1, void (d = !1); p && r.params.cssMode && C(), p = !1, d = !1; } })), a('slideChange', (() => { !r.destroyed && r.autoplay.running && (h = !0); })), Object.assign(r.autoplay, {
            start: E, stop: T, pause: _, resume: C,
          });
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; n({
            thumbs: {
              swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: 'swiper-slide-thumb-active', thumbsContainerClass: 'swiper-thumbs',
            },
          }); let o = !1; let a = !1; function s() { const e = t.thumbs.swiper; if (e && !e.destroyed) { let n; const r = e.clickedIndex; const i = e.clickedSlide; i && i.classList.contains(t.params.thumbs.slideThumbActiveClass) || r != null && (n = e.params.loop ? parseInt(e.clickedSlide.getAttribute('data-swiper-slide-index'), 10) : r, t.params.loop ? t.slideToLoop(n) : t.slideTo(n)); } } function l() { const e = t.params.thumbs; if (o) return !1; o = !0; const n = t.constructor; if (e.swiper instanceof n)t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(t.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper.update(); else if (b(e.swiper)) { const r = { ...e.swiper }; Object.assign(r, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper = new n(r), a = !0; } return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on('tap', s), !0; } function c(e) { const n = t.thumbs.swiper; if (n && !n.destroyed) { const r = n.params.slidesPerView === 'auto' ? n.slidesPerViewDynamic() : n.params.slidesPerView; let i = 1; const o = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (i = 1), i = Math.floor(i), n.slides.forEach(((e) => e.classList.remove(o))), n.params.loop || n.params.virtual && n.params.virtual.enabled) for (let a = 0; a < i; a += 1)T(n.slidesEl, '[data-swiper-slide-index="'.concat(t.realIndex + a, '"]')).forEach(((e) => { e.classList.add(o); })); else for (let s = 0; s < i; s += 1)n.slides[t.realIndex + s] && n.slides[t.realIndex + s].classList.add(o); const l = t.params.thumbs.autoScrollOffset; const c = l && !n.params.loop; if (t.realIndex !== n.realIndex || c) { let u; let d; const p = n.activeIndex; if (n.params.loop) { const f = n.slides.filter(((e) => e.getAttribute('data-swiper-slide-index') === ''.concat(t.realIndex)))[0]; u = n.slides.indexOf(f), d = t.activeIndex > t.previousIndex ? 'next' : 'prev'; } else d = (u = t.realIndex) > t.previousIndex ? 'next' : 'prev'; c && (u += d === 'next' ? l : -1 * l), n.visibleSlidesIndexes && n.visibleSlidesIndexes.indexOf(u) < 0 && (n.params.centeredSlides ? u = u > p ? u - Math.floor(r / 2) + 1 : u + Math.floor(r / 2) - 1 : u > p && n.params.slidesPerGroup, n.slideTo(u, e ? 0 : void 0)); } } }t.thumbs = { swiper: null }, r('beforeInit', (() => { const e = t.params.thumbs; if (e && e.swiper) if (typeof e.swiper === 'string' || e.swiper instanceof HTMLElement) { const n = i(); const r = function () { t.destroyed || (function () { const r = 'string' === typeof e.swiper ? n.querySelector(e.swiper) : e.swiper; if (r && r.swiper)e.swiper = r.swiper, l(), c(!0); else if (r) { const i = ''.concat(t.params.eventsPrefix, 'init'); const o = function (n) { e.swiper = n.detail[0], r.removeEventListener(i, o), l(), c(!0), e.swiper.update(), t.update(); }; r.addEventListener(i, o); } return r; }()) || requestAnimationFrame(r); }; requestAnimationFrame(r); } else l(), c(!0); })), r('slideChange update resize observerUpdate', (() => { c(); })), r('setTransition', ((e, n) => { const r = t.thumbs.swiper; r && !r.destroyed && r.setTransition(n); })), r('beforeDestroy', (() => { const e = t.thumbs.swiper; e && !e.destroyed && a && e.destroy(); })), Object.assign(t.thumbs, { init: l, update: c });
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.emit; const i = e.once; n({
            freeMode: {
              enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: 0.02,
            },
          }), Object.assign(t, { freeMode: { onTouchStart() { if (!t.params.cssMode) { const e = t.getTranslate(); t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({ currentPos: t.rtl ? t.translate : -t.translate }); } }, onTouchMove() { if (!t.params.cssMode) { const e = t.touchEventsData; const n = t.touches; e.velocities.length === 0 && e.velocities.push({ position: n[t.isHorizontal() ? 'startX' : 'startY'], time: e.touchStartTime }), e.velocities.push({ position: n[t.isHorizontal() ? 'currentX' : 'currentY'], time: g() }); } }, onTouchEnd(e) { const n = e.currentPos; if (!t.params.cssMode) { const o = t.params; const a = t.wrapperEl; const s = t.rtlTranslate; const l = t.snapGrid; const c = t.touchEventsData; const u = g() - c.touchStartTime; if (n < -t.minTranslate())t.slideTo(t.activeIndex); else if (n > -t.maxTranslate())t.slides.length < l.length ? t.slideTo(l.length - 1) : t.slideTo(t.slides.length - 1); else { if (o.freeMode.momentum) { if (c.velocities.length > 1) { const d = c.velocities.pop(); const p = c.velocities.pop(); const f = d.position - p.position; const h = d.time - p.time; t.velocity = f / h, t.velocity /= 2, Math.abs(t.velocity) < o.freeMode.minimumVelocity && (t.velocity = 0), (h > 150 || g() - d.time > 300) && (t.velocity = 0); } else t.velocity = 0; t.velocity *= o.freeMode.momentumVelocityRatio, c.velocities.length = 0; let m = 1e3 * o.freeMode.momentumRatio; const v = t.velocity * m; let y = t.translate + v; s && (y = -y); let b; let w; let S = !1; const x = 20 * Math.abs(t.velocity) * o.freeMode.momentumBounceRatio; if (y < t.maxTranslate())o.freeMode.momentumBounce ? (y + t.maxTranslate() < -x && (y = t.maxTranslate() - x), b = t.maxTranslate(), S = !0, c.allowMomentumBounce = !0) : y = t.maxTranslate(), o.loop && o.centeredSlides && (w = !0); else if (y > t.minTranslate())o.freeMode.momentumBounce ? (y - t.minTranslate() > x && (y = t.minTranslate() + x), b = t.minTranslate(), S = !0, c.allowMomentumBounce = !0) : y = t.minTranslate(), o.loop && o.centeredSlides && (w = !0); else if (o.freeMode.sticky) { for (var E, T = 0; T < l.length; T += 1) if (l[T] > -y) { E = T; break; }y = -(y = Math.abs(l[E] - y) < Math.abs(l[E - 1] - y) || t.swipeDirection === 'next' ? l[E] : l[E - 1]); } if (w && i('transitionEnd', (() => { t.loopFix(); })), t.velocity !== 0) { if (m = s ? Math.abs((-y - t.translate) / t.velocity) : Math.abs((y - t.translate) / t.velocity), o.freeMode.sticky) { const _ = Math.abs((s ? -y : y) - t.translate); const C = t.slidesSizesGrid[t.activeIndex]; m = _ < C ? o.speed : _ < 2 * C ? 1.5 * o.speed : 2.5 * o.speed; } } else if (o.freeMode.sticky) return void t.slideToClosest(); o.freeMode.momentumBounce && S ? (t.updateProgress(b), t.setTransition(m), t.setTranslate(y), t.transitionStart(!0, t.swipeDirection), t.animating = !0, O(a, (() => { t && !t.destroyed && c.allowMomentumBounce && (r('momentumBounce'), t.setTransition(o.speed), setTimeout((() => { t.setTranslate(b), O(a, (() => { t && !t.destroyed && t.transitionEnd(); })); }), 0)); }))) : t.velocity ? (r('_freeModeNoMomentumRelease'), t.updateProgress(y), t.setTransition(m), t.setTranslate(y), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, O(a, (() => { t && !t.destroyed && t.transitionEnd(); })))) : t.updateProgress(y), t.updateActiveIndex(), t.updateSlidesClasses(); } else { if (o.freeMode.sticky) return void t.slideToClosest(); o.freeMode && r('_freeModeNoMomentumRelease'); }(!o.freeMode.momentum || u >= o.longSwipesMs) && (r('_freeModeStaticRelease'), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()); } } } } });
        }, function (e) {
          let t; let n; let r; let i; const o = e.swiper; const a = e.extendParams; const s = e.on; a({ grid: { rows: 1, fill: 'column' } }); const l = function () { let e = o.params.spaceBetween; return typeof e === 'string' && e.indexOf('%') >= 0 ? e = parseFloat(e.replace('%', '')) / 100 * o.size : typeof e === 'string' && (e = parseFloat(e)), e; }; s('init', (() => { i = o.params.grid && o.params.grid.rows > 1; })), s('update', (() => { const e = o.params; const t = o.el; const n = e.grid && e.grid.rows > 1; i && !n ? (t.classList.remove(''.concat(e.containerModifierClass, 'grid'), ''.concat(e.containerModifierClass, 'grid-column')), r = 1, o.emitContainerClasses()) : !i && n && (t.classList.add(''.concat(e.containerModifierClass, 'grid')), e.grid.fill === 'column' && t.classList.add(''.concat(e.containerModifierClass, 'grid-column')), o.emitContainerClasses()), i = n; })), o.grid = {
            initSlides(e) { const i = o.params.slidesPerView; const a = o.params.grid; const s = a.rows; const l = a.fill; const c = o.virtual && o.params.virtual.enabled ? o.virtual.slides.length : e.length; r = Math.floor(c / s), t = Math.floor(c / s) === c / s ? c : Math.ceil(c / s) * s, i !== 'auto' && l === 'row' && (t = Math.max(t, i * s)), n = t / s; }, unsetSlides() { o.slides && o.slides.forEach(((e) => { e.swiperSlideGridSet && (e.style.height = '', e.style[o.getDirectionLabel('margin-top')] = ''); })); }, updateSlide(e, i, a) { let s; let c; let u; const d = o.params.slidesPerGroup; const p = l(); const f = o.params.grid; const h = f.rows; const m = f.fill; const v = o.virtual && o.params.virtual.enabled ? o.virtual.slides.length : a.length; if (m === 'row' && d > 1) { const g = Math.floor(e / (d * h)); const y = e - h * d * g; const b = g === 0 ? d : Math.min(Math.ceil((v - g * h * d) / h), d); s = (c = y - (u = Math.floor(y / b)) * b + g * d) + u * t / h, i.style.order = s; } else m === 'column' ? (u = e - (c = Math.floor(e / h)) * h, (c > r || c === r && u === h - 1) && (u += 1) >= h && (u = 0, c += 1)) : c = e - (u = Math.floor(e / n)) * n; i.row = u, i.column = c, i.style.height = 'calc((100% - '.concat((h - 1) * p, 'px) / ').concat(h, ')'), i.style[o.getDirectionLabel('margin-top')] = u !== 0 ? p && ''.concat(p, 'px') : '', i.swiperSlideGridSet = !0; }, updateWrapperSize(e, n) { const r = o.params; const i = r.centeredSlides; const a = r.roundLengths; const s = l(); const c = o.params.grid.rows; if (o.virtualSize = (e + s) * t, o.virtualSize = Math.ceil(o.virtualSize / c) - s, o.params.cssMode || (o.wrapperEl.style[o.getDirectionLabel('width')] = ''.concat(o.virtualSize + s, 'px')), i) { for (var u = [], d = 0; d < n.length; d += 1) { let p = n[d]; a && (p = Math.floor(p)), n[d] < o.virtualSize + n[0] && u.push(p); }n.splice(0, n.length), n.push.apply(n, u); } },
          };
        }, function (e) {
          const t = e.swiper; Object.assign(t, {
            appendSlide: fe.bind(t), prependSlide: he.bind(t), addSlide: me.bind(t), removeSlide: ve.bind(t), removeAllSlides: ge.bind(t),
          });
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; n({ fadeEffect: { crossFade: !1 } }), ye({
            effect: 'fade',
            swiper: t,
            on: r,
            setTranslate() { const e = t.slides; t.params.fadeEffect; for (let n = 0; n < e.length; n += 1) { const r = t.slides[n]; let i = -r.swiperSlideOffset; t.params.virtualTranslate || (i -= t.translate); let o = 0; t.isHorizontal() || (o = i, i = 0); const a = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(r.progress), 0) : 1 + Math.min(Math.max(r.progress, -1), 0); const s = be(0, r); s.style.opacity = a, s.style.transform = 'translate3d('.concat(i, 'px, ').concat(o, 'px, 0px)'); } },
            setTransition(e) {
              const n = t.slides.map(((e) => E(e))); n.forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })), we({
                swiper: t, duration: e, transformElements: n, allSlides: !0,
              });
            },
            overwriteParams() {
              return {
                slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode,
              };
            },
          });
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; n({
            cubeEffect: {
              slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: 0.94,
            },
          }); const i = function (e, t, n) { let r = n ? e.querySelector('.swiper-slide-shadow-left') : e.querySelector('.swiper-slide-shadow-top'); let i = n ? e.querySelector('.swiper-slide-shadow-right') : e.querySelector('.swiper-slide-shadow-bottom'); r || (r = C('div', (`swiper-slide-shadow-cube swiper-slide-shadow-${n ? 'left' : 'top'}`).split(' ')), e.append(r)), i || (i = C('div', (`swiper-slide-shadow-cube swiper-slide-shadow-${n ? 'right' : 'bottom'}`).split(' ')), e.append(i)), r && (r.style.opacity = Math.max(-t, 0)), i && (i.style.opacity = Math.max(t, 0)); }; ye({
            effect: 'cube',
            swiper: t,
            on: r,
            setTranslate() {
              let e; const n = t.el; const r = t.wrapperEl; const o = t.slides; const a = t.width; const s = t.height; const l = t.rtlTranslate; const c = t.size; const u = t.browser; const d = N(t); const p = t.params.cubeEffect; const f = t.isHorizontal(); const h = t.virtual && t.params.virtual.enabled; let m = 0; p.shadow && (f ? ((e = t.wrapperEl.querySelector('.swiper-cube-shadow')) || (e = C('div', 'swiper-cube-shadow'), t.wrapperEl.append(e)), e.style.height = ''.concat(a, 'px')) : (e = n.querySelector('.swiper-cube-shadow')) || (e = C('div', 'swiper-cube-shadow'), n.append(e))); for (let v = 0; v < o.length; v += 1) {
                const g = o[v]; let y = v; h && (y = parseInt(g.getAttribute('data-swiper-slide-index'), 10)); let b = 90 * y; let w = Math.floor(b / 360); l && (b = -b, w = Math.floor(-b / 360)); const S = Math.max(Math.min(g.progress, 1), -1); let x = 0; let E = 0; let T = 0; y % 4 == 0 ? (x = 4 * -w * c, T = 0) : (y - 1) % 4 == 0 ? (x = 0, T = 4 * -w * c) : (y - 2) % 4 == 0 ? (x = c + 4 * w * c, T = c) : (y - 3) % 4 == 0 && (x = -c, T = 3 * c + 4 * c * w), l && (x = -x), f || (E = x, x = 0); const _ = 'rotateX('.concat(d(f ? 0 : -b), 'deg) rotateY(').concat(d(f ? b : 0), 'deg) translate3d(').concat(x, 'px, ').concat(E, 'px, ')
                  .concat(T, 'px)'); S <= 1 && S > -1 && (m = 90 * y + 90 * S, l && (m = 90 * -y - 90 * S)), g.style.transform = _, p.slideShadows && i(g, S, f);
              } if (r.style.transformOrigin = '50% 50% -'.concat(c / 2, 'px'), r.style['-webkit-transform-origin'] = '50% 50% -'.concat(c / 2, 'px'), p.shadow) if (f)e.style.transform = 'translate3d(0px, '.concat(a / 2 + p.shadowOffset, 'px, ').concat(-a / 2, 'px) rotateX(89.99deg) rotateZ(0deg) scale(').concat(p.shadowScale, ')'); else { const L = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90); const k = 1.5 - (Math.sin(2 * L * Math.PI / 360) / 2 + Math.cos(2 * L * Math.PI / 360) / 2); const M = p.shadowScale; const A = p.shadowScale / k; const O = p.shadowOffset; e.style.transform = 'scale3d('.concat(M, ', 1, ').concat(A, ') translate3d(0px, ').concat(s / 2 + O, 'px, ').concat(-s / 2 / A, 'px) rotateX(-89.99deg)'); } const P = (u.isSafari || u.isWebView) && u.needPerspectiveFix ? -c / 2 : 0; r.style.transform = 'translate3d(0px,0,'.concat(P, 'px) rotateX(').concat(d(t.isHorizontal() ? 0 : m), 'deg) rotateY(').concat(d(t.isHorizontal() ? -m : 0), 'deg)'), r.style.setProperty('--swiper-cube-translate-z', ''.concat(P, 'px'));
            },
            setTransition(e) { const n = t.el; if (t.slides.forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'), t.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })); })), t.params.cubeEffect.shadow && !t.isHorizontal()) { const r = n.querySelector('.swiper-cube-shadow'); r && (r.style.transitionDuration = ''.concat(e, 'ms')); } },
            recreateShadows() { const e = t.isHorizontal(); t.slides.forEach(((t) => { const n = Math.max(Math.min(t.progress, 1), -1); i(t, n, e); })); },
            getEffectParams() { return t.params.cubeEffect; },
            perspective() { return !0; },
            overwriteParams() {
              return {
                slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0,
              };
            }
          });
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; n({ flipEffect: { slideShadows: !0, limitRotation: !0 } }); const i = function (e, n) { let r = t.isHorizontal() ? e.querySelector('.swiper-slide-shadow-left') : e.querySelector('.swiper-slide-shadow-top'); let i = t.isHorizontal() ? e.querySelector('.swiper-slide-shadow-right') : e.querySelector('.swiper-slide-shadow-bottom'); r || (r = Se('flip', e, t.isHorizontal() ? 'left' : 'top')), i || (i = Se('flip', e, t.isHorizontal() ? 'right' : 'bottom')), r && (r.style.opacity = Math.max(-n, 0)), i && (i.style.opacity = Math.max(n, 0)); }; ye({
            effect: 'flip',
            swiper: t,
            on: r,
            setTranslate() { for (let e = t.slides, n = t.rtlTranslate, r = t.params.flipEffect, o = N(t), a = 0; a < e.length; a += 1) { const s = e[a]; let l = s.progress; t.params.flipEffect.limitRotation && (l = Math.max(Math.min(s.progress, 1), -1)); const c = s.swiperSlideOffset; let u = -180 * l; let d = 0; let p = t.params.cssMode ? -c - t.translate : -c; let f = 0; t.isHorizontal() ? n && (u = -u) : (f = p, p = 0, d = -u, u = 0), s.style.zIndex = -Math.abs(Math.round(l)) + e.length, r.slideShadows && i(s, l); const h = 'translate3d('.concat(p, 'px, ').concat(f, 'px, 0px) rotateX(').concat(o(d), 'deg) rotateY(').concat(o(u), 'deg)'); be(0, s).style.transform = h; } },
            setTransition(e) { const n = t.slides.map(((e) => E(e))); n.forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'), t.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })); })), we({ swiper: t, duration: e, transformElements: n }); },
            recreateShadows() { t.params.flipEffect, t.slides.forEach(((e) => { let n = e.progress; t.params.flipEffect.limitRotation && (n = Math.max(Math.min(e.progress, 1), -1)), i(e, n); })); },
            getEffectParams() { return t.params.flipEffect; },
            perspective() { return !0; },
            overwriteParams() {
              return {
                slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode,
              };
            },
          });
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; n({
            coverflowEffect: {
              rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0,
            },
          }), ye({
            effect: 'coverflow',
            swiper: t,
            on: r,
            setTranslate() {
              for (let e = t.width, n = t.height, r = t.slides, i = t.slidesSizesGrid, o = t.params.coverflowEffect, a = t.isHorizontal(), s = t.translate, l = a ? e / 2 - s : n / 2 - s, c = a ? o.rotate : -o.rotate, u = o.depth, d = N(t), p = 0, f = r.length; p < f; p += 1) {
                const h = r[p]; const m = i[p]; const v = (l - h.swiperSlideOffset - m / 2) / m; const g = 'function' === typeof o.modifier ? o.modifier(v) : v * o.modifier; let y = a ? c * g : 0; let b = a ? 0 : c * g; let w = -u * Math.abs(g); let S = o.stretch; typeof S === 'string' && S.indexOf('%') !== -1 && (S = parseFloat(o.stretch) / 100 * m); let x = a ? 0 : S * g; let E = a ? S * g : 0; let T = 1 - (1 - o.scale) * Math.abs(g); Math.abs(E) < 0.001 && (E = 0), Math.abs(x) < 0.001 && (x = 0), Math.abs(w) < 0.001 && (w = 0), Math.abs(y) < 0.001 && (y = 0), Math.abs(b) < 0.001 && (b = 0), Math.abs(T) < 0.001 && (T = 0); const _ = 'translate3d('.concat(E, 'px,').concat(x, 'px,').concat(w, 'px)  rotateX(').concat(d(b), 'deg) rotateY(')
                  .concat(d(y), 'deg) scale(')
                  .concat(T, ')'); if (be(0, h).style.transform = _, h.style.zIndex = 1 - Math.abs(Math.round(g)), o.slideShadows) { let C = a ? h.querySelector('.swiper-slide-shadow-left') : h.querySelector('.swiper-slide-shadow-top'); let L = a ? h.querySelector('.swiper-slide-shadow-right') : h.querySelector('.swiper-slide-shadow-bottom'); C || (C = Se('coverflow', h, a ? 'left' : 'top')), L || (L = Se('coverflow', h, a ? 'right' : 'bottom')), C && (C.style.opacity = g > 0 ? g : 0), L && (L.style.opacity = -g > 0 ? -g : 0); }
              }
            },
            setTransition(e) { t.slides.map(((e) => E(e))).forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'), t.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })); })); },
            perspective() { return !0; },
            overwriteParams() { return { watchSlidesProgress: !0 }; },
          });
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; n({
            creativeEffect: {
              limitProgress: 1,
              shadowPerProgress: !1,
              progressMultiplier: 1,
              perspective: !0,
              prev: {
                translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1,
              },
              next: {
                translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1,
              },
            }
          }), ye({
            effect: 'creative',
            swiper: t,
            on: r,
            setTranslate() {
              const e = t.slides; const n = t.wrapperEl; const r = t.slidesSizesGrid; const i = t.params.creativeEffect; const o = i.progressMultiplier; const a = t.params.centeredSlides; const s = N(t); if (a) { const l = r[0] / 2 - t.params.slidesOffsetBefore || 0; n.style.transform = 'translateX(calc(50% - '.concat(l, 'px))'); } for (var c = function () {
                  const n = e[u]; const r = n.progress; const l = Math.min(Math.max(n.progress, -i.limitProgress), i.limitProgress); let c = l; a || (c = Math.min(Math.max(n.originalProgress, -i.limitProgress), i.limitProgress)); const d = n.swiperSlideOffset; const p = [t.params.cssMode ? -d - t.translate : -d, 0, 0]; const f = [0, 0, 0]; let h = !1; t.isHorizontal() || (p[1] = p[0], p[0] = 0); let m = {
                    translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1,
                  }; l < 0 ? (m = i.next, h = !0) : l > 0 && (m = i.prev, h = !0), p.forEach(((e, t) => { p[t] = 'calc('.concat(e, 'px + (').concat((function (e) { return typeof e === 'string' ? e : ''.concat(e, 'px'); }(m.translate[t])), ' * ').concat(Math.abs(l * o), '))'); })), f.forEach(((e, t) => { const n = m.rotate[t] * Math.abs(l * o); f[t] = n; })), n.style.zIndex = -Math.abs(Math.round(r)) + e.length; const v = p.join(', '); const g = 'rotateX('.concat(s(f[0]), 'deg) rotateY(').concat(s(f[1]), 'deg) rotateZ(').concat(s(f[2]), 'deg)'); const y = 'scale('.concat(c < 0 ? 1 + (1 - m.scale) * c * o : 1 - (1 - m.scale) * c * o, ')'); const b = c < 0 ? 1 + (1 - m.opacity) * c * o : 1 - (1 - m.opacity) * c * o; const w = 'translate3d('.concat(v, ') ').concat(g, ' ').concat(y); if (h && m.shadow || !h) { let S = n.querySelector('.swiper-slide-shadow'); if (!S && m.shadow && (S = Se('creative', n)), S) { const x = i.shadowPerProgress ? l * (1 / i.limitProgress) : l; S.style.opacity = Math.min(Math.max(Math.abs(x), 0), 1); } } const E = be(0, n); E.style.transform = w, E.style.opacity = b, m.origin && (E.style.transformOrigin = m.origin);
                }, u = 0; u < e.length; u += 1)c();
            },
            setTransition(e) {
              const n = t.slides.map(((e) => E(e))); n.forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'), t.querySelectorAll('.swiper-slide-shadow').forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })); })), we({
                swiper: t, duration: e, transformElements: n, allSlides: !0,
              });
            },
            perspective() { return t.params.creativeEffect.perspective; },
            overwriteParams() { return { watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }; },
          });
        }, function (e) {
          const t = e.swiper; const n = e.extendParams; const r = e.on; n({
            cardsEffect: {
              slideShadows: !0, rotate: !0, perSlideRotate: 2, perSlideOffset: 8,
            },
          }), ye({
            effect: 'cards',
            swiper: t,
            on: r,
            setTranslate() {
              for (let e = t.slides, n = t.activeIndex, r = t.rtlTranslate, i = t.params.cardsEffect, o = t.touchEventsData, a = o.startTranslate, s = o.isTouched, l = r ? -t.translate : t.translate, c = 0; c < e.length; c += 1) {
                const u = e[c]; const d = u.progress; const p = Math.min(Math.max(d, -4), 4); let f = u.swiperSlideOffset; t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = 'translateX('.concat(t.minTranslate(), 'px)')), t.params.centeredSlides && t.params.cssMode && (f -= e[0].swiperSlideOffset); let h = t.params.cssMode ? -f - t.translate : -f; let m = 0; const v = -100 * Math.abs(p); let g = 1; let y = -i.perSlideRotate * p; let b = i.perSlideOffset - 0.75 * Math.abs(p); const w = t.virtual && t.params.virtual.enabled ? t.virtual.from + c : c; const S = (w === n || w === n - 1) && p > 0 && p < 1 && (s || t.params.cssMode) && l < a; const x = (w === n || w === n + 1) && p < 0 && p > -1 && (s || t.params.cssMode) && l > a; if (S || x) { const E = (1 - Math.abs((Math.abs(p) - 0.5) / 0.5)) ** .5; y += -28 * p * E, g += -0.5 * E, b += 96 * E, m = `${-25 * E * Math.abs(p)}%`; } if (h = p < 0 ? 'calc('.concat(h, 'px ').concat(r ? '-' : '+', ' (').concat(b * Math.abs(p), '%))') : p > 0 ? 'calc('.concat(h, 'px ').concat(r ? '-' : '+', ' (-').concat(b * Math.abs(p), '%))') : ''.concat(h, 'px'), !t.isHorizontal()) { const T = m; m = h, h = T; } const _ = p < 0 ? `${  1 + (1 - g) * p}` : `${  1 - (1 - g) * p}`; const C = '\n        translate3d('.concat(h, ', ').concat(m, ', ').concat(v, 'px)\n        rotateZ(').concat(i.rotate ? r ? -y : y : 0, 'deg)\n        scale(')
                  .concat(_, ')\n      '); if (i.slideShadows) { let L = u.querySelector('.swiper-slide-shadow'); L || (L = Se('cards', u)), L && (L.style.opacity = Math.min(Math.max((Math.abs(p) - 0.5) / 0.5, 0), 1)); }u.style.zIndex = -Math.abs(Math.round(d)) + e.length, be(0, u).style.transform = C;
              }
            },
            setTransition(e) { const n = t.slides.map(((e) => E(e))); n.forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'), t.querySelectorAll('.swiper-slide-shadow').forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })); })), we({ swiper: t, duration: e, transformElements: n }); },
            perspective() { return !0; },
            overwriteParams() { return { watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }; },
          });
        }]; return ue.use(xe), ue;
      }()); function h(e, t) { return new f(e, t); }
    },
    316: (e, t, n) => {
      function r(e) { return (function (e) { if (Array.isArray(e)) return i(e); }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(e)) || (function (e, t) { if (e) { if (typeof e === 'string') return i(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? i(e, t) : void 0; } }(e)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function i(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; } function o(e) { const t = r(e.firstElementChild.children); e.classList.add('columns-'.concat(t.length, '-cols')), r(e.children).forEach(((e) => { r(e.children).forEach(((e) => { const t = e.querySelector('picture'); if (t) { const n = t.closest('div'); n && n.children.length === 1 && n.classList.add('columns-img-col'); } })); })); }n.r(t), n.d(t, { default: () => o });
    },
    400: () => {},
    640: (e, t, n) => {
      function r(e, t) { return (function (e) { if (Array.isArray(e)) return e; }(e)) || (function (e, t) { let n = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']; if (n != null) { let r; let i; let o; let a; const s = []; let l = !0; let c = !1; try { if (o = (n = n.call(e)).next, t === 0) { if (Object(n) !== n) return; l = !1; } else for (;!(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); l = !0); } catch (e) { c = !0, i = e; } finally { try { if (!l && n.return != null && (a = n.return(), Object(a) !== a)) return; } finally { if (c) throw i; } } return s; } }(e, t)) || (function (e, t) { if (e) { if (typeof e === 'string') return i(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? i(e, t) : void 0; } }(e, t)) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function i(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; }n.r(t), n.d(t, { default: () => c }); const o = function (e, t) { const n = new URLSearchParams(e.search); const i = t ? '&muted=1&autoplay=1' : ''; let o = n.get('v') ? encodeURIComponent(n.get('v')) : ''; const a = e.pathname; return e.origin.includes('youtu.be') && (o = r(e.pathname.split('/'), 2)[1]), '<div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;">\n          <iframe src="https://www.youtube.com'.concat(o ? '/embed/'.concat(o, '?rel=0&v=').concat(o).concat(i) : a, '" style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" \n          allow="autoplay; fullscreen; picture-in-picture; encrypted-media; accelerometer; gyroscope; picture-in-picture" allowfullscreen="" scrolling="no" title="Content from Youtube" loading="lazy"></iframe>\n        </div>'); }; const a = function (e, t) { const n = r(e.pathname.split('/'), 2)[1]; const i = t ? '?muted=1&autoplay=1' : ''; return '<div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;">\n          <iframe src="https://player.vimeo.com/video/'.concat(n).concat(i, '" \n          style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" \n          frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen  \n          title="Content from Vimeo" loading="lazy"></iframe>\n        </div>'); }; const s = function (e) { let t; let n; const r = '<blockquote class="twitter-tweet"><a href="'.concat(e.href, '"></a></blockquote>'); return t = document.querySelector('head'), (n = document.createElement('script')).src = 'https://platform.twitter.com/widgets.js', n.onload = void 0, t.append(n), r; }; const l = function (e, t, n) { if (!e.classList.contains('embed-is-loaded')) { const r = [{ match: ['youtube', 'youtu.be'], embed: o }, { match: ['vimeo'], embed: a }, { match: ['twitter'], embed: s }].find(((e) => e.match.some(((e) => t.includes(e))))); const i = new URL(t); r ? (e.innerHTML = r.embed(i, n), e.classList = 'block embed embed-'.concat(r.match[0])) : (e.innerHTML = (function (e) { return '<div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;">\n        <iframe src="'.concat(e.href, '" style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" allowfullscreen=""\n          scrolling="no" allow="encrypted-media" title="Content from ').concat(e.hostname, '" loading="lazy">\n        </iframe>\n      </div>'); }(i)), e.classList = 'block embed'), e.classList.add('embed-is-loaded'); } }; function c(e) { const t = e.querySelector('picture'); const n = e.querySelector('a').href; if (e.textContent = '', t) { const r = document.createElement('div'); r.className = 'embed-placeholder', r.innerHTML = '<div class="embed-placeholder-play"><button type="button" title="Play"></button></div>', r.prepend(t), r.addEventListener('click', (() => { l(e, n, !0); })), e.append(r); } else { var i = new IntersectionObserver(((t) => { t.some(((e) => e.isIntersecting)) && (i.disconnect(), l(e, n)); })); i.observe(e); } }
    },
    676: (e, t, n) => {
      n.r(t), n.d(t, { default: () => l }); const r = n(927); const i = n(658); function o(e) { return o = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, o(e); } function a() {
        a = function () { return t; }; let e; var t = {}; const n = Object.prototype; const r = n.hasOwnProperty; const i = Object.defineProperty || function (e, t, n) { e[t] = n.value; }; const s = typeof Symbol === 'function' ? Symbol : {}; const l = s.iterator || '@@iterator'; const c = s.asyncIterator || '@@asyncIterator'; const u = s.toStringTag || '@@toStringTag'; function d(e, t, n) {
          return Object.defineProperty(e, t, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
          }), e[t];
        } try { d({}, ''); } catch (e) { d = function (e, t, n) { return e[t] = n; }; } function p(e, t, n, r) { const o = t && t.prototype instanceof b ? t : b; const a = Object.create(o.prototype); const s = new P(r || []); return i(a, '_invoke', { value: k(e, n, s) }), a; } function f(e, t, n) { try { return { type: 'normal', arg: e.call(t, n) }; } catch (e) { return { type: 'throw', arg: e }; } }t.wrap = p; const h = 'suspendedStart'; const m = 'suspendedYield'; const v = 'executing'; const g = 'completed'; const y = {}; function b() {} function w() {} function S() {} let x = {}; d(x, l, (function () { return this; })); const E = Object.getPrototypeOf; const T = E && E(E(I([]))); T && T !== n && r.call(T, l) && (x = T); const _ = S.prototype = b.prototype = Object.create(x); function C(e) { ['next', 'throw', 'return'].forEach(((t) => { d(e, t, (function (e) { return this._invoke(t, e); })); })); } function L(e, t) { function n(i, a, s, l) { const c = f(e[i], e, a); if (c.type !== 'throw') { const u = c.arg; const d = u.value; return d && o(d) == 'object' && r.call(d, '__await') ? t.resolve(d.__await).then(((e) => { n('next', e, s, l); }), ((e) => { n('throw', e, s, l); })) : t.resolve(d).then(((e) => { u.value = e, s(u); }), ((e) => n('throw', e, s, l))); }l(c.arg); } let a; i(this, '_invoke', { value(e, r) { function i() { return new t(((t, i) => { n(e, r, t, i); })); } return a = a ? a.then(i, i) : i(); } }); } function k(t, n, r) { let i = h; return function (o, a) { if (i === v) throw Error('Generator is already running'); if (i === g) { if (o === 'throw') throw a; return { value: e, done: !0 }; } for (r.method = o, r.arg = a; ;) { const s = r.delegate; if (s) { const l = M(s, r); if (l) { if (l === y) continue; return l; } } if (r.method === 'next')r.sent = r._sent = r.arg; else if (r.method === 'throw') { if (i === h) throw i = g, r.arg; r.dispatchException(r.arg); } else r.method === 'return' && r.abrupt('return', r.arg); i = v; const c = f(t, n, r); if (c.type === 'normal') { if (i = r.done ? g : m, c.arg === y) continue; return { value: c.arg, done: r.done }; }c.type === 'throw' && (i = g, r.method = 'throw', r.arg = c.arg); } }; } function M(t, n) { const r = n.method; const i = t.iterator[r]; if (i === e) return n.delegate = null, r === 'throw' && t.iterator.return && (n.method = 'return', n.arg = e, M(t, n), n.method === 'throw') || r !== 'return' && (n.method = 'throw', n.arg = new TypeError(`The iterator does not provide a '${r}' method`)), y; const o = f(i, t.iterator, n.arg); if (o.type === 'throw') return n.method = 'throw', n.arg = o.arg, n.delegate = null, y; const a = o.arg; return a ? a.done ? (n[t.resultName] = a.value, n.next = t.nextLoc, n.method !== 'return' && (n.method = 'next', n.arg = e), n.delegate = null, y) : a : (n.method = 'throw', n.arg = new TypeError('iterator result is not an object'), n.delegate = null, y); } function A(e) { const t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t); } function O(e) { const t = e.completion || {}; t.type = 'normal', delete t.arg, e.completion = t; } function P(e) { this.tryEntries = [{ tryLoc: 'root' }], e.forEach(A, this), this.reset(!0); } function I(t) { if (t || t === '') { const n = t[l]; if (n) return n.call(t); if (typeof t.next === 'function') return t; if (!isNaN(t.length)) { let i = -1; const a = function n() { for (;++i < t.length;) if (r.call(t, i)) return n.value = t[i], n.done = !1, n; return n.value = e, n.done = !0, n; }; return a.next = a; } } throw new TypeError(`${o(t)} is not iterable`); } return w.prototype = S, i(_, 'constructor', { value: S, configurable: !0 }), i(S, 'constructor', { value: w, configurable: !0 }), w.displayName = d(S, u, 'GeneratorFunction'), t.isGeneratorFunction = function (e) { const t = typeof e === 'function' && e.constructor; return !!t && (t === w || (t.displayName || t.name) === 'GeneratorFunction'); }, t.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, S) : (e.__proto__ = S, d(e, u, 'GeneratorFunction')), e.prototype = Object.create(_), e; }, t.awrap = function (e) { return { __await: e }; }, C(L.prototype), d(L.prototype, c, (function () { return this; })), t.AsyncIterator = L, t.async = function (e, n, r, i, o) { void 0 === o && (o = Promise); const a = new L(p(e, n, r, i), o); return t.isGeneratorFunction(n) ? a : a.next().then(((e) => (e.done ? e.value : a.next()))); }, C(_), d(_, u, 'Generator'), d(_, l, (function () { return this; })), d(_, 'toString', (() => '[object Generator]')), t.keys = function (e) { const t = Object(e); const n = []; for (const r in t)n.push(r); return n.reverse(), function e() { for (;n.length;) { const r = n.pop(); if (r in t) return e.value = r, e.done = !1, e; } return e.done = !0, e; }; }, t.values = I, P.prototype = {
          constructor: P, reset(t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = 'next', this.arg = e, this.tryEntries.forEach(O), !t) for (const n in this)n.charAt(0) === 't' && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e); }, stop() { this.done = !0; const e = this.tryEntries[0].completion; if (e.type === 'throw') throw e.arg; return this.rval; }, dispatchException(t) { if (this.done) throw t; const n = this; function i(r, i) { return s.type = 'throw', s.arg = t, n.next = r, i && (n.method = 'next', n.arg = e), !!i; } for (let o = this.tryEntries.length - 1; o >= 0; --o) { const a = this.tryEntries[o]; var s = a.completion; if (a.tryLoc === 'root') return i('end'); if (a.tryLoc <= this.prev) { const l = r.call(a, 'catchLoc'); const c = r.call(a, 'finallyLoc'); if (l && c) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } else if (l) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); } else { if (!c) throw Error('try statement without catch or finally'); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } } } }, abrupt(e, t) { for (let n = this.tryEntries.length - 1; n >= 0; --n) { const i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, 'finallyLoc') && this.prev < i.finallyLoc) { var o = i; break; } }o && (e === 'break' || e === 'continue') && o.tryLoc <= t && t <= o.finallyLoc && (o = null); const a = o ? o.completion : {}; return a.type = e, a.arg = t, o ? (this.method = 'next', this.next = o.finallyLoc, y) : this.complete(a); }, complete(e, t) { if (e.type === 'throw') throw e.arg; return e.type === 'break' || e.type === 'continue' ? this.next = e.arg : e.type === 'return' ? (this.rval = this.arg = e.arg, this.method = 'return', this.next = 'end') : e.type === 'normal' && t && (this.next = t), y; }, finish(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), O(n), y; } }, catch(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.tryLoc === e) { const r = n.completion; if (r.type === 'throw') { var i = r.arg; O(n); } return i; } } throw Error('illegal catch attempt'); }, delegateYield(t, n, r) { return this.delegate = { iterator: I(t), resultName: n, nextLoc: r }, this.method === 'next' && (this.arg = e), y; },
        }, t;
      } function s(e, t, n, r, i, o, a) { try { var s = e[o](a); var l = s.value; } catch (e) { return void n(e); }s.done ? t(l) : Promise.resolve(l).then(r, i); } function l(e) { return c.apply(this, arguments); } function c() { let e; return e = a().mark((function e(t) { let n; let o; let s; let l; return a().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: return n = (0, r.yb)('footer'), o = n ? new URL(n, window.location).pathname : '/footer', e.next = 4, (0, i.LL)(o); case 4: for (s = e.sent, t.textContent = '', l = document.createElement('div'); s.firstElementChild;)l.append(s.firstElementChild); t.append(l); case 9: case 'end': return e.stop(); } }), e); })), c = function () { const t = this; const n = arguments; return new Promise(((r, i) => { const o = e.apply(t, n); function a(e) { s(o, r, i, a, l, 'next', e); } function l(e) { s(o, r, i, a, l, 'throw', e); }a(void 0); })); }, c.apply(this, arguments); }
    },
    146: (e, t, n) => {
      n.r(t), n.d(t, { default: () => m }); const r = n(927); function i(e) { return i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, i(e); } function o() {
        o = function () { return t; }; let e; var t = {}; const n = Object.prototype; const r = n.hasOwnProperty; const a = Object.defineProperty || function (e, t, n) { e[t] = n.value; }; const s = typeof Symbol === 'function' ? Symbol : {}; const l = s.iterator || '@@iterator'; const c = s.asyncIterator || '@@asyncIterator'; const u = s.toStringTag || '@@toStringTag'; function d(e, t, n) {
          return Object.defineProperty(e, t, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
          }), e[t];
        } try { d({}, ''); } catch (e) { d = function (e, t, n) { return e[t] = n; }; } function p(e, t, n, r) { const i = t && t.prototype instanceof b ? t : b; const o = Object.create(i.prototype); const s = new P(r || []); return a(o, '_invoke', { value: k(e, n, s) }), o; } function f(e, t, n) { try { return { type: 'normal', arg: e.call(t, n) }; } catch (e) { return { type: 'throw', arg: e }; } }t.wrap = p; const h = 'suspendedStart'; const m = 'suspendedYield'; const v = 'executing'; const g = 'completed'; const y = {}; function b() {} function w() {} function S() {} let x = {}; d(x, l, (function () { return this; })); const E = Object.getPrototypeOf; const T = E && E(E(I([]))); T && T !== n && r.call(T, l) && (x = T); const _ = S.prototype = b.prototype = Object.create(x); function C(e) { ['next', 'throw', 'return'].forEach(((t) => { d(e, t, (function (e) { return this._invoke(t, e); })); })); } function L(e, t) { function n(o, a, s, l) { const c = f(e[o], e, a); if (c.type !== 'throw') { const u = c.arg; const d = u.value; return d && i(d) == 'object' && r.call(d, '__await') ? t.resolve(d.__await).then(((e) => { n('next', e, s, l); }), ((e) => { n('throw', e, s, l); })) : t.resolve(d).then(((e) => { u.value = e, s(u); }), ((e) => n('throw', e, s, l))); }l(c.arg); } let o; a(this, '_invoke', { value(e, r) { function i() { return new t(((t, i) => { n(e, r, t, i); })); } return o = o ? o.then(i, i) : i(); } }); } function k(t, n, r) { let i = h; return function (o, a) { if (i === v) throw Error('Generator is already running'); if (i === g) { if (o === 'throw') throw a; return { value: e, done: !0 }; } for (r.method = o, r.arg = a; ;) { const s = r.delegate; if (s) { const l = M(s, r); if (l) { if (l === y) continue; return l; } } if (r.method === 'next')r.sent = r._sent = r.arg; else if (r.method === 'throw') { if (i === h) throw i = g, r.arg; r.dispatchException(r.arg); } else r.method === 'return' && r.abrupt('return', r.arg); i = v; const c = f(t, n, r); if (c.type === 'normal') { if (i = r.done ? g : m, c.arg === y) continue; return { value: c.arg, done: r.done }; }c.type === 'throw' && (i = g, r.method = 'throw', r.arg = c.arg); } }; } function M(t, n) { const r = n.method; const i = t.iterator[r]; if (i === e) return n.delegate = null, r === 'throw' && t.iterator.return && (n.method = 'return', n.arg = e, M(t, n), n.method === 'throw') || r !== 'return' && (n.method = 'throw', n.arg = new TypeError(`The iterator does not provide a '${r}' method`)), y; const o = f(i, t.iterator, n.arg); if (o.type === 'throw') return n.method = 'throw', n.arg = o.arg, n.delegate = null, y; const a = o.arg; return a ? a.done ? (n[t.resultName] = a.value, n.next = t.nextLoc, n.method !== 'return' && (n.method = 'next', n.arg = e), n.delegate = null, y) : a : (n.method = 'throw', n.arg = new TypeError('iterator result is not an object'), n.delegate = null, y); } function A(e) { const t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t); } function O(e) { const t = e.completion || {}; t.type = 'normal', delete t.arg, e.completion = t; } function P(e) { this.tryEntries = [{ tryLoc: 'root' }], e.forEach(A, this), this.reset(!0); } function I(t) { if (t || t === '') { const n = t[l]; if (n) return n.call(t); if (typeof t.next === 'function') return t; if (!isNaN(t.length)) { let o = -1; const a = function n() { for (;++o < t.length;) if (r.call(t, o)) return n.value = t[o], n.done = !1, n; return n.value = e, n.done = !0, n; }; return a.next = a; } } throw new TypeError(`${i(t)} is not iterable`); } return w.prototype = S, a(_, 'constructor', { value: S, configurable: !0 }), a(S, 'constructor', { value: w, configurable: !0 }), w.displayName = d(S, u, 'GeneratorFunction'), t.isGeneratorFunction = function (e) { const t = typeof e === 'function' && e.constructor; return !!t && (t === w || (t.displayName || t.name) === 'GeneratorFunction'); }, t.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, S) : (e.__proto__ = S, d(e, u, 'GeneratorFunction')), e.prototype = Object.create(_), e; }, t.awrap = function (e) { return { __await: e }; }, C(L.prototype), d(L.prototype, c, (function () { return this; })), t.AsyncIterator = L, t.async = function (e, n, r, i, o) { void 0 === o && (o = Promise); const a = new L(p(e, n, r, i), o); return t.isGeneratorFunction(n) ? a : a.next().then(((e) => (e.done ? e.value : a.next()))); }, C(_), d(_, u, 'Generator'), d(_, l, (function () { return this; })), d(_, 'toString', (() => '[object Generator]')), t.keys = function (e) { const t = Object(e); const n = []; for (const r in t)n.push(r); return n.reverse(), function e() { for (;n.length;) { const r = n.pop(); if (r in t) return e.value = r, e.done = !1, e; } return e.done = !0, e; }; }, t.values = I, P.prototype = {
          constructor: P, reset(t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = 'next', this.arg = e, this.tryEntries.forEach(O), !t) for (const n in this)n.charAt(0) === 't' && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e); }, stop() { this.done = !0; const e = this.tryEntries[0].completion; if (e.type === 'throw') throw e.arg; return this.rval; }, dispatchException(t) { if (this.done) throw t; const n = this; function i(r, i) { return s.type = 'throw', s.arg = t, n.next = r, i && (n.method = 'next', n.arg = e), !!i; } for (let o = this.tryEntries.length - 1; o >= 0; --o) { const a = this.tryEntries[o]; var s = a.completion; if (a.tryLoc === 'root') return i('end'); if (a.tryLoc <= this.prev) { const l = r.call(a, 'catchLoc'); const c = r.call(a, 'finallyLoc'); if (l && c) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } else if (l) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); } else { if (!c) throw Error('try statement without catch or finally'); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } } } }, abrupt(e, t) { for (let n = this.tryEntries.length - 1; n >= 0; --n) { const i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, 'finallyLoc') && this.prev < i.finallyLoc) { var o = i; break; } }o && (e === 'break' || e === 'continue') && o.tryLoc <= t && t <= o.finallyLoc && (o = null); const a = o ? o.completion : {}; return a.type = e, a.arg = t, o ? (this.method = 'next', this.next = o.finallyLoc, y) : this.complete(a); }, complete(e, t) { if (e.type === 'throw') throw e.arg; return e.type === 'break' || e.type === 'continue' ? this.next = e.arg : e.type === 'return' ? (this.rval = this.arg = e.arg, this.method = 'return', this.next = 'end') : e.type === 'normal' && t && (this.next = t), y; }, finish(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), O(n), y; } }, catch(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.tryLoc === e) { const r = n.completion; if (r.type === 'throw') { var i = r.arg; O(n); } return i; } } throw Error('illegal catch attempt'); }, delegateYield(t, n, r) { return this.delegate = { iterator: I(t), resultName: n, nextLoc: r }, this.method === 'next' && (this.arg = e), y; },
        }, t;
      } function a(e, t, n, r, i, o, a) { try { var s = e[o](a); var l = s.value; } catch (e) { return void n(e); }s.done ? t(l) : Promise.resolve(l).then(r, i); } function s(e) { return function () { const t = this; const n = arguments; return new Promise(((r, i) => { const o = e.apply(t, n); function s(e) { a(o, r, i, s, l, 'next', e); } function l(e) { a(o, r, i, s, l, 'throw', e); }s(void 0); })); }; } function l(e) { const t = document.createElement('div'); return e.Style && (t.className = e.Style), t.classList.add('field-wrapper', ''.concat(e.Type, '-wrapper')), t.dataset.fieldset = e.Fieldset, t; } const c = []; function u(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ''; const n = (0, r.L4)('form-'.concat(e.Name).concat(t)); c[n] = c[n] || 0; const i = c[n] ? '-'.concat(c[n]) : ''; return c[n] += 1, ''.concat(n).concat(i); } function d(e) { const t = document.createElement('label'); return t.id = u(e, '-label'), t.innerHTML = e.Label || e.Name, t.setAttribute('for', e.Id), e.Mandatory.toLowerCase() !== 'true' && e.Mandatory.toLowerCase() !== 'x' || (t.dataset.required = !0), t; } function p(e, t) { e.id = t.Id, e.name = t.Name, e.required = t.Mandatory && (t.Mandatory.toLowerCase() === 'true' || t.Mandatory.toLowerCase() === 'x'), e.placeholder = t.Placeholder, e.value = t.Value; } const f = function (e) { const t = document.createElement('input'); t.type = e.Type, p(t, e); const n = l(e); const r = d(e); return t.setAttribute('aria-labelledby', r.id), n.append(t), e.Type === 'radio' || e.Type === 'checkbox' ? n.append(r) : n.prepend(r), { field: t, fieldWrapper: n }; }; const h = {
        select: (function () { const e = s(o().mark((function e(t) { let n; let r; let i; let a; let s; let c; return o().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: if (p(n = document.createElement('select'), t), r = function (e) { const t = e.text; const r = e.value; const i = document.createElement('option'); return i.text = t.trim(), i.value = r.trim(), i.value === n.value && i.setAttribute('selected', ''), n.add(i), i; }, t.Placeholder && r({ text: t.Placeholder, value: '' }).setAttribute('disabled', ''), !t.Options) { e.next = 19; break; } if (i = [], !t.Options.startsWith('https://')) { e.next = 17; break; } return a = new URL(t.Options), e.next = 10, fetch(''.concat(a.pathname).concat(a.search)); case 10: return s = e.sent, e.next = 13, s.json(); case 13: e.sent.data.forEach(((e) => { i.push({ text: e.Option, value: e.Value || e.Option }); })), e.next = 18; break; case 17: i = t.Options.split(',').map(((e) => ({ text: e.trim(), value: e.trim().toLowerCase() }))); case 18: i.forEach(((e) => r(e))); case 19: return (c = l(t)).append(n), c.prepend(d(t)), e.abrupt('return', { field: n, fieldWrapper: c }); case 23: case 'end': return e.stop(); } }), e); }))); return function (t) { return e.apply(this, arguments); }; }()), heading(e) { const t = l(e); const n = e.Style && e.Style.includes('sub-heading') ? 3 : 2; const r = document.createElement('h'.concat(n)); return r.innerHTML = e.Value || e.Label, r.id = e.Id, t.append(r), { field: r, fieldWrapper: t }; }, plaintext(e) { const t = l(e); const n = document.createElement('p'); return n.innerHTML = e.Value || e.Label, n.id = e.Id, t.append(n), { field: n, fieldWrapper: t }; }, 'text-area': function (e) { const t = document.createElement('textarea'); p(t, e); const n = l(e); const r = d(e); return t.setAttribute('aria-labelledby', r.id), n.append(t), n.prepend(r), { field: t, fieldWrapper: n }; }, toggle(e) { const t = f(e); const n = t.field; const r = t.fieldWrapper; n.type = 'checkbox', n.value || (n.value = 'on'), n.classList.add('toggle'), r.classList.add('selection-wrapper'); const i = document.createElement('div'); i.classList.add('switch'), i.append(n), r.append(i); const o = document.createElement('span'); return o.classList.add('slider'), i.append(o), o.addEventListener('click', (() => { n.checked = !n.checked; })), { field: n, fieldWrapper: r }; }, submit(e) { const t = document.createElement('button'); t.textContent = e.Label || e.Name, t.classList.add('button'), t.type = 'submit'; const n = l(e); return n.append(t), { field: t, fieldWrapper: n }; }, confirmation(e, t) { return t.dataset.confirmation = new URL(e.Value).pathname, {}; }, fieldset(e) { const t = document.createElement('fieldset'); if (p(t, e), e.Label) { const n = document.createElement('legend'); n.textContent = e.Label, t.append(n); } const r = l(e); return r.append(t), { field: t, fieldWrapper: r }; }, checkbox(e) { const t = f(e); const n = t.field; const r = t.fieldWrapper; return n.value || (n.value = 'checked'), r.classList.add('selection-wrapper'), { field: n, fieldWrapper: r }; }, radio(e) { const t = f(e); const n = t.field; const r = t.fieldWrapper; return n.value || (n.value = e.Label || 'on'), r.classList.add('selection-wrapper'), { field: n, fieldWrapper: r }; },
      }; function m(e, t) { return v.apply(this, arguments); } function v() { return (v = s(o().mark((function e(t, n) { let r; let i; let a; return o().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: return t.Id = t.Id || u(t), r = t.Type.toLowerCase(), i = h[r] || f, e.next = 5, i(t, n); case 5: return a = e.sent, e.abrupt('return', a.fieldWrapper); case 7: case 'end': return e.stop(); } }), e); })))).apply(this, arguments); }
    },
    874: (e, t, n) => {
      n.r(t), n.d(t, { default: () => m }); const r = n(146); function i(e) { return i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, i(e); } function o() {
        o = function () { return t; }; let e; var t = {}; const n = Object.prototype; const r = n.hasOwnProperty; const a = Object.defineProperty || function (e, t, n) { e[t] = n.value; }; const s = typeof Symbol === 'function' ? Symbol : {}; const l = s.iterator || '@@iterator'; const c = s.asyncIterator || '@@asyncIterator'; const u = s.toStringTag || '@@toStringTag'; function d(e, t, n) {
          return Object.defineProperty(e, t, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
          }), e[t];
        } try { d({}, ''); } catch (e) { d = function (e, t, n) { return e[t] = n; }; } function p(e, t, n, r) { const i = t && t.prototype instanceof b ? t : b; const o = Object.create(i.prototype); const s = new P(r || []); return a(o, '_invoke', { value: k(e, n, s) }), o; } function f(e, t, n) { try { return { type: 'normal', arg: e.call(t, n) }; } catch (e) { return { type: 'throw', arg: e }; } }t.wrap = p; const h = 'suspendedStart'; const m = 'suspendedYield'; const v = 'executing'; const g = 'completed'; const y = {}; function b() {} function w() {} function S() {} let x = {}; d(x, l, (function () { return this; })); const E = Object.getPrototypeOf; const T = E && E(E(I([]))); T && T !== n && r.call(T, l) && (x = T); const _ = S.prototype = b.prototype = Object.create(x); function C(e) { ['next', 'throw', 'return'].forEach(((t) => { d(e, t, (function (e) { return this._invoke(t, e); })); })); } function L(e, t) { function n(o, a, s, l) { const c = f(e[o], e, a); if (c.type !== 'throw') { const u = c.arg; const d = u.value; return d && i(d) == 'object' && r.call(d, '__await') ? t.resolve(d.__await).then(((e) => { n('next', e, s, l); }), ((e) => { n('throw', e, s, l); })) : t.resolve(d).then(((e) => { u.value = e, s(u); }), ((e) => n('throw', e, s, l))); }l(c.arg); } let o; a(this, '_invoke', { value(e, r) { function i() { return new t(((t, i) => { n(e, r, t, i); })); } return o = o ? o.then(i, i) : i(); } }); } function k(t, n, r) { let i = h; return function (o, a) { if (i === v) throw Error('Generator is already running'); if (i === g) { if (o === 'throw') throw a; return { value: e, done: !0 }; } for (r.method = o, r.arg = a; ;) { const s = r.delegate; if (s) { const l = M(s, r); if (l) { if (l === y) continue; return l; } } if (r.method === 'next')r.sent = r._sent = r.arg; else if (r.method === 'throw') { if (i === h) throw i = g, r.arg; r.dispatchException(r.arg); } else r.method === 'return' && r.abrupt('return', r.arg); i = v; const c = f(t, n, r); if (c.type === 'normal') { if (i = r.done ? g : m, c.arg === y) continue; return { value: c.arg, done: r.done }; }c.type === 'throw' && (i = g, r.method = 'throw', r.arg = c.arg); } }; } function M(t, n) { const r = n.method; const i = t.iterator[r]; if (i === e) return n.delegate = null, r === 'throw' && t.iterator.return && (n.method = 'return', n.arg = e, M(t, n), n.method === 'throw') || r !== 'return' && (n.method = 'throw', n.arg = new TypeError(`The iterator does not provide a '${r}' method`)), y; const o = f(i, t.iterator, n.arg); if (o.type === 'throw') return n.method = 'throw', n.arg = o.arg, n.delegate = null, y; const a = o.arg; return a ? a.done ? (n[t.resultName] = a.value, n.next = t.nextLoc, n.method !== 'return' && (n.method = 'next', n.arg = e), n.delegate = null, y) : a : (n.method = 'throw', n.arg = new TypeError('iterator result is not an object'), n.delegate = null, y); } function A(e) { const t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t); } function O(e) { const t = e.completion || {}; t.type = 'normal', delete t.arg, e.completion = t; } function P(e) { this.tryEntries = [{ tryLoc: 'root' }], e.forEach(A, this), this.reset(!0); } function I(t) { if (t || t === '') { const n = t[l]; if (n) return n.call(t); if (typeof t.next === 'function') return t; if (!isNaN(t.length)) { let o = -1; const a = function n() { for (;++o < t.length;) if (r.call(t, o)) return n.value = t[o], n.done = !1, n; return n.value = e, n.done = !0, n; }; return a.next = a; } } throw new TypeError(`${i(t)} is not iterable`); } return w.prototype = S, a(_, 'constructor', { value: S, configurable: !0 }), a(S, 'constructor', { value: w, configurable: !0 }), w.displayName = d(S, u, 'GeneratorFunction'), t.isGeneratorFunction = function (e) { const t = typeof e === 'function' && e.constructor; return !!t && (t === w || (t.displayName || t.name) === 'GeneratorFunction'); }, t.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, S) : (e.__proto__ = S, d(e, u, 'GeneratorFunction')), e.prototype = Object.create(_), e; }, t.awrap = function (e) { return { __await: e }; }, C(L.prototype), d(L.prototype, c, (function () { return this; })), t.AsyncIterator = L, t.async = function (e, n, r, i, o) { void 0 === o && (o = Promise); const a = new L(p(e, n, r, i), o); return t.isGeneratorFunction(n) ? a : a.next().then(((e) => (e.done ? e.value : a.next()))); }, C(_), d(_, u, 'Generator'), d(_, l, (function () { return this; })), d(_, 'toString', (() => '[object Generator]')), t.keys = function (e) { const t = Object(e); const n = []; for (const r in t)n.push(r); return n.reverse(), function e() { for (;n.length;) { const r = n.pop(); if (r in t) return e.value = r, e.done = !1, e; } return e.done = !0, e; }; }, t.values = I, P.prototype = {
          constructor: P, reset(t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = 'next', this.arg = e, this.tryEntries.forEach(O), !t) for (const n in this)n.charAt(0) === 't' && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e); }, stop() { this.done = !0; const e = this.tryEntries[0].completion; if (e.type === 'throw') throw e.arg; return this.rval; }, dispatchException(t) { if (this.done) throw t; const n = this; function i(r, i) { return s.type = 'throw', s.arg = t, n.next = r, i && (n.method = 'next', n.arg = e), !!i; } for (let o = this.tryEntries.length - 1; o >= 0; --o) { const a = this.tryEntries[o]; var s = a.completion; if (a.tryLoc === 'root') return i('end'); if (a.tryLoc <= this.prev) { const l = r.call(a, 'catchLoc'); const c = r.call(a, 'finallyLoc'); if (l && c) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } else if (l) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); } else { if (!c) throw Error('try statement without catch or finally'); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } } } }, abrupt(e, t) { for (let n = this.tryEntries.length - 1; n >= 0; --n) { const i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, 'finallyLoc') && this.prev < i.finallyLoc) { var o = i; break; } }o && (e === 'break' || e === 'continue') && o.tryLoc <= t && t <= o.finallyLoc && (o = null); const a = o ? o.completion : {}; return a.type = e, a.arg = t, o ? (this.method = 'next', this.next = o.finallyLoc, y) : this.complete(a); }, complete(e, t) { if (e.type === 'throw') throw e.arg; return e.type === 'break' || e.type === 'continue' ? this.next = e.arg : e.type === 'return' ? (this.rval = this.arg = e.arg, this.method = 'return', this.next = 'end') : e.type === 'normal' && t && (this.next = t), y; }, finish(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), O(n), y; } }, catch(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.tryLoc === e) { const r = n.completion; if (r.type === 'throw') { var i = r.arg; O(n); } return i; } } throw Error('illegal catch attempt'); }, delegateYield(t, n, r) { return this.delegate = { iterator: I(t), resultName: n, nextLoc: r }, this.method === 'next' && (this.arg = e), y; },
        }, t;
      } function a(e) { return (function (e) { if (Array.isArray(e)) return s(e); }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(e)) || (function (e, t) { if (e) { if (typeof e === 'string') return s(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? s(e, t) : void 0; } }(e)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function s(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; } function l(e, t, n, r, i, o, a) { try { var s = e[o](a); var l = s.value; } catch (e) { return void n(e); }s.done ? t(l) : Promise.resolve(l).then(r, i); } function c(e) { return function () { const t = this; const n = arguments; return new Promise(((r, i) => { const o = e.apply(t, n); function a(e) { l(o, r, i, a, s, 'next', e); } function s(e) { l(o, r, i, a, s, 'throw', e); }a(void 0); })); }; } function u(e, t) { return d.apply(this, arguments); } function d() { return (d = c(o().mark((function e(t, n) { let i; let a; let s; let l; let c; return o().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: return i = new URL(t), a = i.pathname, e.next = 3, fetch(a); case 3: return s = e.sent, e.next = 6, s.json(); case 6: return l = e.sent, (c = document.createElement('form')).dataset.action = n, e.next = 11, Promise.all(l.data.map(((e) => (0, r.default)(e, c)))); case 11: return e.sent.forEach(((e) => { e && c.append(e); })), c.querySelectorAll('fieldset').forEach(((e) => { c.querySelectorAll('[data-fieldset="'.concat(e.name, '"')).forEach(((t) => { e.append(t); })); })), e.abrupt('return', c); case 16: case 'end': return e.stop(); } }), e); })))).apply(this, arguments); } function p(e) { const t = {}; return a(e.elements).forEach(((e) => { e.name && e.type !== 'submit' && !e.disabled && (e.type === 'radio' ? e.checked && (t[e.name] = e.value) : e.type === 'checkbox' ? e.checked && (t[e.name] = t[e.name] ? ''.concat(t[e.name], ',').concat(e.value) : e.value) : t[e.name] = e.value); })), t; } function f(e) { return h.apply(this, arguments); } function h() { return (h = c(o().mark((function e(t) { let n; let r; let i; let a; return o().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: if (t.getAttribute('data-submitting') !== 'true') { e.next = 2; break; } return e.abrupt('return'); case 2: return n = t.querySelector('button[type="submit"]'), e.prev = 3, t.setAttribute('data-submitting', 'true'), n.disabled = !0, r = p(t), e.next = 9, fetch(t.dataset.action, { method: 'POST', body: JSON.stringify({ data: r }), headers: { 'Content-Type': 'application/json' } }); case 9: if (!(i = e.sent).ok) { e.next = 14; break; }t.dataset.confirmation && (window.location.href = t.dataset.confirmation), e.next = 18; break; case 14: return e.next = 16, i.text(); case 16: throw a = e.sent, new Error(a); case 18: e.next = 23; break; case 20: e.prev = 20, e.t0 = e.catch(3), console.error(e.t0); case 23: return e.prev = 23, t.setAttribute('data-submitting', 'false'), n.disabled = !1, e.finish(23); case 27: case 'end': return e.stop(); } }), e, null, [[3, 20, 23, 27]]); })))).apply(this, arguments); } function m(e) { return v.apply(this, arguments); } function v() { return (v = c(o().mark((function e(t) { let n; let r; let i; let s; return o().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: if (n = a(t.querySelectorAll('a')).map(((e) => e.href)), r = n.find(((e) => e.startsWith(window.location.origin) && e.endsWith('.json'))), i = n.find(((e) => e !== r)), r && i) { e.next = 5; break; } return e.abrupt('return'); case 5: return e.next = 7, u(r, i); case 7: s = e.sent, t.replaceChildren(s), s.addEventListener('submit', ((e) => { if (e.preventDefault(), s.checkValidity())f(s); else { const t = s.querySelector(':invalid:not(fieldset)'); t && (t.focus(), t.scrollIntoView({ behavior: 'smooth' })); } })); case 10: case 'end': return e.stop(); } }), e); })))).apply(this, arguments); }
    },
    273: (e, t, n) => {
      n.r(t), n.d(t, { default: () => c }); const r = n(658); function i(e) { return i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, i(e); } function o() {
        o = function () { return t; }; let e; var t = {}; const n = Object.prototype; const r = n.hasOwnProperty; const a = Object.defineProperty || function (e, t, n) { e[t] = n.value; }; const s = typeof Symbol === 'function' ? Symbol : {}; const l = s.iterator || '@@iterator'; const c = s.asyncIterator || '@@asyncIterator'; const u = s.toStringTag || '@@toStringTag'; function d(e, t, n) {
          return Object.defineProperty(e, t, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
          }), e[t];
        } try { d({}, ''); } catch (e) { d = function (e, t, n) { return e[t] = n; }; } function p(e, t, n, r) { const i = t && t.prototype instanceof b ? t : b; const o = Object.create(i.prototype); const s = new P(r || []); return a(o, '_invoke', { value: k(e, n, s) }), o; } function f(e, t, n) { try { return { type: 'normal', arg: e.call(t, n) }; } catch (e) { return { type: 'throw', arg: e }; } }t.wrap = p; const h = 'suspendedStart'; const m = 'suspendedYield'; const v = 'executing'; const g = 'completed'; const y = {}; function b() {} function w() {} function S() {} let x = {}; d(x, l, (function () { return this; })); const E = Object.getPrototypeOf; const T = E && E(E(I([]))); T && T !== n && r.call(T, l) && (x = T); const _ = S.prototype = b.prototype = Object.create(x); function C(e) { ['next', 'throw', 'return'].forEach(((t) => { d(e, t, (function (e) { return this._invoke(t, e); })); })); } function L(e, t) { function n(o, a, s, l) { const c = f(e[o], e, a); if (c.type !== 'throw') { const u = c.arg; const d = u.value; return d && i(d) == 'object' && r.call(d, '__await') ? t.resolve(d.__await).then(((e) => { n('next', e, s, l); }), ((e) => { n('throw', e, s, l); })) : t.resolve(d).then(((e) => { u.value = e, s(u); }), ((e) => n('throw', e, s, l))); }l(c.arg); } let o; a(this, '_invoke', { value(e, r) { function i() { return new t(((t, i) => { n(e, r, t, i); })); } return o = o ? o.then(i, i) : i(); } }); } function k(t, n, r) { let i = h; return function (o, a) { if (i === v) throw Error('Generator is already running'); if (i === g) { if (o === 'throw') throw a; return { value: e, done: !0 }; } for (r.method = o, r.arg = a; ;) { const s = r.delegate; if (s) { const l = M(s, r); if (l) { if (l === y) continue; return l; } } if (r.method === 'next')r.sent = r._sent = r.arg; else if (r.method === 'throw') { if (i === h) throw i = g, r.arg; r.dispatchException(r.arg); } else r.method === 'return' && r.abrupt('return', r.arg); i = v; const c = f(t, n, r); if (c.type === 'normal') { if (i = r.done ? g : m, c.arg === y) continue; return { value: c.arg, done: r.done }; }c.type === 'throw' && (i = g, r.method = 'throw', r.arg = c.arg); } }; } function M(t, n) { const r = n.method; const i = t.iterator[r]; if (i === e) return n.delegate = null, r === 'throw' && t.iterator.return && (n.method = 'return', n.arg = e, M(t, n), n.method === 'throw') || r !== 'return' && (n.method = 'throw', n.arg = new TypeError(`The iterator does not provide a '${r}' method`)), y; const o = f(i, t.iterator, n.arg); if (o.type === 'throw') return n.method = 'throw', n.arg = o.arg, n.delegate = null, y; const a = o.arg; return a ? a.done ? (n[t.resultName] = a.value, n.next = t.nextLoc, n.method !== 'return' && (n.method = 'next', n.arg = e), n.delegate = null, y) : a : (n.method = 'throw', n.arg = new TypeError('iterator result is not an object'), n.delegate = null, y); } function A(e) { const t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t); } function O(e) { const t = e.completion || {}; t.type = 'normal', delete t.arg, e.completion = t; } function P(e) { this.tryEntries = [{ tryLoc: 'root' }], e.forEach(A, this), this.reset(!0); } function I(t) { if (t || t === '') { const n = t[l]; if (n) return n.call(t); if (typeof t.next === 'function') return t; if (!isNaN(t.length)) { let o = -1; const a = function n() { for (;++o < t.length;) if (r.call(t, o)) return n.value = t[o], n.done = !1, n; return n.value = e, n.done = !0, n; }; return a.next = a; } } throw new TypeError(`${i(t)} is not iterable`); } return w.prototype = S, a(_, 'constructor', { value: S, configurable: !0 }), a(S, 'constructor', { value: w, configurable: !0 }), w.displayName = d(S, u, 'GeneratorFunction'), t.isGeneratorFunction = function (e) { const t = typeof e === 'function' && e.constructor; return !!t && (t === w || (t.displayName || t.name) === 'GeneratorFunction'); }, t.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, S) : (e.__proto__ = S, d(e, u, 'GeneratorFunction')), e.prototype = Object.create(_), e; }, t.awrap = function (e) { return { __await: e }; }, C(L.prototype), d(L.prototype, c, (function () { return this; })), t.AsyncIterator = L, t.async = function (e, n, r, i, o) { void 0 === o && (o = Promise); const a = new L(p(e, n, r, i), o); return t.isGeneratorFunction(n) ? a : a.next().then(((e) => (e.done ? e.value : a.next()))); }, C(_), d(_, u, 'Generator'), d(_, l, (function () { return this; })), d(_, 'toString', (() => '[object Generator]')), t.keys = function (e) { const t = Object(e); const n = []; for (const r in t)n.push(r); return n.reverse(), function e() { for (;n.length;) { const r = n.pop(); if (r in t) return e.value = r, e.done = !1, e; } return e.done = !0, e; }; }, t.values = I, P.prototype = {
          constructor: P, reset(t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = 'next', this.arg = e, this.tryEntries.forEach(O), !t) for (const n in this)n.charAt(0) === 't' && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e); }, stop() { this.done = !0; const e = this.tryEntries[0].completion; if (e.type === 'throw') throw e.arg; return this.rval; }, dispatchException(t) { if (this.done) throw t; const n = this; function i(r, i) { return s.type = 'throw', s.arg = t, n.next = r, i && (n.method = 'next', n.arg = e), !!i; } for (let o = this.tryEntries.length - 1; o >= 0; --o) { const a = this.tryEntries[o]; var s = a.completion; if (a.tryLoc === 'root') return i('end'); if (a.tryLoc <= this.prev) { const l = r.call(a, 'catchLoc'); const c = r.call(a, 'finallyLoc'); if (l && c) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } else if (l) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); } else { if (!c) throw Error('try statement without catch or finally'); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } } } }, abrupt(e, t) { for (let n = this.tryEntries.length - 1; n >= 0; --n) { const i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, 'finallyLoc') && this.prev < i.finallyLoc) { var o = i; break; } }o && (e === 'break' || e === 'continue') && o.tryLoc <= t && t <= o.finallyLoc && (o = null); const a = o ? o.completion : {}; return a.type = e, a.arg = t, o ? (this.method = 'next', this.next = o.finallyLoc, y) : this.complete(a); }, complete(e, t) { if (e.type === 'throw') throw e.arg; return e.type === 'break' || e.type === 'continue' ? this.next = e.arg : e.type === 'return' ? (this.rval = this.arg = e.arg, this.method = 'return', this.next = 'end') : e.type === 'normal' && t && (this.next = t), y; }, finish(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), O(n), y; } }, catch(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.tryLoc === e) { const r = n.completion; if (r.type === 'throw') { var i = r.arg; O(n); } return i; } } throw Error('illegal catch attempt'); }, delegateYield(t, n, r) { return this.delegate = { iterator: I(t), resultName: n, nextLoc: r }, this.method === 'next' && (this.arg = e), y; },
        }, t;
      } function a(e) { return (function (e) { if (Array.isArray(e)) return s(e); }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(e)) || (function (e, t) { if (e) { if (typeof e === 'string') return s(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? s(e, t) : void 0; } }(e)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function s(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; } function l(e, t, n, r, i, o, a) { try { var s = e[o](a); var l = s.value; } catch (e) { return void n(e); }s.done ? t(l) : Promise.resolve(l).then(r, i); } function c(e) { return u.apply(this, arguments); } function u() { let e; return e = o().mark((function e(t) { let n; let i; let s; let l; let c; return o().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: return n = t.querySelector('a'), i = n ? n.getAttribute('href') : t.textContent.trim(), e.next = 4, (0, r.LL)(i); case 4: (s = e.sent) && (l = s.querySelector(':scope .section')) && ((c = t.classList).add.apply(c, a(l.classList)), t.classList.remove('section'), t.replaceChildren.apply(t, a(l.childNodes))); case 6: case 'end': return e.stop(); } }), e); })), u = function () { const t = this; const n = arguments; return new Promise(((r, i) => { const o = e.apply(t, n); function a(e) { l(o, r, i, a, s, 'next', e); } function s(e) { l(o, r, i, a, s, 'throw', e); }a(void 0); })); }, u.apply(this, arguments); }
    },
    724: (e, t, n) => {
      n.r(t), n.d(t, { default: () => h, isDesktop: () => c, toggleMenu: () => f }); const r = n(927); const i = n(658); function o(e) { return o = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, o(e); } function a() {
        a = function () { return t; }; let e; var t = {}; const n = Object.prototype; const r = n.hasOwnProperty; const i = Object.defineProperty || function (e, t, n) { e[t] = n.value; }; const s = typeof Symbol === 'function' ? Symbol : {}; const l = s.iterator || '@@iterator'; const c = s.asyncIterator || '@@asyncIterator'; const u = s.toStringTag || '@@toStringTag'; function d(e, t, n) {
          return Object.defineProperty(e, t, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
          }), e[t];
        } try { d({}, ''); } catch (e) { d = function (e, t, n) { return e[t] = n; }; } function p(e, t, n, r) { const o = t && t.prototype instanceof b ? t : b; const a = Object.create(o.prototype); const s = new P(r || []); return i(a, '_invoke', { value: k(e, n, s) }), a; } function f(e, t, n) { try { return { type: 'normal', arg: e.call(t, n) }; } catch (e) { return { type: 'throw', arg: e }; } }t.wrap = p; const h = 'suspendedStart'; const m = 'suspendedYield'; const v = 'executing'; const g = 'completed'; const y = {}; function b() {} function w() {} function S() {} let x = {}; d(x, l, (function () { return this; })); const E = Object.getPrototypeOf; const T = E && E(E(I([]))); T && T !== n && r.call(T, l) && (x = T); const _ = S.prototype = b.prototype = Object.create(x); function C(e) { ['next', 'throw', 'return'].forEach(((t) => { d(e, t, (function (e) { return this._invoke(t, e); })); })); } function L(e, t) { function n(i, a, s, l) { const c = f(e[i], e, a); if (c.type !== 'throw') { const u = c.arg; const d = u.value; return d && o(d) == 'object' && r.call(d, '__await') ? t.resolve(d.__await).then(((e) => { n('next', e, s, l); }), ((e) => { n('throw', e, s, l); })) : t.resolve(d).then(((e) => { u.value = e, s(u); }), ((e) => n('throw', e, s, l))); }l(c.arg); } let a; i(this, '_invoke', { value(e, r) { function i() { return new t(((t, i) => { n(e, r, t, i); })); } return a = a ? a.then(i, i) : i(); } }); } function k(t, n, r) { let i = h; return function (o, a) { if (i === v) throw Error('Generator is already running'); if (i === g) { if (o === 'throw') throw a; return { value: e, done: !0 }; } for (r.method = o, r.arg = a; ;) { const s = r.delegate; if (s) { const l = M(s, r); if (l) { if (l === y) continue; return l; } } if (r.method === 'next')r.sent = r._sent = r.arg; else if (r.method === 'throw') { if (i === h) throw i = g, r.arg; r.dispatchException(r.arg); } else r.method === 'return' && r.abrupt('return', r.arg); i = v; const c = f(t, n, r); if (c.type === 'normal') { if (i = r.done ? g : m, c.arg === y) continue; return { value: c.arg, done: r.done }; }c.type === 'throw' && (i = g, r.method = 'throw', r.arg = c.arg); } }; } function M(t, n) { const r = n.method; const i = t.iterator[r]; if (i === e) return n.delegate = null, r === 'throw' && t.iterator.return && (n.method = 'return', n.arg = e, M(t, n), n.method === 'throw') || r !== 'return' && (n.method = 'throw', n.arg = new TypeError(`The iterator does not provide a '${r}' method`)), y; const o = f(i, t.iterator, n.arg); if (o.type === 'throw') return n.method = 'throw', n.arg = o.arg, n.delegate = null, y; const a = o.arg; return a ? a.done ? (n[t.resultName] = a.value, n.next = t.nextLoc, n.method !== 'return' && (n.method = 'next', n.arg = e), n.delegate = null, y) : a : (n.method = 'throw', n.arg = new TypeError('iterator result is not an object'), n.delegate = null, y); } function A(e) { const t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t); } function O(e) { const t = e.completion || {}; t.type = 'normal', delete t.arg, e.completion = t; } function P(e) { this.tryEntries = [{ tryLoc: 'root' }], e.forEach(A, this), this.reset(!0); } function I(t) { if (t || t === '') { const n = t[l]; if (n) return n.call(t); if (typeof t.next === 'function') return t; if (!isNaN(t.length)) { let i = -1; const a = function n() { for (;++i < t.length;) if (r.call(t, i)) return n.value = t[i], n.done = !1, n; return n.value = e, n.done = !0, n; }; return a.next = a; } } throw new TypeError(`${o(t)} is not iterable`); } return w.prototype = S, i(_, 'constructor', { value: S, configurable: !0 }), i(S, 'constructor', { value: w, configurable: !0 }), w.displayName = d(S, u, 'GeneratorFunction'), t.isGeneratorFunction = function (e) { const t = typeof e === 'function' && e.constructor; return !!t && (t === w || (t.displayName || t.name) === 'GeneratorFunction'); }, t.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, S) : (e.__proto__ = S, d(e, u, 'GeneratorFunction')), e.prototype = Object.create(_), e; }, t.awrap = function (e) { return { __await: e }; }, C(L.prototype), d(L.prototype, c, (function () { return this; })), t.AsyncIterator = L, t.async = function (e, n, r, i, o) { void 0 === o && (o = Promise); const a = new L(p(e, n, r, i), o); return t.isGeneratorFunction(n) ? a : a.next().then(((e) => (e.done ? e.value : a.next()))); }, C(_), d(_, u, 'Generator'), d(_, l, (function () { return this; })), d(_, 'toString', (() => '[object Generator]')), t.keys = function (e) { const t = Object(e); const n = []; for (const r in t)n.push(r); return n.reverse(), function e() { for (;n.length;) { const r = n.pop(); if (r in t) return e.value = r, e.done = !1, e; } return e.done = !0, e; }; }, t.values = I, P.prototype = {
          constructor: P, reset(t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = 'next', this.arg = e, this.tryEntries.forEach(O), !t) for (const n in this)n.charAt(0) === 't' && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e); }, stop() { this.done = !0; const e = this.tryEntries[0].completion; if (e.type === 'throw') throw e.arg; return this.rval; }, dispatchException(t) { if (this.done) throw t; const n = this; function i(r, i) { return s.type = 'throw', s.arg = t, n.next = r, i && (n.method = 'next', n.arg = e), !!i; } for (let o = this.tryEntries.length - 1; o >= 0; --o) { const a = this.tryEntries[o]; var s = a.completion; if (a.tryLoc === 'root') return i('end'); if (a.tryLoc <= this.prev) { const l = r.call(a, 'catchLoc'); const c = r.call(a, 'finallyLoc'); if (l && c) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } else if (l) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); } else { if (!c) throw Error('try statement without catch or finally'); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } } } }, abrupt(e, t) { for (let n = this.tryEntries.length - 1; n >= 0; --n) { const i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, 'finallyLoc') && this.prev < i.finallyLoc) { var o = i; break; } }o && (e === 'break' || e === 'continue') && o.tryLoc <= t && t <= o.finallyLoc && (o = null); const a = o ? o.completion : {}; return a.type = e, a.arg = t, o ? (this.method = 'next', this.next = o.finallyLoc, y) : this.complete(a); }, complete(e, t) { if (e.type === 'throw') throw e.arg; return e.type === 'break' || e.type === 'continue' ? this.next = e.arg : e.type === 'return' ? (this.rval = this.arg = e.arg, this.method = 'return', this.next = 'end') : e.type === 'normal' && t && (this.next = t), y; }, finish(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), O(n), y; } }, catch(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.tryLoc === e) { const r = n.completion; if (r.type === 'throw') { var i = r.arg; O(n); } return i; } } throw Error('illegal catch attempt'); }, delegateYield(t, n, r) { return this.delegate = { iterator: I(t), resultName: n, nextLoc: r }, this.method === 'next' && (this.arg = e), y; },
        }, t;
      } function s(e, t, n, r, i, o, a) { try { var s = e[o](a); var l = s.value; } catch (e) { return void n(e); }s.done ? t(l) : Promise.resolve(l).then(r, i); } function l(e) { return function () { const t = this; const n = arguments; return new Promise(((r, i) => { const o = e.apply(t, n); function a(e) { s(o, r, i, a, l, 'next', e); } function l(e) { s(o, r, i, a, l, 'throw', e); }a(void 0); })); }; } var c = window.matchMedia('(min-width: 900px)'); function u(e) { const t = document.activeElement; if (t.className === 'nav-drop' && (e.code === 'Enter' || e.code === 'Space')) { const n = t.getAttribute('aria-expanded') === 'true'; p(t.closest('.nav-sections')), t.setAttribute('aria-expanded', n ? 'false' : 'true'); } } function d() { document.activeElement.addEventListener('keydown', u); } function p(e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; e.querySelectorAll('.nav-sections .default-content-wrapper > ul > li').forEach(((e) => { e.setAttribute('aria-expanded', t); })); } function f(e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; const r = n !== null ? !n : e.getAttribute('aria-expanded') === 'true'; const i = e.querySelector('.nav-hamburger button'); document.body.style.overflowY = r || c.matches ? '' : 'hidden', e.setAttribute('aria-expanded', r ? 'false' : 'true'), p(t, r || c.matches ? 'false' : 'true'), i.setAttribute('aria-label', r ? 'Open navigation' : 'Close navigation'); const o = t.querySelectorAll('.nav-drop'); c.matches ? o.forEach(((e) => { e.hasAttribute('tabindex') || (e.setAttribute('tabindex', 0), e.addEventListener('focus', d)); })) : o.forEach(((e) => { e.removeAttribute('tabindex'), e.removeEventListener('focus', d); })); } function h(e) { return m.apply(this, arguments); } function m() { return (m = l(a().mark((function e(t) { let n; let o; let s; let u; let d; let h; let m; let v; let g; let y; return a().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: return n = (0, r.yb)('nav'), o = n ? new URL(n, window.location).pathname : '/nav', e.next = 4, (0, i.LL)(o); case 4: for (s = e.sent, t.textContent = '', (u = document.createElement('nav')).id = 'nav'; s.firstElementChild;)u.append(s.firstElementChild); ['head', 'brand', 'sections', 'tools'].forEach(((e, t) => { const n = u.children[t]; n && n.classList.add('nav-'.concat(e)); })), d = u.querySelector('.nav-brand'), (h = d.querySelector('.button')) && (h.className = '', h.closest('.button-container').className = ''), (m = u.querySelector('.nav-sections')) && m.querySelectorAll(':scope .default-content-wrapper > ul > li').forEach(((e) => { e.querySelector('ul') && e.classList.add('nav-drop'), e.addEventListener('click', (() => { if (c.matches) { const t = e.getAttribute('aria-expanded') === 'true'; p(m), e.setAttribute('aria-expanded', t ? 'false' : 'true'); } })); })), (v = document.createElement('div')).classList.add('nav-hamburger'), v.innerHTML = '<button type="button" aria-controls="nav" aria-label="Open navigation">\n      <span class="nav-hamburger-icon"></span>\n    </button>', v.addEventListener('click', l(a().mark((function e() { return a().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: f(u, m); case 1: case 'end': return e.stop(); } }), e); })))), u.prepend(v), u.setAttribute('aria-expanded', 'false'), f(u, m, c.matches), c.addEventListener('change', (() => f(u, m, c.matches))), (g = document.createElement('div')).className = 'nav-wrapper', g.append(u), t.append(g), t.querySelectorAll('.nav-sections .default-content-wrapper ul').forEach(((e) => { e.querySelectorAll('li').forEach(((e) => { let t; (t = e.querySelector('p')) === null || void 0 === t || t.setAttribute('aria-expanded', 'false'); const n = e.querySelector('ul'); n && e.addEventListener('click', ((e) => { const t = n.style.display === 'block'; n.style.display = t ? 'none' : 'block', e.target.setAttribute('aria-expanded', t ? 'false' : 'true'), e.stopImmediatePropagation(); })); })); })), (y = t.querySelector('.nav-sections .default-content-wrapper ul li img')).addEventListener('click', (() => { y.closest('body').style.overflow = 'auto', y.closest('nav').setAttribute('aria-expanded', 'false'); })); case 32: case 'end': return e.stop(); } }), e); })))).apply(this, arguments); }
    },
    202: () => {},
    816: (e, t, n) => {
      n.r(t), n.d(t, { createModal: () => d, openModal: () => f }); const r = n(927); const i = n(658); const o = n(724); function a(e) { return a = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, a(e); } function s() {
        s = function () { return t; }; let e; var t = {}; const n = Object.prototype; const r = n.hasOwnProperty; const i = Object.defineProperty || function (e, t, n) { e[t] = n.value; }; const o = typeof Symbol === 'function' ? Symbol : {}; const l = o.iterator || '@@iterator'; const c = o.asyncIterator || '@@asyncIterator'; const u = o.toStringTag || '@@toStringTag'; function d(e, t, n) {
          return Object.defineProperty(e, t, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
          }), e[t];
        } try { d({}, ''); } catch (e) { d = function (e, t, n) { return e[t] = n; }; } function p(e, t, n, r) { const o = t && t.prototype instanceof b ? t : b; const a = Object.create(o.prototype); const s = new P(r || []); return i(a, '_invoke', { value: k(e, n, s) }), a; } function f(e, t, n) { try { return { type: 'normal', arg: e.call(t, n) }; } catch (e) { return { type: 'throw', arg: e }; } }t.wrap = p; const h = 'suspendedStart'; const m = 'suspendedYield'; const v = 'executing'; const g = 'completed'; const y = {}; function b() {} function w() {} function S() {} let x = {}; d(x, l, (function () { return this; })); const E = Object.getPrototypeOf; const T = E && E(E(I([]))); T && T !== n && r.call(T, l) && (x = T); const _ = S.prototype = b.prototype = Object.create(x); function C(e) { ['next', 'throw', 'return'].forEach(((t) => { d(e, t, (function (e) { return this._invoke(t, e); })); })); } function L(e, t) { function n(i, o, s, l) { const c = f(e[i], e, o); if (c.type !== 'throw') { const u = c.arg; const d = u.value; return d && a(d) == 'object' && r.call(d, '__await') ? t.resolve(d.__await).then(((e) => { n('next', e, s, l); }), ((e) => { n('throw', e, s, l); })) : t.resolve(d).then(((e) => { u.value = e, s(u); }), ((e) => n('throw', e, s, l))); }l(c.arg); } let o; i(this, '_invoke', { value(e, r) { function i() { return new t(((t, i) => { n(e, r, t, i); })); } return o = o ? o.then(i, i) : i(); } }); } function k(t, n, r) { let i = h; return function (o, a) { if (i === v) throw Error('Generator is already running'); if (i === g) { if (o === 'throw') throw a; return { value: e, done: !0 }; } for (r.method = o, r.arg = a; ;) { const s = r.delegate; if (s) { const l = M(s, r); if (l) { if (l === y) continue; return l; } } if (r.method === 'next')r.sent = r._sent = r.arg; else if (r.method === 'throw') { if (i === h) throw i = g, r.arg; r.dispatchException(r.arg); } else r.method === 'return' && r.abrupt('return', r.arg); i = v; const c = f(t, n, r); if (c.type === 'normal') { if (i = r.done ? g : m, c.arg === y) continue; return { value: c.arg, done: r.done }; }c.type === 'throw' && (i = g, r.method = 'throw', r.arg = c.arg); } }; } function M(t, n) { const r = n.method; const i = t.iterator[r]; if (i === e) return n.delegate = null, r === 'throw' && t.iterator.return && (n.method = 'return', n.arg = e, M(t, n), n.method === 'throw') || r !== 'return' && (n.method = 'throw', n.arg = new TypeError(`The iterator does not provide a '${r}' method`)), y; const o = f(i, t.iterator, n.arg); if (o.type === 'throw') return n.method = 'throw', n.arg = o.arg, n.delegate = null, y; const a = o.arg; return a ? a.done ? (n[t.resultName] = a.value, n.next = t.nextLoc, n.method !== 'return' && (n.method = 'next', n.arg = e), n.delegate = null, y) : a : (n.method = 'throw', n.arg = new TypeError('iterator result is not an object'), n.delegate = null, y); } function A(e) { const t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t); } function O(e) { const t = e.completion || {}; t.type = 'normal', delete t.arg, e.completion = t; } function P(e) { this.tryEntries = [{ tryLoc: 'root' }], e.forEach(A, this), this.reset(!0); } function I(t) { if (t || t === '') { const n = t[l]; if (n) return n.call(t); if (typeof t.next === 'function') return t; if (!isNaN(t.length)) { let i = -1; const o = function n() { for (;++i < t.length;) if (r.call(t, i)) return n.value = t[i], n.done = !1, n; return n.value = e, n.done = !0, n; }; return o.next = o; } } throw new TypeError(`${a(t)} is not iterable`); } return w.prototype = S, i(_, 'constructor', { value: S, configurable: !0 }), i(S, 'constructor', { value: w, configurable: !0 }), w.displayName = d(S, u, 'GeneratorFunction'), t.isGeneratorFunction = function (e) { const t = typeof e === 'function' && e.constructor; return !!t && (t === w || (t.displayName || t.name) === 'GeneratorFunction'); }, t.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, S) : (e.__proto__ = S, d(e, u, 'GeneratorFunction')), e.prototype = Object.create(_), e; }, t.awrap = function (e) { return { __await: e }; }, C(L.prototype), d(L.prototype, c, (function () { return this; })), t.AsyncIterator = L, t.async = function (e, n, r, i, o) { void 0 === o && (o = Promise); const a = new L(p(e, n, r, i), o); return t.isGeneratorFunction(n) ? a : a.next().then(((e) => (e.done ? e.value : a.next()))); }, C(_), d(_, u, 'Generator'), d(_, l, (function () { return this; })), d(_, 'toString', (() => '[object Generator]')), t.keys = function (e) { const t = Object(e); const n = []; for (const r in t)n.push(r); return n.reverse(), function e() { for (;n.length;) { const r = n.pop(); if (r in t) return e.value = r, e.done = !1, e; } return e.done = !0, e; }; }, t.values = I, P.prototype = {
          constructor: P, reset(t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = 'next', this.arg = e, this.tryEntries.forEach(O), !t) for (const n in this)n.charAt(0) === 't' && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e); }, stop() { this.done = !0; const e = this.tryEntries[0].completion; if (e.type === 'throw') throw e.arg; return this.rval; }, dispatchException(t) { if (this.done) throw t; const n = this; function i(r, i) { return s.type = 'throw', s.arg = t, n.next = r, i && (n.method = 'next', n.arg = e), !!i; } for (let o = this.tryEntries.length - 1; o >= 0; --o) { const a = this.tryEntries[o]; var s = a.completion; if (a.tryLoc === 'root') return i('end'); if (a.tryLoc <= this.prev) { const l = r.call(a, 'catchLoc'); const c = r.call(a, 'finallyLoc'); if (l && c) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } else if (l) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); } else { if (!c) throw Error('try statement without catch or finally'); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } } } }, abrupt(e, t) { for (let n = this.tryEntries.length - 1; n >= 0; --n) { const i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, 'finallyLoc') && this.prev < i.finallyLoc) { var o = i; break; } }o && (e === 'break' || e === 'continue') && o.tryLoc <= t && t <= o.finallyLoc && (o = null); const a = o ? o.completion : {}; return a.type = e, a.arg = t, o ? (this.method = 'next', this.next = o.finallyLoc, y) : this.complete(a); }, complete(e, t) { if (e.type === 'throw') throw e.arg; return e.type === 'break' || e.type === 'continue' ? this.next = e.arg : e.type === 'return' ? (this.rval = this.arg = e.arg, this.method = 'return', this.next = 'end') : e.type === 'normal' && t && (this.next = t), y; }, finish(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), O(n), y; } }, catch(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.tryLoc === e) { const r = n.completion; if (r.type === 'throw') { var i = r.arg; O(n); } return i; } } throw Error('illegal catch attempt'); }, delegateYield(t, n, r) { return this.delegate = { iterator: I(t), resultName: n, nextLoc: r }, this.method === 'next' && (this.arg = e), y; },
        }, t;
      } function l(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; } function c(e, t, n, r, i, o, a) { try { var s = e[o](a); var l = s.value; } catch (e) { return void n(e); }s.done ? t(l) : Promise.resolve(l).then(r, i); } function u(e) { return function () { const t = this; const n = arguments; return new Promise(((r, i) => { const o = e.apply(t, n); function a(e) { c(o, r, i, a, s, 'next', e); } function s(e) { c(o, r, i, a, s, 'throw', e); }a(void 0); })); }; } function d(e) { return p.apply(this, arguments); } function p() { return (p = u(s().mark((function e(t) { let n; let i; let a; let c; return s().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: return e.next = 2, (0, r.y6)(''.concat(window.hlx.codeBasePath, '/blocks/modal/modal.css')); case 2: return n = document.createElement('dialog'), (i = document.createElement('div')).classList.add('modal-content'), i.append.apply(i, (function (e) { if (Array.isArray(e)) return l(e); }(s = t)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(s)) || (function (e, t) { if (e) { if (typeof e === 'string') return l(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? l(e, t) : void 0; } }(s)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }())), n.append(i), (a = document.createElement('button')).classList.add('close-button'), a.setAttribute('aria-label', 'Close'), a.type = 'button', a.innerHTML = '<span class="icon icon-close"></span>', a.addEventListener('click', (() => n.close())), n.prepend(a), c = (0, r.KG)('modal', ''), document.querySelector('main').append(c), (0, r.fg)(c), e.next = 19, (0, r.ez)(c); case 19: return n.addEventListener('click', ((e) => { const t = n.getBoundingClientRect(); const r = t.left; const i = t.right; const a = t.top; const s = t.bottom; const l = e.clientX; const c = e.clientY; if (l < r || l > i || c < a || c > s) { const u = document.querySelector('nav'); const d = u.querySelector('.nav-sections'); (0, o.toggleMenu)(u, d), n.close(); } })), n.addEventListener('close', (() => { document.body.classList.remove('modal-open'), c.remove(); })), c.innerHTML = '', c.append(n), e.abrupt('return', { block: c, showModal() { n.showModal(), setTimeout((() => { i.scrollTop = 0; }), 0), document.body.classList.add('modal-open'); } }); case 24: case 'end': return e.stop(); } let s; }), e); })))).apply(this, arguments); } function f(e) { return h.apply(this, arguments); } function h() { return (h = u(s().mark((function e(t) { let n; let r; return s().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: return n = t.startsWith('http') ? new URL(t, window.location).pathname : t, e.next = 3, (0, i.LL)(n); case 3: return r = e.sent, e.next = 6, d(r.childNodes); case 6: (0, e.sent.showModal)(); case 9: case 'end': return e.stop(); } }), e); })))).apply(this, arguments); }
    },
    266: () => {},
    966: () => {},
    602: (e, t, n) => {
      n.r(t), n.d(t, { default: () => l }); const r = n(927); function i(e) { return i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, i(e); } function o() {
        o = function () { return t; }; let e; var t = {}; const n = Object.prototype; const r = n.hasOwnProperty; const a = Object.defineProperty || function (e, t, n) { e[t] = n.value; }; const s = typeof Symbol === 'function' ? Symbol : {}; const l = s.iterator || '@@iterator'; const c = s.asyncIterator || '@@asyncIterator'; const u = s.toStringTag || '@@toStringTag'; function d(e, t, n) {
          return Object.defineProperty(e, t, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
          }), e[t];
        } try { d({}, ''); } catch (e) { d = function (e, t, n) { return e[t] = n; }; } function p(e, t, n, r) { const i = t && t.prototype instanceof b ? t : b; const o = Object.create(i.prototype); const s = new P(r || []); return a(o, '_invoke', { value: k(e, n, s) }), o; } function f(e, t, n) { try { return { type: 'normal', arg: e.call(t, n) }; } catch (e) { return { type: 'throw', arg: e }; } }t.wrap = p; const h = 'suspendedStart'; const m = 'suspendedYield'; const v = 'executing'; const g = 'completed'; const y = {}; function b() {} function w() {} function S() {} let x = {}; d(x, l, (function () { return this; })); const E = Object.getPrototypeOf; const T = E && E(E(I([]))); T && T !== n && r.call(T, l) && (x = T); const _ = S.prototype = b.prototype = Object.create(x); function C(e) { ['next', 'throw', 'return'].forEach(((t) => { d(e, t, (function (e) { return this._invoke(t, e); })); })); } function L(e, t) { function n(o, a, s, l) { const c = f(e[o], e, a); if (c.type !== 'throw') { const u = c.arg; const d = u.value; return d && i(d) == 'object' && r.call(d, '__await') ? t.resolve(d.__await).then(((e) => { n('next', e, s, l); }), ((e) => { n('throw', e, s, l); })) : t.resolve(d).then(((e) => { u.value = e, s(u); }), ((e) => n('throw', e, s, l))); }l(c.arg); } let o; a(this, '_invoke', { value(e, r) { function i() { return new t(((t, i) => { n(e, r, t, i); })); } return o = o ? o.then(i, i) : i(); } }); } function k(t, n, r) { let i = h; return function (o, a) { if (i === v) throw Error('Generator is already running'); if (i === g) { if (o === 'throw') throw a; return { value: e, done: !0 }; } for (r.method = o, r.arg = a; ;) { const s = r.delegate; if (s) { const l = M(s, r); if (l) { if (l === y) continue; return l; } } if (r.method === 'next')r.sent = r._sent = r.arg; else if (r.method === 'throw') { if (i === h) throw i = g, r.arg; r.dispatchException(r.arg); } else r.method === 'return' && r.abrupt('return', r.arg); i = v; const c = f(t, n, r); if (c.type === 'normal') { if (i = r.done ? g : m, c.arg === y) continue; return { value: c.arg, done: r.done }; }c.type === 'throw' && (i = g, r.method = 'throw', r.arg = c.arg); } }; } function M(t, n) { const r = n.method; const i = t.iterator[r]; if (i === e) return n.delegate = null, r === 'throw' && t.iterator.return && (n.method = 'return', n.arg = e, M(t, n), n.method === 'throw') || r !== 'return' && (n.method = 'throw', n.arg = new TypeError(`The iterator does not provide a '${r}' method`)), y; const o = f(i, t.iterator, n.arg); if (o.type === 'throw') return n.method = 'throw', n.arg = o.arg, n.delegate = null, y; const a = o.arg; return a ? a.done ? (n[t.resultName] = a.value, n.next = t.nextLoc, n.method !== 'return' && (n.method = 'next', n.arg = e), n.delegate = null, y) : a : (n.method = 'throw', n.arg = new TypeError('iterator result is not an object'), n.delegate = null, y); } function A(e) { const t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t); } function O(e) { const t = e.completion || {}; t.type = 'normal', delete t.arg, e.completion = t; } function P(e) { this.tryEntries = [{ tryLoc: 'root' }], e.forEach(A, this), this.reset(!0); } function I(t) { if (t || t === '') { const n = t[l]; if (n) return n.call(t); if (typeof t.next === 'function') return t; if (!isNaN(t.length)) { let o = -1; const a = function n() { for (;++o < t.length;) if (r.call(t, o)) return n.value = t[o], n.done = !1, n; return n.value = e, n.done = !0, n; }; return a.next = a; } } throw new TypeError(`${i(t)} is not iterable`); } return w.prototype = S, a(_, 'constructor', { value: S, configurable: !0 }), a(S, 'constructor', { value: w, configurable: !0 }), w.displayName = d(S, u, 'GeneratorFunction'), t.isGeneratorFunction = function (e) { const t = typeof e === 'function' && e.constructor; return !!t && (t === w || (t.displayName || t.name) === 'GeneratorFunction'); }, t.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, S) : (e.__proto__ = S, d(e, u, 'GeneratorFunction')), e.prototype = Object.create(_), e; }, t.awrap = function (e) { return { __await: e }; }, C(L.prototype), d(L.prototype, c, (function () { return this; })), t.AsyncIterator = L, t.async = function (e, n, r, i, o) { void 0 === o && (o = Promise); const a = new L(p(e, n, r, i), o); return t.isGeneratorFunction(n) ? a : a.next().then(((e) => (e.done ? e.value : a.next()))); }, C(_), d(_, u, 'Generator'), d(_, l, (function () { return this; })), d(_, 'toString', (() => '[object Generator]')), t.keys = function (e) { const t = Object(e); const n = []; for (const r in t)n.push(r); return n.reverse(), function e() { for (;n.length;) { const r = n.pop(); if (r in t) return e.value = r, e.done = !1, e; } return e.done = !0, e; }; }, t.values = I, P.prototype = {
          constructor: P, reset(t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = 'next', this.arg = e, this.tryEntries.forEach(O), !t) for (const n in this)n.charAt(0) === 't' && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e); }, stop() { this.done = !0; const e = this.tryEntries[0].completion; if (e.type === 'throw') throw e.arg; return this.rval; }, dispatchException(t) { if (this.done) throw t; const n = this; function i(r, i) { return s.type = 'throw', s.arg = t, n.next = r, i && (n.method = 'next', n.arg = e), !!i; } for (let o = this.tryEntries.length - 1; o >= 0; --o) { const a = this.tryEntries[o]; var s = a.completion; if (a.tryLoc === 'root') return i('end'); if (a.tryLoc <= this.prev) { const l = r.call(a, 'catchLoc'); const c = r.call(a, 'finallyLoc'); if (l && c) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } else if (l) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); } else { if (!c) throw Error('try statement without catch or finally'); if (this.prev < a.finallyLoc) return i(a.finallyLoc); } } } }, abrupt(e, t) { for (let n = this.tryEntries.length - 1; n >= 0; --n) { const i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, 'finallyLoc') && this.prev < i.finallyLoc) { var o = i; break; } }o && (e === 'break' || e === 'continue') && o.tryLoc <= t && t <= o.finallyLoc && (o = null); const a = o ? o.completion : {}; return a.type = e, a.arg = t, o ? (this.method = 'next', this.next = o.finallyLoc, y) : this.complete(a); }, complete(e, t) { if (e.type === 'throw') throw e.arg; return e.type === 'break' || e.type === 'continue' ? this.next = e.arg : e.type === 'return' ? (this.rval = this.arg = e.arg, this.method = 'return', this.next = 'end') : e.type === 'normal' && t && (this.next = t), y; }, finish(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), O(n), y; } }, catch(e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.tryLoc === e) { const r = n.completion; if (r.type === 'throw') { var i = r.arg; O(n); } return i; } } throw Error('illegal catch attempt'); }, delegateYield(t, n, r) { return this.delegate = { iterator: I(t), resultName: n, nextLoc: r }, this.method === 'next' && (this.arg = e), y; },
        }, t;
      } function a(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = Array(t); n < t; n++)r[n] = e[n]; return r; } function s(e, t, n, r, i, o, a) { try { var s = e[o](a); var l = s.value; } catch (e) { return void n(e); }s.done ? t(l) : Promise.resolve(l).then(r, i); } function l(e) { return c.apply(this, arguments); } function c() { let e; return e = o().mark((function e(t) { let n; return o().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: (n = document.createElement('div')).className = 'tabs-list', n.setAttribute('role', 'tablist'), (i = t.children, (function (e) { if (Array.isArray(e)) return a(e); }(i)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(i)) || (function (e, t) { if (e) { if (typeof e === 'string') return a(e, t); let n = {}.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0; } }(i)) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }())).map(((e) => e.firstElementChild)).forEach(((e, i) => { const o = (0, r.L4)(e.textContent); const a = t.children[i]; a.className = 'tabs-panel', a.id = 'tabpanel-'.concat(o), a.setAttribute('aria-hidden', !!i), a.setAttribute('aria-labelledby', 'tab-'.concat(o)), a.setAttribute('role', 'tabpanel'); const s = document.createElement('button'); s.className = 'tabs-tab', s.id = 'tab-'.concat(o), s.innerHTML = e.innerHTML, s.setAttribute('aria-controls', 'tabpanel-'.concat(o)), s.setAttribute('aria-selected', !i), s.setAttribute('role', 'tab'), s.setAttribute('type', 'button'), i === 0 && s.classList.add('active-tab'), s.addEventListener('click', (() => { t.querySelectorAll('[role=tabpanel]').forEach(((e) => { e.setAttribute('aria-hidden', !0); })), n.querySelectorAll('button').forEach(((e) => { e.setAttribute('aria-selected', !1), e.classList.remove('active-tab'); })), a.setAttribute('aria-hidden', !1), s.setAttribute('aria-selected', !0), s.classList.add('active-tab'); })), n.append(s), e.remove(); })), t.prepend(n); case 6: case 'end': return e.stop(); } let i; }), e); })), c = function () { const t = this; const n = arguments; return new Promise(((r, i) => { const o = e.apply(t, n); function a(e) { s(o, r, i, a, l, 'next', e); } function l(e) { s(o, r, i, a, l, 'throw', e); }a(void 0); })); }, c.apply(this, arguments); }
    },
    38: () => {},
    596: (e, t, n) => {
      n.r(t), n.d(t, { default: () => i }); const r = n(640); function i(e) { const t = Array.from(e.children, ((e) => e.firstElementChild))[1]; (0, r.default)(t); }
    },
    716: (e, t, n) => {
      function r(e) { let t; const n = e.parentElement.closest('.section'); const r = Array.from(n.children); let i = !1; const o = document.createElement('div'); o.classList.add('wrapper-creation-container'), r.forEach(((e, n) => { t + 1 === n || i ? (i = !0, o.append(e)) : e.classList.contains('wrappercreation-wrapper') && (t = n); })), e.innerHTML = '', e.appendChild(o); }n.r(t), n.d(t, { default: () => r });
    },
    262: (e, t) => {
      t.A = (e, t) => { const n = e.__vccOpts || e; for (const [e, r] of t)n[e] = r; return n; };
    },
    425: (e, t, n) => {
      n.d(t, {
        FK: () => ca, Ef: () => oc, CE: () => Sa, Lk: () => ka, uX: () => ma, pI: () => wi, v_: () => le, QW: () => Kt,
      }); const r = {}; function i(e) { const t = Object.create(null); for (const n of e.split(','))t[n] = 1; return (e) => e in t; }n.r(r), n.d(r, {
        BaseTransition: () => vr, BaseTransitionPropsValidators: () => fr, Comment: () => da, DeprecationTypes: () => Ss, EffectScope: () => fe, ErrorCodes: () => fn, ErrorTypeStrings: () => ms, Fragment: () => ca, KeepAlive: () => $r, ReactiveEffect: () => ye, Static: () => pa, Suspense: () => ra, Teleport: () => ar, Text: () => ua, TrackOpTypes: () => nn, Transition: () => Is, TransitionGroup: () => kl, TriggerOpTypes: () => rn, VueElement: () => wl, assertNumber: () => pn, callWithAsyncErrorHandling: () => mn, callWithErrorHandling: () => hn, camelize: () => I, capitalize: () => R, cloneVNode: () => Oa, compatUtils: () => ws, computed: () => ls, createApp: () => oc, createBlock: () => xa, createCommentVNode: () => Na, createElementBlock: () => Sa, createElementVNode: () => ka, createHydrationRenderer: () => ko, createPropsRestProxy: () => Hi, createRenderer: () => Lo, createSSRApp: () => ac, createSlots: () => Si, createStaticVNode: () => Ia, createTextVNode: () => Pa, createVNode: () => Ma, customRef: () => Xt, defineAsyncComponent: () => Hr, defineComponent: () => Er, defineCustomElement: () => gl, defineEmits: () => Oi, defineExpose: () => Pi, defineModel: () => Di, defineOptions: () => Ii, defineProps: () => Ai, defineSSRCustomElement: () => yl, defineSlots: () => Ni, devtools: () => vs, effect: () => Oe, effectScope: () => he, getCurrentInstance: () => Ga, getCurrentScope: () => me, getCurrentWatcher: () => ln, getTransitionRawChildren: () => xr, guardReactiveProps: () => Aa, h: () => cs, handleError: () => vn, hasInjectionContext: () => lo, hydrate: () => ic, hydrateOnIdle: () => Vr, hydrateOnInteraction: () => Br, hydrateOnMediaQuery: () => zr, hydrateOnVisible: () => Fr, initCustomFormatter: () => us, initDirectivesForSSR: () => uc, inject: () => so, isMemoSame: () => ps, isProxy: () => It, isReactive: () => At, isReadonly: () => Ot, isRef: () => Vt, isRuntimeOnly: () => ns, isShallow: () => Pt, isVNode: () => Ea, markRaw: () => Dt, mergeDefaults: () => Bi, mergeModels: () => qi, mergeProps: () => Va, nextTick: () => Tn, normalizeClass: () => J, normalizeProps: () => Q, normalizeStyle: () => $, onActivated: () => Yr, onBeforeMount: () => ni, onBeforeUnmount: () => ai, onBeforeUpdate: () => ii, onDeactivated: () => Xr, onErrorCaptured: () => di, onMounted: () => ri, onRenderTracked: () => ui, onRenderTriggered: () => ci, onScopeDispose: () => ve, onServerPrefetch: () => li, onUnmounted: () => si, onUpdated: () => oi, onWatcherCleanup: () => cn, openBlock: () => ma, popScopeId: () => $n, provide: () => ao, proxyRefs: () => Wt, pushScopeId: () => Un, queuePostFlushCb: () => Ln, reactive: () => _t, readonly: () => Lt, ref: () => Ft, registerRuntimeCompiler: () => ts, render: () => rc, renderList: () => wi, renderSlot: () => xi, resolveComponent: () => hi, resolveDirective: () => gi, resolveDynamicComponent: () => vi, resolveFilter: () => bs, resolveTransitionHooks: () => yr, setBlockTracking: () => ba, setDevtoolsHook: () => gs, setTransitionHooks: () => Sr, shallowReactive: () => Ct, shallowReadonly: () => kt, shallowRef: () => zt, ssrContextKey: () => Ro, ssrUtils: () => ys, stop: () => Pe, toDisplayString: () => le, toHandlerKey: () => j, toHandlers: () => Ti, toRaw: () => Nt, toRef: () => Zt, toRefs: () => Kt, toValue: () => Ut, transformVNodeArgs: () => _a, triggerRef: () => Ht, unref: () => Gt, useAttrs: () => Vi, useCssModule: () => El, useCssVars: () => Qs, useHost: () => Sl, useId: () => Tr, useModel: () => Uo, useSSRContext: () => jo, useShadowRoot: () => xl, useSlots: () => ji, useTemplateRef: () => Cr, useTransitionState: () => dr, vModelCheckbox: () => jl, vModelDynamic: () => Gl, vModelRadio: () => Fl, vModelSelect: () => zl, vModelText: () => Rl, vShow: () => Xs, version: () => fs, warn: () => hs, watch: () => Bo, watchEffect: () => Vo, watchPostEffect: () => Fo, watchSyncEffect: () => zo, withAsyncContext: () => Gi, withCtx: () => Yn, withDefaults: () => Ri, withDirectives: () => Xn, withKeys: () => Jl, withMemo: () => ds, withModifiers: () => Xl, withScopeId: () => Wn,
      }); const o = {}; const a = []; const s = () => {}; const l = () => !1; const c = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97); const u = (e) => e.startsWith('onUpdate:'); const d = Object.assign; const p = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1); }; const f = Object.prototype.hasOwnProperty; const h = (e, t) => f.call(e, t); const m = Array.isArray; const v = (e) => _(e) === '[object Map]'; const g = (e) => _(e) === '[object Set]'; const y = (e) => _(e) === '[object Date]'; const b = (e) => typeof e === 'function'; const w = (e) => typeof e === 'string'; const S = (e) => typeof e === 'symbol'; const x = (e) => e !== null && typeof e === 'object'; const E = (e) => (x(e) || b(e)) && b(e.then) && b(e.catch); const T = Object.prototype.toString; const _ = (e) => T.call(e); const C = (e) => _(e).slice(8, -1); const L = (e) => _(e) === '[object Object]'; const k = (e) => w(e) && e !== 'NaN' && e[0] !== '-' && `${parseInt(e, 10)}` === e; const M = i(',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'); const A = i('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'); const O = (e) => { const t = Object.create(null); return (n) => t[n] || (t[n] = e(n)); }; const P = /-(\w)/g; const I = O(((e) => e.replace(P, ((e, t) => (t ? t.toUpperCase() : ''))))); const N = /\B([A-Z])/g; const D = O(((e) => e.replace(N, '-$1').toLowerCase())); const R = O(((e) => e.charAt(0).toUpperCase() + e.slice(1))); const j = O(((e) => (e ? `on${R(e)}` : ''))); const V = (e, t) => !Object.is(e, t); const F = (e, ...t) => { for (let n = 0; n < e.length; n++)e[n](...t); }; const z = (e, t, n, r = !1) => {
        Object.defineProperty(e, t, {
          configurable: !0, enumerable: !1, writable: r, value: n,
        });
      }; const B = (e) => { const t = parseFloat(e); return isNaN(t) ? e : t; }; const q = (e) => { const t = w(e) ? Number(e) : NaN; return isNaN(t) ? e : t; }; let H; const G = () => H || (H = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : void 0 !== n.g ? n.g : {}); const U = i('Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol'); function $(e) { if (m(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n]; const i = w(r) ? K(r) : $(r); if (i) for (const e in i)t[e] = i[e]; } return t; } if (w(e) || x(e)) return e; } const W = /;(?![^(]*\))/g; const Y = /:([^]+)/; const X = /\/\*[^]*?\*\//g; function K(e) { const t = {}; return e.replace(X, '').split(W).forEach(((e) => { if (e) { const n = e.split(Y); n.length > 1 && (t[n[0].trim()] = n[1].trim()); } })), t; } function J(e) { let t = ''; if (w(e))t = e; else if (m(e)) for (let n = 0; n < e.length; n++) { const r = J(e[n]); r && (t += `${r} `); } else if (x(e)) for (const n in e)e[n] && (t += `${n} `); return t.trim(); } function Q(e) { if (!e) return null; const { class: t, style: n } = e; return t && !w(t) && (e.class = J(t)), n && (e.style = $(n)), e; } const Z = i('html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot'); const ee = i('svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view'); const te = i('annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics'); const ne = i('area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'); const re = i('itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly'); function ie(e) { return !!e || e === ''; } function oe(e, t) { if (e === t) return !0; let n = y(e); let r = y(t); if (n || r) return !(!n || !r) && e.getTime() === t.getTime(); if (n = S(e), r = S(t), n || r) return e === t; if (n = m(e), r = m(t), n || r) return !(!n || !r) && (function (e, t) { if (e.length !== t.length) return !1; let n = !0; for (let r = 0; n && r < e.length; r++)n = oe(e[r], t[r]); return n; }(e, t)); if (n = x(e), r = x(t), n || r) { if (!n || !r) return !1; if (Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) { const r = e.hasOwnProperty(n); const i = t.hasOwnProperty(n); if (r && !i || !r && i || !oe(e[n], t[n])) return !1; } } return String(e) === String(t); } function ae(e, t) { return e.findIndex(((e) => oe(e, t))); } const se = (e) => !(!e || !0 !== e.__v_isRef); const le = (e) => (w(e) ? e : e == null ? '' : m(e) || x(e) && (e.toString === T || !b(e.toString)) ? se(e) ? le(e.value) : JSON.stringify(e, ce, 2) : String(e)); const ce = (e, t) => (se(t) ? ce(e, t.value) : v(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce(((e, [t, n], r) => (e[`${ue(t, r)} =>`] = n, e)), {}) } : g(t) ? { [`Set(${t.size})`]: [...t.values()].map(((e) => ue(e))) } : S(t) ? ue(t) : !x(t) || m(t) || L(t) ? t : String(t)); const ue = (e, t = '') => { let n; return S(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e; }; let de; let pe; class fe {
        constructor(e = !1) { this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = de, !e && de && (this.index = (de.scopes || (de.scopes = [])).push(this) - 1); }

        get active() { return this._active; }

        pause() { if (this._active) { let e; let t; if (this._isPaused = !0, this.scopes) for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].pause(); for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].pause(); } }

        resume() { if (this._active && this._isPaused) { let e; let t; if (this._isPaused = !1, this.scopes) for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].resume(); for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].resume(); } }

        run(e) { if (this._active) { const t = de; try { return de = this, e(); } finally { de = t; } } }

        on() { de = this; }

        off() { de = this.parent; }

        stop(e) { if (this._active) { let t; let n; for (this._active = !1, t = 0, n = this.effects.length; t < n; t++) this.effects[t].stop(); for (this.effects.length = 0, t = 0, n = this.cleanups.length; t < n; t++) this.cleanups[t](); if (this.cleanups.length = 0, this.scopes) { for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].stop(!0); this.scopes.length = 0; } if (!this.detached && this.parent && !e) { const e = this.parent.scopes.pop(); e && e !== this && (this.parent.scopes[this.index] = e, e.index = this.index); } this.parent = void 0; } }
      } function he(e) { return new fe(e); } function me() { return de; } function ve(e, t = !1) { de && de.cleanups.push(e); } const ge = new WeakSet(); class ye {
        constructor(e) { this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, de && de.active && de.effects.push(this); }

        pause() { this.flags |= 64; }

        resume() { 64 & this.flags && (this.flags &= -65, ge.has(this) && (ge.delete(this), this.trigger())); }

        notify() { 2 & this.flags && !(32 & this.flags) || 8 & this.flags || xe(this); }

        run() { if (!(1 & this.flags)) return this.fn(); this.flags |= 2, je(this), _e(this); const e = pe; const t = Ie; pe = this, Ie = !0; try { return this.fn(); } finally { Ce(this), pe = e, Ie = t, this.flags &= -3; } }

        stop() { if (1 & this.flags) { for (let e = this.deps; e; e = e.nextDep)Me(e); this.deps = this.depsTail = void 0, je(this), this.onStop && this.onStop(), this.flags &= -2; } }

        trigger() { 64 & this.flags ? ge.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty(); }

        runIfDirty() { Le(this) && this.run(); }

        get dirty() { return Le(this); }
      }let be; let we; let Se = 0; function xe(e, t = !1) { if (e.flags |= 8, t) return e.next = we, void (we = e); e.next = be, be = e; } function Ee() { Se++; } function Te() { if (--Se > 0) return; if (we) { let e = we; for (we = void 0; e;) { const t = e.next; e.next = void 0, e.flags &= -9, e = t; } }let e; for (;be;) { let t = be; for (be = void 0; t;) { const n = t.next; if (t.next = void 0, t.flags &= -9, 1 & t.flags) try { t.trigger(); } catch (t) { e || (e = t); }t = n; } } if (e) throw e; } function _e(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t; } function Ce(e) { let t; let n = e.depsTail; let r = n; for (;r;) { const e = r.prevDep; r.version === -1 ? (r === n && (n = e), Me(r), Ae(r)) : t = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = e; }e.deps = t, e.depsTail = n; } function Le(e) { for (let t = e.deps; t; t = t.nextDep) if (t.dep.version !== t.version || t.dep.computed && (ke(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty; } function ke(e) { if (4 & e.flags && !(16 & e.flags)) return; if (e.flags &= -17, e.globalVersion === Ve) return; e.globalVersion = Ve; const t = e.dep; if (e.flags |= 2, t.version > 0 && !e.isSSR && e.deps && !Le(e)) return void (e.flags &= -3); const n = pe; const r = Ie; pe = e, Ie = !0; try { _e(e); const n = e.fn(e._value); (t.version === 0 || V(n, e._value)) && (e._value = n, t.version++); } catch (e) { throw t.version++, e; } finally { pe = n, Ie = r, Ce(e), e.flags &= -3; } } function Me(e, t = !1) { const { dep: n, prevSub: r, nextSub: i } = e; if (r && (r.nextSub = i, e.prevSub = void 0), i && (i.prevSub = r, e.nextSub = void 0), n.subs === e && (n.subs = r, !r && n.computed)) { n.computed.flags &= -5; for (let e = n.computed.deps; e; e = e.nextDep)Me(e, !0); }t || --n.sc || !n.map || n.map.delete(n.key); } function Ae(e) { const { prevDep: t, nextDep: n } = e; t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0); } function Oe(e, t) { e.effect instanceof ye && (e = e.effect.fn); const n = new ye(e); t && d(n, t); try { n.run(); } catch (e) { throw n.stop(), e; } const r = n.run.bind(n); return r.effect = n, r; } function Pe(e) { e.effect.stop(); }let Ie = !0; const Ne = []; function De() { Ne.push(Ie), Ie = !1; } function Re() { const e = Ne.pop(); Ie = void 0 === e || e; } function je(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const e = pe; pe = void 0; try { t(); } finally { pe = e; } } }let Ve = 0; class Fe {constructor(e, t) { this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0; }} class ze {
        constructor(e) { this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0; }

        track(e) { if (!pe || !Ie || pe === this.computed) return; let t = this.activeLink; if (void 0 === t || t.sub !== pe)t = this.activeLink = new Fe(pe, this), pe.deps ? (t.prevDep = pe.depsTail, pe.depsTail.nextDep = t, pe.depsTail = t) : pe.deps = pe.depsTail = t, Be(t); else if (t.version === -1 && (t.version = this.version, t.nextDep)) { const e = t.nextDep; e.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = e), t.prevDep = pe.depsTail, t.nextDep = void 0, pe.depsTail.nextDep = t, pe.depsTail = t, pe.deps === t && (pe.deps = e); } return t; }

        trigger(e) { this.version++, Ve++, this.notify(e); }

        notify(e) { Ee(); try { for (let e = this.subs; e; e = e.prevSub)e.sub.notify() && e.sub.dep.notify(); } finally { Te(); } }
      } function Be(e) { if (e.dep.sc++, 4 & e.sub.flags) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let e = t.deps; e; e = e.nextDep)Be(e); } const n = e.dep.subs; n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e; } } const qe = new WeakMap(); const He = Symbol(''); const Ge = Symbol(''); const
        Ue = Symbol(''); function $e(e, t, n) { if (Ie && pe) { let t = qe.get(e); t || qe.set(e, t = new Map()); let r = t.get(n); r || (t.set(n, r = new ze()), r.map = t, r.key = n), r.track(); } } function We(e, t, n, r, i, o) { const a = qe.get(e); if (!a) return void Ve++; const s = (e) => { e && e.trigger(); }; if (Ee(), t === 'clear')a.forEach(s); else { const i = m(e); const o = i && k(n); if (i && n === 'length') { const e = Number(r); a.forEach(((t, n) => { (n === 'length' || n === Ue || !S(n) && n >= e) && s(t); })); } else switch ((void 0 !== n || a.has(void 0)) && s(a.get(n)), o && s(a.get(Ue)), t) { case 'add': i ? o && s(a.get('length')) : (s(a.get(He)), v(e) && s(a.get(Ge))); break; case 'delete': i || (s(a.get(He)), v(e) && s(a.get(Ge))); break; case 'set': v(e) && s(a.get(He)); } }Te(); } function Ye(e) { const t = Nt(e); return t === e ? t : ($e(t, 0, Ue), Pt(e) ? t : t.map(Rt)); } function Xe(e) { return $e(e = Nt(e), 0, Ue), e; } const Ke = {
        __proto__: null, [Symbol.iterator]() { return Je(this, Symbol.iterator, Rt); }, concat(...e) { return Ye(this).concat(...e.map(((e) => (m(e) ? Ye(e) : e)))); }, entries() { return Je(this, 'entries', ((e) => (e[1] = Rt(e[1]), e))); }, every(e, t) { return Ze(this, 'every', e, t, void 0, arguments); }, filter(e, t) { return Ze(this, 'filter', e, t, ((e) => e.map(Rt)), arguments); }, find(e, t) { return Ze(this, 'find', e, t, Rt, arguments); }, findIndex(e, t) { return Ze(this, 'findIndex', e, t, void 0, arguments); }, findLast(e, t) { return Ze(this, 'findLast', e, t, Rt, arguments); }, findLastIndex(e, t) { return Ze(this, 'findLastIndex', e, t, void 0, arguments); }, forEach(e, t) { return Ze(this, 'forEach', e, t, void 0, arguments); }, includes(...e) { return tt(this, 'includes', e); }, indexOf(...e) { return tt(this, 'indexOf', e); }, join(e) { return Ye(this).join(e); }, lastIndexOf(...e) { return tt(this, 'lastIndexOf', e); }, map(e, t) { return Ze(this, 'map', e, t, void 0, arguments); }, pop() { return nt(this, 'pop'); }, push(...e) { return nt(this, 'push', e); }, reduce(e, ...t) { return et(this, 'reduce', e, t); }, reduceRight(e, ...t) { return et(this, 'reduceRight', e, t); }, shift() { return nt(this, 'shift'); }, some(e, t) { return Ze(this, 'some', e, t, void 0, arguments); }, splice(...e) { return nt(this, 'splice', e); }, toReversed() { return Ye(this).toReversed(); }, toSorted(e) { return Ye(this).toSorted(e); }, toSpliced(...e) { return Ye(this).toSpliced(...e); }, unshift(...e) { return nt(this, 'unshift', e); }, values() { return Je(this, 'values', Rt); },
      }; function Je(e, t, n) { const r = Xe(e); const i = r[t](); return r === e || Pt(e) || (i._next = i.next, i.next = () => { const e = i._next(); return e.value && (e.value = n(e.value)), e; }), i; } const Qe = Array.prototype; function Ze(e, t, n, r, i, o) { const a = Xe(e); const s = a !== e && !Pt(e); const l = a[t]; if (l !== Qe[t]) { const t = l.apply(e, o); return s ? Rt(t) : t; }let c = n; a !== e && (s ? c = function (t, r) { return n.call(this, Rt(t), r, e); } : n.length > 2 && (c = function (t, r) { return n.call(this, t, r, e); })); const u = l.call(a, c, r); return s && i ? i(u) : u; } function et(e, t, n, r) { const i = Xe(e); let o = n; return i !== e && (Pt(e) ? n.length > 3 && (o = function (t, r, i) { return n.call(this, t, r, i, e); }) : o = function (t, r, i) { return n.call(this, t, Rt(r), i, e); }), i[t](o, ...r); } function tt(e, t, n) { const r = Nt(e); $e(r, 0, Ue); const i = r[t](...n); return i !== -1 && !1 !== i || !It(n[0]) ? i : (n[0] = Nt(n[0]), r[t](...n)); } function nt(e, t, n = []) { De(), Ee(); const r = Nt(e)[t].apply(e, n); return Te(), Re(), r; } const rt = i('__proto__,__v_isRef,__isVue'); const it = new Set(Object.getOwnPropertyNames(Symbol).filter(((e) => e !== 'arguments' && e !== 'caller')).map(((e) => Symbol[e])).filter(S)); function ot(e) { S(e) || (e = String(e)); const t = Nt(this); return $e(t, 0, e), t.hasOwnProperty(e); } class at {
        constructor(e = !1, t = !1) { this._isReadonly = e, this._isShallow = t; }

        get(e, t, n) { if (t === '__v_skip') return e.__v_skip; const r = this._isReadonly; const i = this._isShallow; if (t === '__v_isReactive') return !r; if (t === '__v_isReadonly') return r; if (t === '__v_isShallow') return i; if (t === '__v_raw') return n === (r ? i ? Tt : Et : i ? xt : St).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0; const o = m(e); if (!r) { let e; if (o && (e = Ke[t])) return e; if (t === 'hasOwnProperty') return ot; } const a = Reflect.get(e, t, Vt(e) ? e : n); return (S(t) ? it.has(t) : rt(t)) ? a : (r || $e(e, 0, t), i ? a : Vt(a) ? o && k(t) ? a : a.value : x(a) ? r ? Lt(a) : _t(a) : a); }
      } class st extends at {
        constructor(e = !1) { super(!1, e); }

        set(e, t, n, r) { let i = e[t]; if (!this._isShallow) { const t = Ot(i); if (Pt(n) || Ot(n) || (i = Nt(i), n = Nt(n)), !m(e) && Vt(i) && !Vt(n)) return !t && (i.value = n, !0); } const o = m(e) && k(t) ? Number(t) < e.length : h(e, t); const a = Reflect.set(e, t, n, Vt(e) ? e : r); return e === Nt(r) && (o ? V(n, i) && We(e, 'set', t, n) : We(e, 'add', t, n)), a; }

        deleteProperty(e, t) { const n = h(e, t); const r = (e[t], Reflect.deleteProperty(e, t)); return r && n && We(e, 'delete', t, void 0), r; }

        has(e, t) { const n = Reflect.has(e, t); return S(t) && it.has(t) || $e(e, 0, t), n; }

        ownKeys(e) { return $e(e, 0, m(e) ? 'length' : He), Reflect.ownKeys(e); }
      } class lt extends at {
        constructor(e = !1) { super(!0, e); }

        set(e, t) { return !0; }

        deleteProperty(e, t) { return !0; }
      } const ct = new st(); const ut = new lt(); const dt = new st(!0); const pt = new lt(!0); const ft = (e) => e; const
        ht = (e) => Reflect.getPrototypeOf(e); function mt(e) { return function (...t) { return e !== 'delete' && (e === 'clear' ? void 0 : this); }; } function vt(e, t) {
        const n = (function (e, t) {
          const n = {
            get(n) { const r = this.__v_raw; const i = Nt(r); const o = Nt(n); e || (V(n, o) && $e(i, 0, n), $e(i, 0, o)); const { has: a } = ht(i); const s = t ? ft : e ? jt : Rt; return a.call(i, n) ? s(r.get(n)) : a.call(i, o) ? s(r.get(o)) : void (r !== i && r.get(n)); }, get size() { const t = this.__v_raw; return !e && $e(Nt(t), 0, He), Reflect.get(t, 'size', t); }, has(t) { const n = this.__v_raw; const r = Nt(n); const i = Nt(t); return e || (V(t, i) && $e(r, 0, t), $e(r, 0, i)), t === i ? n.has(t) : n.has(t) || n.has(i); }, forEach(n, r) { const i = this; const o = i.__v_raw; const a = Nt(o); const s = t ? ft : e ? jt : Rt; return !e && $e(a, 0, He), o.forEach(((e, t) => n.call(r, s(e), s(t), i))); },
          }; return d(n, e ? {
            add: mt('add'), set: mt('set'), delete: mt('delete'), clear: mt('clear'),
          } : {
            add(e) { t || Pt(e) || Ot(e) || (e = Nt(e)); const n = Nt(this); return ht(n).has.call(n, e) || (n.add(e), We(n, 'add', e, e)), this; }, set(e, n) { t || Pt(n) || Ot(n) || (n = Nt(n)); const r = Nt(this); const { has: i, get: o } = ht(r); let a = i.call(r, e); a || (e = Nt(e), a = i.call(r, e)); const s = o.call(r, e); return r.set(e, n), a ? V(n, s) && We(r, 'set', e, n) : We(r, 'add', e, n), this; }, delete(e) { const t = Nt(this); const { has: n, get: r } = ht(t); let i = n.call(t, e); i || (e = Nt(e), i = n.call(t, e)), r && r.call(t, e); const o = t.delete(e); return i && We(t, 'delete', e, void 0), o; }, clear() { const e = Nt(this); const t = e.size !== 0; const n = e.clear(); return t && We(e, 'clear', void 0, void 0), n; },
          }), ['keys', 'values', 'entries', Symbol.iterator].forEach(((r) => { n[r] = (function (e, t, n) { return function (...r) { const i = this.__v_raw; const o = Nt(i); const a = v(o); const s = e === 'entries' || e === Symbol.iterator && a; const l = e === 'keys' && a; const c = i[e](...r); const u = n ? ft : t ? jt : Rt; return !t && $e(o, 0, l ? Ge : He), { next() { const { value: e, done: t } = c.next(); return t ? { value: e, done: t } : { value: s ? [u(e[0]), u(e[1])] : u(e), done: t }; }, [Symbol.iterator]() { return this; } }; }; }(r, e, t)); })), n;
        }(e, t)); return (t, r, i) => (r === '__v_isReactive' ? !e : r === '__v_isReadonly' ? e : r === '__v_raw' ? t : Reflect.get(h(n, r) && r in t ? n : t, r, i));
      } const gt = { get: vt(!1, !1) }; const yt = { get: vt(!1, !0) }; const bt = { get: vt(!0, !1) }; const wt = { get: vt(!0, !0) }; const St = new WeakMap(); const xt = new WeakMap(); const Et = new WeakMap(); const Tt = new WeakMap(); function _t(e) { return Ot(e) ? e : Mt(e, !1, ct, gt, St); } function Ct(e) { return Mt(e, !1, dt, yt, xt); } function Lt(e) { return Mt(e, !0, ut, bt, Et); } function kt(e) { return Mt(e, !0, pt, wt, Tt); } function Mt(e, t, n, r, i) { if (!x(e)) return e; if (e.__v_raw && (!t || !e.__v_isReactive)) return e; const o = i.get(e); if (o) return o; const a = (s = e).__v_skip || !Object.isExtensible(s) ? 0 : (function (e) { switch (e) { case 'Object': case 'Array': return 1; case 'Map': case 'Set': case 'WeakMap': case 'WeakSet': return 2; default: return 0; } }(C(s))); let s; if (a === 0) return e; const l = new Proxy(e, a === 2 ? r : n); return i.set(e, l), l; } function At(e) { return Ot(e) ? At(e.__v_raw) : !(!e || !e.__v_isReactive); } function Ot(e) { return !(!e || !e.__v_isReadonly); } function Pt(e) { return !(!e || !e.__v_isShallow); } function It(e) { return !!e && !!e.__v_raw; } function Nt(e) { const t = e && e.__v_raw; return t ? Nt(t) : e; } function Dt(e) { return !h(e, '__v_skip') && Object.isExtensible(e) && z(e, '__v_skip', !0), e; } const Rt = (e) => (x(e) ? _t(e) : e); const jt = (e) => (x(e) ? Lt(e) : e); function Vt(e) { return !!e && !0 === e.__v_isRef; } function Ft(e) { return Bt(e, !1); } function zt(e) { return Bt(e, !0); } function Bt(e, t) { return Vt(e) ? e : new qt(e, t); } class qt {
        constructor(e, t) { this.dep = new ze(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : Nt(e), this._value = t ? e : Rt(e), this.__v_isShallow = t; }

        get value() { return this.dep.track(), this._value; }

        set value(e) { const t = this._rawValue; const n = this.__v_isShallow || Pt(e) || Ot(e); e = n ? e : Nt(e), V(e, t) && (this._rawValue = e, this._value = n ? e : Rt(e), this.dep.trigger()); }
      } function Ht(e) { e.dep && e.dep.trigger(); } function Gt(e) { return Vt(e) ? e.value : e; } function Ut(e) { return b(e) ? e() : Gt(e); } const $t = { get: (e, t, n) => (t === '__v_raw' ? e : Gt(Reflect.get(e, t, n))), set: (e, t, n, r) => { const i = e[t]; return Vt(i) && !Vt(n) ? (i.value = n, !0) : Reflect.set(e, t, n, r); } }; function Wt(e) { return At(e) ? e : new Proxy(e, $t); } class Yt {
        constructor(e) {
          this.__v_isRef = !0, this._value = void 0; const t = this.dep = new ze(); const
            { get: n, set: r } = e(t.track.bind(t), t.trigger.bind(t)); this._get = n, this._set = r;
        }

        get value() { return this._value = this._get(); }

        set value(e) { this._set(e); }
      } function Xt(e) { return new Yt(e); } function Kt(e) { const t = m(e) ? new Array(e.length) : {}; for (const n in e)t[n] = en(e, n); return t; } class Jt {
        constructor(e, t, n) { this._object = e, this._key = t, this._defaultValue = n, this.__v_isRef = !0, this._value = void 0; }

        get value() { const e = this._object[this._key]; return this._value = void 0 === e ? this._defaultValue : e; }

        set value(e) { this._object[this._key] = e; }

        get dep() { return (function (e, t) { const n = qe.get(e); return n && n.get(t); }(Nt(this._object), this._key)); }
      } class Qt {
        constructor(e) { this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0; }

        get value() { return this._value = this._getter(); }
      } function Zt(e, t, n) { return Vt(e) ? e : b(e) ? new Qt(e) : x(e) && arguments.length > 1 ? en(e, t, n) : Ft(e); } function en(e, t, n) { const r = e[t]; return Vt(r) ? r : new Jt(e, t, n); } class tn {
        constructor(e, t, n) { this.fn = e, this.setter = t, this._value = void 0, this.dep = new ze(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Ve - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !t, this.isSSR = n; }

        notify() { if (this.flags |= 16, !(8 & this.flags || pe === this)) return xe(this, !0), !0; }

        get value() { const e = this.dep.track(); return ke(this), e && (e.version = this.dep.version), this._value; }

        set value(e) { this.setter && this.setter(e); }
      } const nn = { GET: 'get', HAS: 'has', ITERATE: 'iterate' }; const rn = {
        SET: 'set', ADD: 'add', DELETE: 'delete', CLEAR: 'clear',
      }; const on = {}; const an = new WeakMap(); let sn; function ln() { return sn; } function cn(e, t = !1, n = sn) { if (n) { let t = an.get(n); t || an.set(n, t = []), t.push(e); } } function un(e, t = 1 / 0, n) { if (t <= 0 || !x(e) || e.__v_skip) return e; if ((n = n || new Set()).has(e)) return e; if (n.add(e), t--, Vt(e))un(e.value, t, n); else if (m(e)) for (let r = 0; r < e.length; r++)un(e[r], t, n); else if (g(e) || v(e))e.forEach(((e) => { un(e, t, n); })); else if (L(e)) { for (const r in e)un(e[r], t, n); for (const r of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e, r) && un(e[r], t, n); } return e; } const dn = []; function pn(e, t) {} const fn = {
        SETUP_FUNCTION: 0, 0: 'SETUP_FUNCTION', RENDER_FUNCTION: 1, 1: 'RENDER_FUNCTION', NATIVE_EVENT_HANDLER: 5, 5: 'NATIVE_EVENT_HANDLER', COMPONENT_EVENT_HANDLER: 6, 6: 'COMPONENT_EVENT_HANDLER', VNODE_HOOK: 7, 7: 'VNODE_HOOK', DIRECTIVE_HOOK: 8, 8: 'DIRECTIVE_HOOK', TRANSITION_HOOK: 9, 9: 'TRANSITION_HOOK', APP_ERROR_HANDLER: 10, 10: 'APP_ERROR_HANDLER', APP_WARN_HANDLER: 11, 11: 'APP_WARN_HANDLER', FUNCTION_REF: 12, 12: 'FUNCTION_REF', ASYNC_COMPONENT_LOADER: 13, 13: 'ASYNC_COMPONENT_LOADER', SCHEDULER: 14, 14: 'SCHEDULER', COMPONENT_UPDATE: 15, 15: 'COMPONENT_UPDATE', APP_UNMOUNT_CLEANUP: 16, 16: 'APP_UNMOUNT_CLEANUP',
      }; function hn(e, t, n, r) { try { return r ? e(...r) : e(); } catch (e) { vn(e, t, n); } } function mn(e, t, n, r) { if (b(e)) { const i = hn(e, t, n, r); return i && E(i) && i.catch(((e) => { vn(e, t, n); })), i; } if (m(e)) { const i = []; for (let o = 0; o < e.length; o++)i.push(mn(e[o], t, n, r)); return i; } } function vn(e, t, n, r = !0) { t && t.vnode; const { errorHandler: i, throwUnhandledErrorInProduction: a } = t && t.appContext.config || o; if (t) { let r = t.parent; const o = t.proxy; const a = `https://vuejs.org/error-reference/#runtime-${n}`; for (;r;) { const t = r.ec; if (t) for (let n = 0; n < t.length; n++) if (!1 === t[n](e, o, a)) return; r = r.parent; } if (i) return De(), hn(i, null, 10, [e, o, a]), void Re(); }!(function (e, t, n, r = !0, i = !1) { if (i) throw e; console.error(e); }(e, 0, 0, r, a)); } const gn = []; let yn = -1; const bn = []; let wn = null; let Sn = 0; const xn = Promise.resolve(); let En = null; function Tn(e) { const t = En || xn; return e ? t.then(this ? e.bind(this) : e) : t; } function _n(e) { if (!(1 & e.flags)) { const t = An(e); const n = gn[gn.length - 1]; !n || !(2 & e.flags) && t >= An(n) ? gn.push(e) : gn.splice((function (e) { let t = yn + 1; let n = gn.length; for (;t < n;) { const r = t + n >>> 1; const i = gn[r]; const o = An(i); o < e || o === e && 2 & i.flags ? t = r + 1 : n = r; } return t; }(t)), 0, e), e.flags |= 1, Cn(); } } function Cn() { En || (En = xn.then(On)); } function Ln(e) { m(e) ? bn.push(...e) : wn && e.id === -1 ? wn.splice(Sn + 1, 0, e) : 1 & e.flags || (bn.push(e), e.flags |= 1), Cn(); } function kn(e, t, n = yn + 1) { for (;n < gn.length; n++) { const t = gn[n]; if (t && 2 & t.flags) { if (e && t.id !== e.uid) continue; gn.splice(n, 1), n--, 4 & t.flags && (t.flags &= -2), t(), 4 & t.flags || (t.flags &= -2); } } } function Mn(e) { if (bn.length) { const e = [...new Set(bn)].sort(((e, t) => An(e) - An(t))); if (bn.length = 0, wn) return void wn.push(...e); for (wn = e, Sn = 0; Sn < wn.length; Sn++) { const e = wn[Sn]; 4 & e.flags && (e.flags &= -2), 8 & e.flags || e(), e.flags &= -2; }wn = null, Sn = 0; } } const An = (e) => (e.id == null ? 2 & e.flags ? -1 : 1 / 0 : e.id); function On(e) { try { for (yn = 0; yn < gn.length; yn++) { const e = gn[yn]; !e || 8 & e.flags || (4 & e.flags && (e.flags &= -2), hn(e, e.i, e.i ? 15 : 14), 4 & e.flags || (e.flags &= -2)); } } finally { for (;yn < gn.length; yn++) { const e = gn[yn]; e && (e.flags &= -2); }yn = -1, gn.length = 0, Mn(), En = null, (gn.length || bn.length) && On(e); } }let Pn; let In = []; let Nn = !1; function Dn(e, ...t) { Pn ? Pn.emit(e, ...t) : Nn || In.push({ event: e, args: t }); } function Rn(e, t) { let n; let r; Pn = e, Pn ? (Pn.enabled = !0, In.forEach((({ event: e, args: t }) => Pn.emit(e, ...t))), In = []) : typeof window !== 'undefined' && window.HTMLElement && !((r = (n = window.navigator) == null ? void 0 : n.userAgent) == null ? void 0 : r.includes('jsdom')) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(((e) => { Rn(e, t); })), setTimeout((() => { Pn || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Nn = !0, In = []); }), 3e3)) : (Nn = !0, In = []); } const jn = Bn('component:added'); const Vn = Bn('component:updated'); const Fn = Bn('component:removed'); const zn = (e) => { Pn && typeof Pn.cleanupBuffer === 'function' && !Pn.cleanupBuffer(e) && Fn(e); }; function Bn(e) { return (t) => { Dn(e, t.appContext.app, t.uid, t.parent ? t.parent.uid : void 0, t); }; }let qn = null; let Hn = null; function Gn(e) { const t = qn; return qn = e, Hn = e && e.type.__scopeId || null, t; } function Un(e) { Hn = e; } function $n() { Hn = null; } const Wn = (e) => Yn; function Yn(e, t = qn, n) { if (!t) return e; if (e._n) return e; const r = (...n) => { r._d && ba(-1); const i = Gn(t); let o; try { o = e(...n); } finally { Gn(i), r._d && ba(1); } return __VUE_PROD_DEVTOOLS__ && Vn(t), o; }; return r._n = !0, r._c = !0, r._d = !0, r; } function Xn(e, t) {
        if (qn === null) return e; const n = as(qn); const r = e.dirs || (e.dirs = []); for (let e = 0; e < t.length; e++) {
          let[i, a, s, l = o] = t[e]; i && (b(i) && (i = { mounted: i, updated: i }), i.deep && un(a), r.push({
            dir: i, instance: n, value: a, oldValue: void 0, arg: s, modifiers: l,
          }));
        } return e;
      } function Kn(e, t, n, r) { const i = e.dirs; const o = t && t.dirs; for (let a = 0; a < i.length; a++) { const s = i[a]; o && (s.oldValue = o[a].value); const l = s.dir[r]; l && (De(), mn(l, n, 8, [e.el, s, e, t]), Re()); } } const Jn = Symbol('_vte'); const Qn = (e) => e.__isTeleport; const Zn = (e) => e && (e.disabled || e.disabled === ''); const er = (e) => e && (e.defer || e.defer === ''); const tr = (e) => typeof SVGElement !== 'undefined' && e instanceof SVGElement; const nr = (e) => typeof MathMLElement === 'function' && e instanceof MathMLElement; const rr = (e, t) => { const n = e && e.to; return w(n) ? t ? t(n) : null : n; }; const ir = {
        name: 'Teleport',
        __isTeleport: !0,
        process(e, t, n, r, i, o, a, s, l, c) {
          const {
            mc: u, pc: d, pbc: p, o: {
              insert: f, querySelector: h, createText: m, createComment: v,
            },
          } = c; const g = Zn(t.props); const { shapeFlag: y, children: b, dynamicChildren: w } = t; if (e == null) { const e = t.el = m(''); const c = t.anchor = m(''); f(e, n, r), f(c, n, r); const d = (e, t) => { 16 & y && (i && i.isCE && (i.ce._teleportTarget = e), u(b, e, t, i, o, a, s, l)); }; const p = () => { const e = t.target = rr(t.props, h); const n = lr(e, t, m, f); e && (a !== 'svg' && tr(e) ? a = 'svg' : a !== 'mathml' && nr(e) && (a = 'mathml'), g || (d(e, n), sr(t, !1))); }; g && (d(n, c), sr(t, !0)), er(t.props) ? Co((() => { p(), t.el.__isMounted = !0; }), o) : p(); } else { if (er(t.props) && !e.el.__isMounted) return void Co((() => { ir.process(e, t, n, r, i, o, a, s, l, c), delete e.el.__isMounted; }), o); t.el = e.el, t.targetStart = e.targetStart; const u = t.anchor = e.anchor; const f = t.target = e.target; const m = t.targetAnchor = e.targetAnchor; const v = Zn(e.props); const y = v ? n : f; const b = v ? u : m; if (a === 'svg' || tr(f) ? a = 'svg' : (a === 'mathml' || nr(f)) && (a = 'mathml'), w ? (p(e.dynamicChildren, w, y, i, o, a, s), Io(e, t, !0)) : l || d(e, t, y, b, i, o, a, s, !1), g)v ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : or(t, n, u, c, 1); else if ((t.props && t.props.to) !== (e.props && e.props.to)) { const e = t.target = rr(t.props, h); e && or(t, e, null, c, 0); } else v && or(t, f, m, c, 1); sr(t, g); }
        },
        remove(e, t, n, { um: r, o: { remove: i } }, o) {
          const {
            shapeFlag: a, children: s, anchor: l, targetStart: c, targetAnchor: u, target: d, props: p,
          } = e; if (d && (i(c), i(u)), o && i(l), 16 & a) { const e = o || !Zn(p); for (let i = 0; i < s.length; i++) { const o = s[i]; r(o, t, n, e, !!o.dynamicChildren); } }
        },
        move: or,
        hydrate(e, t, n, r, i, o, {
          o: {
            nextSibling: a, parentNode: s, querySelector: l, insert: c, createText: u,
          },
        }, d) { const p = t.target = rr(t.props, l); if (p) { const l = Zn(t.props); const f = p._lpa || p.firstChild; if (16 & t.shapeFlag) if (l)t.anchor = d(a(e), t, s(e), n, r, i, o), t.targetStart = f, t.targetAnchor = f && a(f); else { t.anchor = a(e); let s = f; for (;s;) { if (s && s.nodeType === 8) if (s.data === 'teleport start anchor')t.targetStart = s; else if (s.data === 'teleport anchor') { t.targetAnchor = s, p._lpa = t.targetAnchor && a(t.targetAnchor); break; }s = a(s); }t.targetAnchor || lr(p, t, u, c), d(f && a(f), t, p, n, r, i, o); }sr(t, l); } return t.anchor && a(t.anchor); },
      }; function or(e, t, n, { o: { insert: r }, m: i }, o = 2) {
        o === 0 && r(e.targetAnchor, t, n); const {
          el: a, anchor: s, shapeFlag: l, children: c, props: u,
        } = e; const d = o === 2; if (d && r(a, t, n), (!d || Zn(u)) && 16 & l) for (let e = 0; e < c.length; e++)i(c[e], t, n, 2); d && r(s, t, n);
      } const ar = ir; function sr(e, t) { const n = e.ctx; if (n && n.ut) { let r; let i; for (t ? (r = e.el, i = e.anchor) : (r = e.targetStart, i = e.targetAnchor); r && r !== i;)r.nodeType === 1 && r.setAttribute('data-v-owner', n.uid), r = r.nextSibling; n.ut(); } } function lr(e, t, n, r) { const i = t.targetStart = n(''); const o = t.targetAnchor = n(''); return i[Jn] = o, e && (r(i, e), r(o, e)), o; } const cr = Symbol('_leaveCb'); const ur = Symbol('_enterCb'); function dr() {
        const e = {
          isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map(),
        }; return ri((() => { e.isMounted = !0; })), ai((() => { e.isUnmounting = !0; })), e;
      } const pr = [Function, Array]; const fr = {
        mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: pr, onEnter: pr, onAfterEnter: pr, onEnterCancelled: pr, onBeforeLeave: pr, onLeave: pr, onAfterLeave: pr, onLeaveCancelled: pr, onBeforeAppear: pr, onAppear: pr, onAfterAppear: pr, onAppearCancelled: pr,
      }; const hr = (e) => { const t = e.subTree; return t.component ? hr(t.component) : t; }; function mr(e) { let t = e[0]; if (e.length > 1) { let n = !1; for (const r of e) if (r.type !== da) { t = r, n = !0; break; } } return t; } const vr = { name: 'BaseTransition', props: fr, setup(e, { slots: t }) { const n = Ga(); const r = dr(); return () => { const i = t.default && xr(t.default(), !0); if (!i || !i.length) return; const o = mr(i); const a = Nt(e); const { mode: s } = a; if (r.isLeaving) return br(o); const l = wr(o); if (!l) return br(o); let c = yr(l, a, r, n, ((e) => c = e)); l.type !== da && Sr(l, c); let u = n.subTree && wr(n.subTree); if (u && u.type !== da && !Ta(l, u) && hr(n).type !== da) { const e = yr(u, a, r, n); if (Sr(u, e), s === 'out-in' && l.type !== da) return r.isLeaving = !0, e.afterLeave = () => { r.isLeaving = !1, 8 & n.job.flags || n.update(), delete e.afterLeave, u = void 0; }, br(o); s === 'in-out' && l.type !== da ? e.delayLeave = (e, t, n) => { gr(r, u)[String(u.key)] = u, e[cr] = () => { t(), e[cr] = void 0, delete c.delayedLeave, u = void 0; }, c.delayedLeave = () => { n(), delete c.delayedLeave, u = void 0; }; } : u = void 0; } else u && (u = void 0); return o; }; } }; function gr(e, t) { const { leavingVNodes: n } = e; let r = n.get(t.type); return r || (r = Object.create(null), n.set(t.type, r)), r; } function yr(e, t, n, r, i) {
        const {
          appear: o, mode: a, persisted: s = !1, onBeforeEnter: l, onEnter: c, onAfterEnter: u, onEnterCancelled: d, onBeforeLeave: p, onLeave: f, onAfterLeave: h, onLeaveCancelled: v, onBeforeAppear: g, onAppear: y, onAfterAppear: b, onAppearCancelled: w,
        } = t; const S = String(e.key); const x = gr(n, e); const E = (e, t) => { e && mn(e, r, 9, t); }; const T = (e, t) => { const n = t[1]; E(e, t), m(e) ? e.every(((e) => e.length <= 1)) && n() : e.length <= 1 && n(); }; const _ = {
          mode: a, persisted: s, beforeEnter(t) { let r = l; if (!n.isMounted) { if (!o) return; r = g || l; }t[cr] && t[cr](!0); const i = x[S]; i && Ta(e, i) && i.el[cr] && i.el[cr](), E(r, [t]); }, enter(e) { let t = c; let r = u; let i = d; if (!n.isMounted) { if (!o) return; t = y || c, r = b || u, i = w || d; }let a = !1; const s = e[ur] = (t) => { a || (a = !0, E(t ? i : r, [e]), _.delayedLeave && _.delayedLeave(), e[ur] = void 0); }; t ? T(t, [e, s]) : s(); }, leave(t, r) { const i = String(e.key); if (t[ur] && t[ur](!0), n.isUnmounting) return r(); E(p, [t]); let o = !1; const a = t[cr] = (n) => { o || (o = !0, r(), E(n ? v : h, [t]), t[cr] = void 0, x[i] === e && delete x[i]); }; x[i] = e, f ? T(f, [t, a]) : a(); }, clone(e) { const o = yr(e, t, n, r, i); return i && i(o), o; },
        }; return _;
      } function br(e) { if (Ur(e)) return (e = Oa(e)).children = null, e; } function wr(e) { if (!Ur(e)) return Qn(e.type) && e.children ? mr(e.children) : e; const { shapeFlag: t, children: n } = e; if (n) { if (16 & t) return n[0]; if (32 & t && b(n.default)) return n.default(); } } function Sr(e, t) { 6 & e.shapeFlag && e.component ? (e.transition = t, Sr(e.component.subTree, t)) : 128 & e.shapeFlag ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t; } function xr(e, t = !1, n) { let r = []; let i = 0; for (let o = 0; o < e.length; o++) { const a = e[o]; const s = n == null ? a.key : String(n) + String(a.key != null ? a.key : o); a.type === ca ? (128 & a.patchFlag && i++, r = r.concat(xr(a.children, t, s))) : (t || a.type !== da) && r.push(s != null ? Oa(a, { key: s }) : a); } if (i > 1) for (let e = 0; e < r.length; e++)r[e].patchFlag = -2; return r; } function Er(e, t) { return b(e) ? (() => ({ name: e.name, ...t, setup: e }))() : e; } function Tr() { const e = Ga(); return e ? `${e.appContext.config.idPrefix || 'v'}-${e.ids[0]}${e.ids[1]++}` : ''; } function _r(e) { e.ids = [`${e.ids[0] + e.ids[2]++}-`, 0, 0]; } function Cr(e) { const t = Ga(); const n = zt(null); if (t) { const r = t.refs === o ? t.refs = {} : t.refs; Object.defineProperty(r, e, { enumerable: !0, get: () => n.value, set: (e) => n.value = e }); } return n; } function Lr(e, t, n, r, i = !1) { if (m(e)) return void e.forEach(((e, o) => Lr(e, t && (m(t) ? t[o] : t), n, r, i))); if (qr(r) && !i) return void (512 & r.shapeFlag && r.type.__asyncResolved && r.component.subTree.component && Lr(e, t, n, r.component.subTree)); const a = 4 & r.shapeFlag ? as(r.component) : r.el; const s = i ? null : a; const { i: l, r: c } = e; const u = t && t.r; const d = l.refs === o ? l.refs = {} : l.refs; const f = l.setupState; const v = Nt(f); const g = f === o ? () => !1 : (e) => h(v, e); if (u != null && u !== c && (w(u) ? (d[u] = null, g(u) && (f[u] = null)) : Vt(u) && (u.value = null)), b(c))hn(c, l, 12, [s, d]); else { const t = w(c); const r = Vt(c); if (t || r) { const o = () => { if (e.f) { const n = t ? g(c) ? f[c] : d[c] : c.value; i ? m(n) && p(n, a) : m(n) ? n.includes(a) || n.push(a) : t ? (d[c] = [a], g(c) && (f[c] = d[c])) : (c.value = [a], e.k && (d[e.k] = c.value)); } else t ? (d[c] = s, g(c) && (f[c] = s)) : r && (c.value = s, e.k && (d[e.k] = s)); }; s ? (o.id = -1, Co(o, n)) : o(); } } }let kr = !1; const Mr = () => { kr || (console.error('Hydration completed but contains mismatches.'), kr = !0); }; const Ar = (e) => { if (e.nodeType === 1) return ((e) => e.namespaceURI.includes('svg') && e.tagName !== 'foreignObject')(e) ? 'svg' : ((e) => e.namespaceURI.includes('MathML'))(e) ? 'mathml' : void 0; }; const Or = (e) => e.nodeType === 8; function Pr(e) {
        const {
          mt: t, p: n, o: {
            patchProp: r, createText: i, nextSibling: o, parentNode: a, remove: s, insert: l, createComment: u,
          },
        } = e; const d = (n, r, s, c, u, b = !1) => {
          b = b || !!r.dynamicChildren; const w = Or(n) && n.data === '['; const S = () => m(n, r, s, c, u, w); const {
            type: x, ref: E, shapeFlag: T, patchFlag: _,
          } = r; let C = n.nodeType; r.el = n, __VUE_PROD_DEVTOOLS__ && (z(n, '__vnode', r, !0), z(n, '__vueParentComponent', s, !0)), _ === -2 && (b = !1, r.dynamicChildren = null); let L = null; switch (x) { case ua: C !== 3 ? r.children === '' ? (l(r.el = i(''), a(n), n), L = n) : L = S() : (n.data !== r.children && (Mr(), n.data = r.children), L = o(n)); break; case da: y(n) ? (L = o(n), g(r.el = n.content.firstChild, n, s)) : L = C !== 8 || w ? S() : o(n); break; case pa: if (w && (C = (n = o(n)).nodeType), C === 1 || C === 3) { L = n; const e = !r.children.length; for (let t = 0; t < r.staticCount; t++)e && (r.children += L.nodeType === 1 ? L.outerHTML : L.data), t === r.staticCount - 1 && (r.anchor = L), L = o(L); return w ? o(L) : L; }S(); break; case ca: L = w ? h(n, r, s, c, u, b) : S(); break; default: if (1 & T)L = C === 1 && r.type.toLowerCase() === n.tagName.toLowerCase() || y(n) ? p(n, r, s, c, u, b) : S(); else if (6 & T) { r.slotScopeIds = u; const e = a(n); if (L = w ? v(n) : Or(n) && n.data === 'teleport start' ? v(n, n.data, 'teleport end') : o(n), t(r, e, null, s, c, Ar(e), b), qr(r) && !r.type.__asyncResolved) { let t; w ? (t = Ma(ca), t.anchor = L ? L.previousSibling : e.lastChild) : t = n.nodeType === 3 ? Pa('') : Ma('div'), t.el = n, r.component.subTree = t; } } else 64 & T ? L = C !== 8 ? S() : r.type.hydrate(n, r, s, c, u, b, e, f) : 128 & T && (L = r.type.hydrate(n, r, s, c, Ar(a(n)), u, b, e, d)); } return E != null && Lr(E, null, c, r), L;
        }; const p = (e, t, n, i, o, a) => {
          a = a || !!t.dynamicChildren; const {
            type: l, props: u, patchFlag: d, shapeFlag: p, dirs: h, transition: m,
          } = t; const v = l === 'input' || l === 'option'; if (v || d !== -1) { h && Kn(t, null, n, 'created'); let l; let b = !1; if (y(e)) { b = Po(null, m) && n && n.vnode.props && n.vnode.props.appear; const r = e.content.firstChild; b && m.beforeEnter(r), g(r, e, n), t.el = e = r; } if (16 & p && (!u || !u.innerHTML && !u.textContent)) { let r = f(e.firstChild, t, e, n, i, o, a); for (;r;) { Dr(e, 1) || Mr(); const t = r; r = r.nextSibling, s(t); } } else if (8 & p) { let n = t.children; n[0] !== '\n' || e.tagName !== 'PRE' && e.tagName !== 'TEXTAREA' || (n = n.slice(1)), e.textContent !== n && (Dr(e, 0) || Mr(), e.textContent = t.children); } if (u) if (v || !a || 48 & d) { const t = e.tagName.includes('-'); for (const i in u)(v && (i.endsWith('value') || i === 'indeterminate') || c(i) && !M(i) || i[0] === '.' || t) && r(e, i, null, u[i], void 0, n); } else if (u.onClick)r(e, 'onClick', null, u.onClick, void 0, n); else if (4 & d && At(u.style)) for (const e in u.style)u.style[e]; (l = u && u.onVnodeBeforeMount) && Fa(l, n, t), h && Kn(t, null, n, 'beforeMount'), ((l = u && u.onVnodeMounted) || h || b) && sa((() => { l && Fa(l, n, t), b && m.enter(e), h && Kn(t, null, n, 'mounted'); }), i); } return e.nextSibling;
        }; const f = (e, t, r, a, s, c, u) => { u = u || !!t.dynamicChildren; const p = t.children; const f = p.length; for (let t = 0; t < f; t++) { const h = u ? p[t] : p[t] = Da(p[t]); const m = h.type === ua; e ? (m && !u && t + 1 < f && Da(p[t + 1]).type === ua && (l(i(e.data.slice(h.children.length)), r, o(e)), e.data = h.children), e = d(e, h, a, s, c, u)) : m && !h.children ? l(h.el = i(''), r) : (Dr(r, 1) || Mr(), n(null, h, r, null, a, s, Ar(r), c)); } return e; }; const h = (e, t, n, r, i, s) => { const { slotScopeIds: c } = t; c && (i = i ? i.concat(c) : c); const d = a(e); const p = f(o(e), t, d, n, r, i, s); return p && Or(p) && p.data === ']' ? o(t.anchor = p) : (Mr(), l(t.anchor = u(']'), d, p), p); }; const m = (e, t, r, i, l, c) => { if (Dr(e.parentElement, 1) || Mr(), t.el = null, c) { const t = v(e); for (;;) { const n = o(e); if (!n || n === t) break; s(n); } } const u = o(e); const d = a(e); return s(e), n(null, t, d, u, r, i, Ar(d), l), r && (r.vnode.el = t.el, ea(r, t.el)), u; }; const v = (e, t = '[', n = ']') => { let r = 0; for (;e;) if ((e = o(e)) && Or(e) && (e.data === t && r++, e.data === n)) { if (r === 0) return o(e); r--; } return e; }; const g = (e, t, n) => { const r = t.parentNode; r && r.replaceChild(e, t); let i = n; for (;i;)i.vnode.el === t && (i.vnode.el = i.subTree.el = e), i = i.parent; }; const y = (e) => e.nodeType === 1 && e.tagName === 'TEMPLATE'; return [(e, t) => { if (!t.hasChildNodes()) return n(null, e, t), Mn(), void (t._vnode = e); d(t.firstChild, e, null, null, null), Mn(), t._vnode = e; }, d];
      } const Ir = 'data-allow-mismatch'; const Nr = {
        0: 'text', 1: 'children', 2: 'class', 3: 'style', 4: 'attribute',
      }; function Dr(e, t) { if (t === 0 || t === 1) for (;e && !e.hasAttribute(Ir);)e = e.parentElement; const n = e && e.getAttribute(Ir); if (n == null) return !1; if (n === '') return !0; { const e = n.split(','); return !(t !== 0 || !e.includes('children')) || n.split(',').includes(Nr[t]); } } const Rr = G().requestIdleCallback || ((e) => setTimeout(e, 1)); const jr = G().cancelIdleCallback || ((e) => clearTimeout(e)); const Vr = (e = 1e4) => (t) => { const n = Rr(t, { timeout: e }); return () => jr(n); }; const Fr = (e) => (t, n) => {
        const r = new IntersectionObserver(((e) => { for (const n of e) if (n.isIntersecting) { r.disconnect(), t(); break; } }), e); return n(((e) => {
          if (e instanceof Element) {
            return (function (e) {
              const {
                top: t, left: n, bottom: r, right: i,
              } = e.getBoundingClientRect(); const { innerHeight: o, innerWidth: a } = window; return (t > 0 && t < o || r > 0 && r < o) && (n > 0 && n < a || i > 0 && i < a);
            }(e)) ? (t(), r.disconnect(), !1) : void r.observe(e);
          }
        })), () => r.disconnect();
      }; const zr = (e) => (t) => { if (e) { const n = matchMedia(e); if (!n.matches) return n.addEventListener('change', t, { once: !0 }), () => n.removeEventListener('change', t); t(); } }; const Br = (e = []) => (t, n) => { w(e) && (e = [e]); let r = !1; const i = (e) => { r || (r = !0, o(), t(), e.target.dispatchEvent(new e.constructor(e.type, e))); }; const o = () => { n(((t) => { for (const n of e)t.removeEventListener(n, i); })); }; return n(((t) => { for (const n of e)t.addEventListener(n, i, { once: !0 }); })), o; }; const qr = (e) => !!e.type.__asyncLoader; function Hr(e) {
        b(e) && (e = { loader: e }); const {
          loader: t, loadingComponent: n, errorComponent: r, delay: i = 200, hydrate: o, timeout: a, suspensible: s = !0, onError: l,
        } = e; let c; let u = null; let d = 0; const p = () => { let e; return u || (e = u = t().catch(((e) => { if (e = e instanceof Error ? e : new Error(String(e)), l) return new Promise(((t, n) => { l(e, (() => t((d++, u = null, p()))), (() => n(e)), d + 1); })); throw e; })).then(((t) => (e !== u && u ? u : (t && (t.__esModule || t[Symbol.toStringTag] === 'Module') && (t = t.default), c = t, t))))); }; return Er({
          name: 'AsyncComponentWrapper', __asyncLoader: p, __asyncHydrate(e, t, n) { const r = o ? () => { const r = o(n, ((t) => (function (e, t) { if (Or(e) && e.data === '[') { let n = 1; let r = e.nextSibling; for (;r;) { if (r.nodeType === 1) { if (!1 === t(r)) break; } else if (Or(r)) if (r.data === ']') { if (--n == 0) break; } else r.data === '[' && n++; r = r.nextSibling; } } else t(e); }(e, t)))); r && (t.bum || (t.bum = [])).push(r); } : n; c ? r() : p().then((() => !t.isUnmounted && r())); }, get __asyncResolved() { return c; }, setup() { const e = Ha; if (_r(e), c) return () => Gr(c, e); const t = (t) => { u = null, vn(t, e, 13, !r); }; if (s && e.suspense || Qa) return p().then(((t) => () => Gr(t, e))).catch(((e) => (t(e), () => (r ? Ma(r, { error: e }) : null)))); const o = Ft(!1); const l = Ft(); const d = Ft(!!i); return i && setTimeout((() => { d.value = !1; }), i), a != null && setTimeout((() => { if (!o.value && !l.value) { const e = new Error(`Async component timed out after ${a}ms.`); t(e), l.value = e; } }), a), p().then((() => { o.value = !0, e.parent && Ur(e.parent.vnode) && e.parent.update(); })).catch(((e) => { t(e), l.value = e; })), () => (o.value && c ? Gr(c, e) : l.value && r ? Ma(r, { error: l.value }) : n && !d.value ? Ma(n) : void 0); },
        });
      } function Gr(e, t) {
        const {
          ref: n, props: r, children: i, ce: o,
        } = t.vnode; const a = Ma(e, r, i); return a.ref = n, a.ce = o, delete t.vnode.ce, a;
      } const Ur = (e) => e.type.__isKeepAlive; const $r = {
        name: 'KeepAlive',
        __isKeepAlive: !0,
        props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] },
        setup(e, { slots: t }) {
          const n = Ga(); const r = n.ctx; if (!r.renderer) return () => { const e = t.default && t.default(); return e && e.length === 1 ? e[0] : e; }; const i = new Map(); const
            o = new Set(); let a = null; __VUE_PROD_DEVTOOLS__ && (n.__v_cache = i); const s = n.suspense; const {
            renderer: {
              p: l, m: c, um: u, o: { createElement: d },
            },
          } = r; const p = d('div'); function f(e) { Qr(e), u(e, n, s, !0); } function h(e) { i.forEach(((t, n) => { const r = ss(t.type); r && !e(r) && m(n); })); } function m(e) { const t = i.get(e); !t || a && Ta(t, a) ? a && Qr(a) : f(t), i.delete(e), o.delete(e); }r.activate = (e, t, n, r, i) => { const o = e.component; c(e, t, n, 0, s), l(o.vnode, e, t, n, o, s, r, e.slotScopeIds, i), Co((() => { o.isDeactivated = !1, o.a && F(o.a); const t = e.props && e.props.onVnodeMounted; t && Fa(t, o.parent, e); }), s), __VUE_PROD_DEVTOOLS__ && jn(o); }, r.deactivate = (e) => { const t = e.component; Do(t.m), Do(t.a), c(e, p, null, 1, s), Co((() => { t.da && F(t.da); const n = e.props && e.props.onVnodeUnmounted; n && Fa(n, t.parent, e), t.isDeactivated = !0; }), s), __VUE_PROD_DEVTOOLS__ && jn(t); }, Bo((() => [e.include, e.exclude]), (([e, t]) => { e && h(((t) => Wr(e, t))), t && h(((e) => !Wr(t, e))); }), { flush: 'post', deep: !0 }); let v = null; const g = () => { v != null && (ta(n.subTree.type) ? Co((() => { i.set(v, Zr(n.subTree)); }), n.subTree.suspense) : i.set(v, Zr(n.subTree))); }; return ri(g), oi(g), ai((() => { i.forEach(((e) => { const { subTree: t, suspense: r } = n; const i = Zr(t); if (e.type !== i.type || e.key !== i.key)f(e); else { Qr(i); const e = i.component.da; e && Co(e, r); } })); })), () => { if (v = null, !t.default) return a = null; const n = t.default(); const r = n[0]; if (n.length > 1) return a = null, n; if (!Ea(r) || !(4 & r.shapeFlag || 128 & r.shapeFlag)) return a = null, r; let s = Zr(r); if (s.type === da) return a = null, s; const l = s.type; const c = ss(qr(s) ? s.type.__asyncResolved || {} : l); const { include: u, exclude: d, max: p } = e; if (u && (!c || !Wr(u, c)) || d && c && Wr(d, c)) return s.shapeFlag &= -257, a = s, r; const f = s.key == null ? l : s.key; const h = i.get(f); return s.el && (s = Oa(s), 128 & r.shapeFlag && (r.ssContent = s)), v = f, h ? (s.el = h.el, s.component = h.component, s.transition && Sr(s, s.transition), s.shapeFlag |= 512, o.delete(f), o.add(f)) : (o.add(f), p && o.size > parseInt(p, 10) && m(o.values().next().value)), s.shapeFlag |= 256, a = s, ta(r.type) ? r : s; };
        },
      }; function Wr(e, t) { return m(e) ? e.some(((e) => Wr(e, t))) : w(e) ? e.split(',').includes(t) : _(e) === '[object RegExp]' && (e.lastIndex = 0, e.test(t)); } function Yr(e, t) { Kr(e, 'a', t); } function Xr(e, t) { Kr(e, 'da', t); } function Kr(e, t, n = Ha) { const r = e.__wdc || (e.__wdc = () => { let t = n; for (;t;) { if (t.isDeactivated) return; t = t.parent; } return e(); }); if (ei(t, r, n), n) { let e = n.parent; for (;e && e.parent;)Ur(e.parent.vnode) && Jr(r, t, n, e), e = e.parent; } } function Jr(e, t, n, r) { const i = ei(t, e, r, !0); si((() => { p(r[t], i); }), n); } function Qr(e) { e.shapeFlag &= -257, e.shapeFlag &= -513; } function Zr(e) { return 128 & e.shapeFlag ? e.ssContent : e; } function ei(e, t, n = Ha, r = !1) { if (n) { const i = n[e] || (n[e] = []); const o = t.__weh || (t.__weh = (...r) => { De(); const i = Wa(n); const o = mn(t, n, e, r); return i(), Re(), o; }); return r ? i.unshift(o) : i.push(o), o; } } const ti = (e) => (t, n = Ha) => { Qa && e !== 'sp' || ei(e, ((...e) => t(...e)), n); }; const ni = ti('bm'); const ri = ti('m'); const ii = ti('bu'); const oi = ti('u'); const ai = ti('bum'); const si = ti('um'); const li = ti('sp'); const ci = ti('rtg'); const ui = ti('rtc'); function di(e, t = Ha) { ei('ec', e, t); } const pi = 'components'; const fi = 'directives'; function hi(e, t) { return yi(pi, e, !0, t) || e; } const mi = Symbol.for('v-ndc'); function vi(e) { return w(e) ? yi(pi, e, !1) || e : e || mi; } function gi(e) { return yi(fi, e); } function yi(e, t, n = !0, r = !1) { const i = qn || Ha; if (i) { const n = i.type; if (e === pi) { const e = ss(n, !1); if (e && (e === t || e === I(t) || e === R(I(t)))) return n; } const o = bi(i[e] || n[e], t) || bi(i.appContext[e], t); return !o && r ? n : o; } } function bi(e, t) { return e && (e[t] || e[I(t)] || e[R(I(t))]); } function wi(e, t, n, r) { let i; const o = n && n[r]; const a = m(e); if (a || w(e)) { let n = !1; a && At(e) && (n = !Pt(e), e = Xe(e)), i = new Array(e.length); for (let r = 0, a = e.length; r < a; r++)i[r] = t(n ? Rt(e[r]) : e[r], r, void 0, o && o[r]); } else if (typeof e === 'number') { i = new Array(e); for (let n = 0; n < e; n++)i[n] = t(n + 1, n, void 0, o && o[n]); } else if (x(e)) if (e[Symbol.iterator])i = Array.from(e, ((e, n) => t(e, n, void 0, o && o[n]))); else { const n = Object.keys(e); i = new Array(n.length); for (let r = 0, a = n.length; r < a; r++) { const a = n[r]; i[r] = t(e[a], a, r, o && o[r]); } } else i = []; return n && (n[r] = i), i; } function Si(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n]; if (m(r)) for (let t = 0; t < r.length; t++)e[r[t].name] = r[t].fn; else r && (e[r.name] = r.key ? (...e) => { const t = r.fn(...e); return t && (t.key = r.key), t; } : r.fn); } return e; } function xi(e, t, n = {}, r, i) { if (qn.ce || qn.parent && qr(qn.parent) && qn.parent.ce) return t !== 'default' && (n.name = t), ma(), xa(ca, null, [Ma('slot', n, r && r())], 64); const o = e[t]; o && o._c && (o._d = !1), ma(); const a = o && Ei(o(n)); const s = n.key || a && a.key; const l = xa(ca, { key: (s && !S(s) ? s : `_${t}`) + (!a && r ? '_fb' : '') }, a || (r ? r() : []), a && e._ === 1 ? 64 : -2); return !i && l.scopeId && (l.slotScopeIds = [`${l.scopeId}-s`]), o && o._c && (o._d = !0), l; } function Ei(e) { return e.some(((e) => !Ea(e) || e.type !== da && !(e.type === ca && !Ei(e.children)))) ? e : null; } function Ti(e, t) { const n = {}; for (const r in e)n[t && /[A-Z]/.test(r) ? `on:${r}` : j(r)] = e[r]; return n; } const _i = (e) => (e ? Xa(e) ? as(e) : _i(e.parent) : null); const Ci = d(Object.create(null), {
        $: (e) => e, $el: (e) => e.vnode.el, $data: (e) => e.data, $props: (e) => e.props, $attrs: (e) => e.attrs, $slots: (e) => e.slots, $refs: (e) => e.refs, $parent: (e) => _i(e.parent), $root: (e) => _i(e.root), $host: (e) => e.ce, $emit: (e) => e.emit, $options: (e) => (__VUE_OPTIONS_API__ ? Yi(e) : e.type), $forceUpdate: (e) => e.f || (e.f = () => { _n(e.update); }), $nextTick: (e) => e.n || (e.n = Tn.bind(e.proxy)), $watch: (e) => (__VUE_OPTIONS_API__ ? Ho.bind(e) : s),
      }); const Li = (e, t) => e !== o && !e.__isScriptSetup && h(e, t); const ki = {
        get({ _: e }, t) {
          if (t === '__v_skip') return !0; const {
            ctx: n, setupState: r, data: i, props: a, accessCache: s, type: l, appContext: c,
          } = e; let u; if (t[0] !== '$') { const l = s[t]; if (void 0 !== l) switch (l) { case 1: return r[t]; case 2: return i[t]; case 4: return n[t]; case 3: return a[t]; } else { if (Li(r, t)) return s[t] = 1, r[t]; if (i !== o && h(i, t)) return s[t] = 2, i[t]; if ((u = e.propsOptions[0]) && h(u, t)) return s[t] = 3, a[t]; if (n !== o && h(n, t)) return s[t] = 4, n[t]; __VUE_OPTIONS_API__ && !Ui || (s[t] = 0); } } const d = Ci[t]; let p; let f; return d ? (t === '$attrs' && $e(e.attrs, 0, ''), d(e)) : (p = l.__cssModules) && (p = p[t]) ? p : n !== o && h(n, t) ? (s[t] = 4, n[t]) : (f = c.config.globalProperties, h(f, t) ? f[t] : void 0);
        },
        set({ _: e }, t, n) { const { data: r, setupState: i, ctx: a } = e; return Li(i, t) ? (i[t] = n, !0) : r !== o && h(r, t) ? (r[t] = n, !0) : !(h(e.props, t) || t[0] === '$' && t.slice(1) in e || (a[t] = n, 0)); },
        has({
          _: {
            data: e, setupState: t, accessCache: n, ctx: r, appContext: i, propsOptions: a,
          },
        }, s) { let l; return !!n[s] || e !== o && h(e, s) || Li(t, s) || (l = a[0]) && h(l, s) || h(r, s) || h(Ci, s) || h(i.config.globalProperties, s); },
        defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : h(n, 'value') && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n); },
      }; const Mi = { ...ki, get(e, t) { if (t !== Symbol.unscopables) return ki.get(e, t, e); }, has: (e, t) => t[0] !== '_' && !U(t) }; function Ai() { return null; } function Oi() { return null; } function Pi(e) {} function Ii(e) {} function Ni() { return null; } function Di() {} function Ri(e, t) { return null; } function ji() { return Fi().slots; } function Vi() { return Fi().attrs; } function Fi() { const e = Ga(); return e.setupContext || (e.setupContext = os(e)); } function zi(e) { return m(e) ? e.reduce(((e, t) => (e[t] = null, e)), {}) : e; } function Bi(e, t) { const n = zi(e); for (const e in t) { if (e.startsWith('__skip')) continue; let r = n[e]; r ? m(r) || b(r) ? r = n[e] = { type: r, default: t[e] } : r.default = t[e] : r === null && (r = n[e] = { default: t[e] }), r && t[`__skip_${e}`] && (r.skipFactory = !0); } return n; } function qi(e, t) { return e && t ? m(e) && m(t) ? e.concat(t) : ({ ...zi(e), ...zi(t) }) : e || t; } function Hi(e, t) { const n = {}; for (const r in e)t.includes(r) || Object.defineProperty(n, r, { enumerable: !0, get: () => e[r] }); return n; } function Gi(e) { const t = Ga(); let n = e(); return Ya(), E(n) && (n = n.catch(((e) => { throw Wa(t), e; }))), [n, () => Wa(t)]; }let Ui = !0; function $i(e, t, n) { mn(m(e) ? e.map(((e) => e.bind(t.proxy))) : e.bind(t.proxy), t, n); } function Wi(e, t, n, r) { const i = r.includes('.') ? Go(n, r) : () => n[r]; if (w(e)) { const n = t[e]; b(n) && Bo(i, n); } else if (b(e))Bo(i, e.bind(n)); else if (x(e)) if (m(e))e.forEach(((e) => Wi(e, t, n, r))); else { const r = b(e.handler) ? e.handler.bind(n) : t[e.handler]; b(r) && Bo(i, r, e); } } function Yi(e) { const t = e.type; const { mixins: n, extends: r } = t; const { mixins: i, optionsCache: o, config: { optionMergeStrategies: a } } = e.appContext; const s = o.get(t); let l; return s ? l = s : i.length || n || r ? (l = {}, i.length && i.forEach(((e) => Xi(l, e, a, !0))), Xi(l, t, a)) : l = t, x(t) && o.set(t, l), l; } function Xi(e, t, n, r = !1) { const { mixins: i, extends: o } = t; o && Xi(e, o, n, !0), i && i.forEach(((t) => Xi(e, t, n, !0))); for (const i in t) if (r && i === 'expose');else { const r = Ki[i] || n && n[i]; e[i] = r ? r(e[i], t[i]) : t[i]; } return e; } const Ki = {
        data: Ji, props: to, emits: to, methods: eo, computed: eo, beforeCreate: Zi, created: Zi, beforeMount: Zi, mounted: Zi, beforeUpdate: Zi, updated: Zi, beforeDestroy: Zi, beforeUnmount: Zi, destroyed: Zi, unmounted: Zi, activated: Zi, deactivated: Zi, errorCaptured: Zi, serverPrefetch: Zi, components: eo, directives: eo, watch(e, t) { if (!e) return t; if (!t) return e; const n = d(Object.create(null), e); for (const r in t)n[r] = Zi(e[r], t[r]); return n; }, provide: Ji, inject(e, t) { return eo(Qi(e), Qi(t)); },
      }; function Ji(e, t) { return t ? e ? function () { return d(b(e) ? e.call(this, this) : e, b(t) ? t.call(this, this) : t); } : t : e; } function Qi(e) { if (m(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t; } return e; } function Zi(e, t) { return e ? [...new Set([].concat(e, t))] : t; } function eo(e, t) { return e ? d(Object.create(null), e, t) : t; } function to(e, t) { return e ? m(e) && m(t) ? [...new Set([...e, ...t])] : d(Object.create(null), zi(e), zi(t != null ? t : {})) : t; } function no() {
        return {
          app: null,
          config: {
            isNativeTag: l, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {},
          },
          mixins: [],
          components: {},
          directives: {},
          provides: Object.create(null),
          optionsCache: new WeakMap(),
          propsCache: new WeakMap(),
          emitsCache: new WeakMap(),
        };
      }let ro = 0; function io(e, t) {
        return function (n, r = null) {
          b(n) || (n = { ...n }), r == null || x(r) || (r = null); const i = no(); const o = new WeakSet(); const a = []; let s = !1; const l = i.app = {
            _uid: ro++,
            _component: n,
            _props: r,
            _container: null,
            _context: i,
            _instance: null,
            version: fs,
            get config() { return i.config; },
            set config(e) {},
            use: (e, ...t) => (o.has(e) || (e && b(e.install) ? (o.add(e), e.install(l, ...t)) : b(e) && (o.add(e), e(l, ...t))), l),
            mixin: (e) => (__VUE_OPTIONS_API__ && (i.mixins.includes(e) || i.mixins.push(e)), l),
            component: (e, t) => (t ? (i.components[e] = t, l) : i.components[e]),
            directive: (e, t) => (t ? (i.directives[e] = t, l) : i.directives[e]),
            mount(o, a, c) {
              if (!s) {
                const u = l._ceVNode || Ma(n, r); return u.appContext = i, !0 === c ? c = 'svg' : !1 === c && (c = void 0), a && t ? t(u, o) : e(u, o, c), s = !0, l._container = o, o.__vue_app__ = l, __VUE_PROD_DEVTOOLS__ && (l._instance = u.component, (function (e, t) {
                  Dn('app:init', e, t, {
                    Fragment: ca, Text: ua, Comment: da, Static: pa,
                  });
                }(l, fs))), as(u.component);
              }
            },
            onUnmount(e) { a.push(e); },
            unmount() { s && (mn(a, l._instance, 16), e(null, l._container), __VUE_PROD_DEVTOOLS__ && (l._instance = null, (function (e) { Dn('app:unmount', e); }(l))), delete l._container.__vue_app__); },
            provide: (e, t) => (i.provides[e] = t, l),
            runWithContext(e) { const t = oo; oo = l; try { return e(); } finally { oo = t; } },
          }; return l;
        };
      }let oo = null; function ao(e, t) { if (Ha) { let n = Ha.provides; const r = Ha.parent && Ha.parent.provides; r === n && (n = Ha.provides = Object.create(r)), n[e] = t; } } function so(e, t, n = !1) { const r = Ha || qn; if (r || oo) { const i = oo ? oo._context.provides : r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0; if (i && e in i) return i[e]; if (arguments.length > 1) return n && b(t) ? t.call(r && r.proxy) : t; } } function lo() { return !!(Ha || qn || oo); } const co = {}; const uo = () => Object.create(co); const po = (e) => Object.getPrototypeOf(e) === co; function fo(e, t, n, r) { const [i, a] = e.propsOptions; let s; let l = !1; if (t) for (const o in t) { if (M(o)) continue; const c = t[o]; let u; i && h(i, u = I(o)) ? a && a.includes(u) ? (s || (s = {}))[u] = c : n[u] = c : Xo(e.emitsOptions, o) || o in r && c === r[o] || (r[o] = c, l = !0); } if (a) { const t = Nt(n); const r = s || o; for (let o = 0; o < a.length; o++) { const s = a[o]; n[s] = ho(i, t, s, r[s], e, !h(r, s)); } } return l; } function ho(e, t, n, r, i, o) { const a = e[n]; if (a != null) { const e = h(a, 'default'); if (e && void 0 === r) { const e = a.default; if (a.type !== Function && !a.skipFactory && b(e)) { const { propsDefaults: o } = i; if (n in o)r = o[n]; else { const a = Wa(i); r = o[n] = e.call(null, t), a(); } } else r = e; i.ce && i.ce._setProp(n, r); }a[0] && (o && !e ? r = !1 : !a[1] || r !== '' && r !== D(n) || (r = !0)); } return r; } const mo = new WeakMap(); function vo(e, t, n = !1) { const r = __VUE_OPTIONS_API__ && n ? mo : t.propsCache; const i = r.get(e); if (i) return i; const s = e.props; const l = {}; const c = []; let u = !1; if (__VUE_OPTIONS_API__ && !b(e)) { const r = (e) => { u = !0; const [n, r] = vo(e, t, !0); d(l, n), r && c.push(...r); }; !n && t.mixins.length && t.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r); } if (!s && !u) return x(e) && r.set(e, a), a; if (m(s)) for (let e = 0; e < s.length; e++) { const t = I(s[e]); go(t) && (l[t] = o); } else if (s) for (const e in s) { const t = I(e); if (go(t)) { const n = s[e]; const r = l[t] = m(n) || b(n) ? { type: n } : ({ ...n }); const i = r.type; let o = !1; let a = !0; if (m(i)) for (let e = 0; e < i.length; ++e) { const t = i[e]; const n = b(t) && t.name; if (n === 'Boolean') { o = !0; break; }n === 'String' && (a = !1); } else o = b(i) && i.name === 'Boolean'; r[0] = o, r[1] = a, (o || h(r, 'default')) && c.push(t); } } const p = [l, c]; return x(e) && r.set(e, p), p; } function go(e) { return e[0] !== '$' && !M(e); } const yo = (e) => e[0] === '_' || e === '$stable'; const bo = (e) => (m(e) ? e.map(Da) : [Da(e)]); const wo = (e, t, n) => { if (t._n) return t; const r = Yn(((...e) => bo(t(...e))), n); return r._c = !1, r; }; const So = (e, t, n) => { const r = e._ctx; for (const n in e) { if (yo(n)) continue; const i = e[n]; if (b(i))t[n] = wo(0, i, r); else if (i != null) { const e = bo(i); t[n] = () => e; } } }; const xo = (e, t) => { const n = bo(t); e.slots.default = () => n; }; const Eo = (e, t, n) => { for (const r in t)(n || r !== '_') && (e[r] = t[r]); }; const To = (e, t, n) => { const r = e.slots = uo(); if (32 & e.vnode.shapeFlag) { const e = t._; e ? (Eo(r, t, n), n && z(r, '_', e, !0)) : So(t, r); } else t && xo(e, t); }; const _o = (e, t, n) => { const { vnode: r, slots: i } = e; let a = !0; let s = o; if (32 & r.shapeFlag) { const e = t._; e ? n && e === 1 ? a = !1 : Eo(i, t, n) : (a = !t.$stable, So(t, i)), s = t; } else t && (xo(e, t), s = { default: 1 }); if (a) for (const e in i)yo(e) || s[e] != null || delete i[e]; }; const Co = sa; function Lo(e) { return Mo(e); } function ko(e) { return Mo(e, Pr); } function Mo(e, t) {
        typeof __VUE_OPTIONS_API__ !== 'boolean' && (G().__VUE_OPTIONS_API__ = !0), typeof __VUE_PROD_DEVTOOLS__ !== 'boolean' && (G().__VUE_PROD_DEVTOOLS__ = !1); const n = G(); n.__VUE__ = !0, __VUE_PROD_DEVTOOLS__ && Rn(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n); const {
          insert: r, remove: i, patchProp: l, createElement: c, createText: u, createComment: d, setText: p, setElementText: f, parentNode: m, nextSibling: v, setScopeId: g = s, insertStaticContent: y,
        } = e; const b = (e, t, n, r = null, i = null, o = null, a = void 0, s = null, l = !!t.dynamicChildren) => { if (e === t) return; e && !Ta(e, t) && (r = J(e), $(e, i, o, !0), e = null), t.patchFlag === -2 && (l = !1, t.dynamicChildren = null); const { type: c, ref: u, shapeFlag: d } = t; switch (c) { case ua: w(e, t, n, r); break; case da: S(e, t, n, r); break; case pa: e == null && x(t, n, r, a); break; case ca: O(e, t, n, r, i, o, a, s, l); break; default: 1 & d ? E(e, t, n, r, i, o, a, s, l) : 6 & d ? P(e, t, n, r, i, o, a, s, l) : (64 & d || 128 & d) && c.process(e, t, n, r, i, o, a, s, l, ee); }u != null && i && Lr(u, e && e.ref, o, t || e, !t); }; const w = (e, t, n, i) => { if (e == null)r(t.el = u(t.children), n, i); else { const n = t.el = e.el; t.children !== e.children && p(n, t.children); } }; const S = (e, t, n, i) => { e == null ? r(t.el = d(t.children || ''), n, i) : t.el = e.el; }; const x = (e, t, n, r) => { [e.el, e.anchor] = y(e.children, t, n, r, e.el, e.anchor); }; const E = (e, t, n, r, i, o, a, s, l) => { t.type === 'svg' ? a = 'svg' : t.type === 'math' && (a = 'mathml'), e == null ? T(t, n, r, i, o, a, s, l) : L(e, t, i, o, a, s, l); }; const T = (e, t, n, i, o, a, s, u) => {
          let d; let p; const {
            props: h, shapeFlag: m, transition: v, dirs: g,
          } = e; if (d = e.el = c(e.type, a, h && h.is, h), 8 & m ? f(d, e.children) : 16 & m && C(e.children, d, null, i, o, Ao(e, a), s, u), g && Kn(e, null, i, 'created'), _(d, e, e.scopeId, s, i), h) { for (const e in h)e === 'value' || M(e) || l(d, e, null, h[e], a, i); 'value' in h && l(d, 'value', null, h.value, a), (p = h.onVnodeBeforeMount) && Fa(p, i, e); }__VUE_PROD_DEVTOOLS__ && (z(d, '__vnode', e, !0), z(d, '__vueParentComponent', i, !0)), g && Kn(e, null, i, 'beforeMount'); const y = Po(o, v); y && v.beforeEnter(d), r(d, t, n), ((p = h && h.onVnodeMounted) || y || g) && Co((() => { p && Fa(p, i, e), y && v.enter(d), g && Kn(e, null, i, 'mounted'); }), o);
        }; const _ = (e, t, n, r, i) => { if (n && g(e, n), r) for (let t = 0; t < r.length; t++)g(e, r[t]); if (i) { const n = i.subTree; if (t === n || ta(n.type) && (n.ssContent === t || n.ssFallback === t)) { const t = i.vnode; _(e, t, t.scopeId, t.slotScopeIds, i.parent); } } }; const C = (e, t, n, r, i, o, a, s, l = 0) => { for (let c = l; c < e.length; c++) { const l = e[c] = s ? Ra(e[c]) : Da(e[c]); b(null, l, t, n, r, i, o, a, s); } }; const L = (e, t, n, r, i, a, s) => { const c = t.el = e.el; __VUE_PROD_DEVTOOLS__ && (c.__vnode = t); let{ patchFlag: u, dynamicChildren: d, dirs: p } = t; u |= 16 & e.patchFlag; const h = e.props || o; const m = t.props || o; let v; if (n && Oo(n, !1), (v = m.onVnodeBeforeUpdate) && Fa(v, n, t, e), p && Kn(t, e, n, 'beforeUpdate'), n && Oo(n, !0), (h.innerHTML && m.innerHTML == null || h.textContent && m.textContent == null) && f(c, ''), d ? k(e.dynamicChildren, d, c, n, r, Ao(t, i), a) : s || B(e, t, c, null, n, r, Ao(t, i), a, !1), u > 0) { if (16 & u)A(c, h, m, n, i); else if (2 & u && h.class !== m.class && l(c, 'class', null, m.class, i), 4 & u && l(c, 'style', h.style, m.style, i), 8 & u) { const e = t.dynamicProps; for (let t = 0; t < e.length; t++) { const r = e[t]; const o = h[r]; const a = m[r]; a === o && r !== 'value' || l(c, r, o, a, i, n); } }1 & u && e.children !== t.children && f(c, t.children); } else s || d != null || A(c, h, m, n, i); ((v = m.onVnodeUpdated) || p) && Co((() => { v && Fa(v, n, t, e), p && Kn(t, e, n, 'updated'); }), r); }; const k = (e, t, n, r, i, o, a) => { for (let s = 0; s < t.length; s++) { const l = e[s]; const c = t[s]; const u = l.el && (l.type === ca || !Ta(l, c) || 70 & l.shapeFlag) ? m(l.el) : n; b(l, c, u, null, r, i, o, a, !0); } }; const A = (e, t, n, r, i) => { if (t !== n) { if (t !== o) for (const o in t)M(o) || o in n || l(e, o, t[o], null, i, r); for (const o in n) { if (M(o)) continue; const a = n[o]; const s = t[o]; a !== s && o !== 'value' && l(e, o, s, a, i, r); }'value' in n && l(e, 'value', t.value, n.value, i); } }; const O = (e, t, n, i, o, a, s, l, c) => { const d = t.el = e ? e.el : u(''); const p = t.anchor = e ? e.anchor : u(''); const { patchFlag: f, dynamicChildren: h, slotScopeIds: m } = t; m && (l = l ? l.concat(m) : m), e == null ? (r(d, n, i), r(p, n, i), C(t.children || [], n, p, o, a, s, l, c)) : f > 0 && 64 & f && h && e.dynamicChildren ? (k(e.dynamicChildren, h, n, o, a, s, l), (t.key != null || o && t === o.subTree) && Io(e, t, !0)) : B(e, t, n, p, o, a, s, l, c); }; const P = (e, t, n, r, i, o, a, s, l) => { t.slotScopeIds = s, e == null ? 512 & t.shapeFlag ? i.ctx.activate(t, n, r, a, l) : N(t, n, r, i, o, a, l) : R(e, t, l); }; const N = (e, t, n, r, i, o, a) => { const s = e.component = qa(e, r, i); if (Ur(e) && (s.ctx.renderer = ee), Za(s, !1, a), s.asyncDep) { if (i && i.registerDep(s, j, a), !e.el) { const e = s.subTree = Ma(da); S(null, e, t, n); } } else j(s, e, t, n, i, o, a); }; const R = (e, t, n) => { const r = t.component = e.component; if (function (e, t, n) { const { props: r, children: i, component: o } = e; const { props: a, children: s, patchFlag: l } = t; const c = o.emitsOptions; if (t.dirs || t.transition) return !0; if (!(n && l >= 0)) return !(!i && !s || s && s.$stable) || r !== a && (r ? !a || Zo(r, a, c) : !!a); if (1024 & l) return !0; if (16 & l) return r ? Zo(r, a, c) : !!a; if (8 & l) { const e = t.dynamicProps; for (let t = 0; t < e.length; t++) { const n = e[t]; if (a[n] !== r[n] && !Xo(c, n)) return !0; } } return !1; }(e, t, n)) { if (r.asyncDep && !r.asyncResolved) return void V(r, t, n); r.next = t, r.update(); } else t.el = e.el, r.vnode = t; }; const j = (e, t, n, r, i, o, a) => {
          const s = () => {
            if (e.isMounted) {
              let{
                next: t, bu: n, u: r, parent: l, vnode: c,
              } = e; { const n = No(e); if (n) return t && (t.el = c.el, V(e, t, a)), void n.asyncDep.then((() => { e.isUnmounted || s(); })); }let u; const d = t; Oo(e, !1), t ? (t.el = c.el, V(e, t, a)) : t = c, n && F(n), (u = t.props && t.props.onVnodeBeforeUpdate) && Fa(u, l, t, c), Oo(e, !0); const p = Ko(e); const f = e.subTree; e.subTree = p, b(f, p, m(f.el), J(f), e, i, o), t.el = p.el, d === null && ea(e, p.el), r && Co(r, i), (u = t.props && t.props.onVnodeUpdated) && Co((() => Fa(u, l, t, c)), i), __VUE_PROD_DEVTOOLS__ && Vn(e);
            } else {
              let a; const { el: s, props: l } = t; const {
                bm: c, m: u, parent: d, root: p, type: f,
              } = e; const h = qr(t); if (Oo(e, !1), c && F(c), !h && (a = l && l.onVnodeBeforeMount) && Fa(a, d, t), Oo(e, !0), s && ne) { const t = () => { e.subTree = Ko(e), ne(s, e.subTree, e, i, null); }; h && f.__asyncHydrate ? f.__asyncHydrate(s, e, t) : t(); } else { p.ce && p.ce._injectChildStyle(f); const a = e.subTree = Ko(e); b(null, a, n, r, e, i, o), t.el = a.el; } if (u && Co(u, i), !h && (a = l && l.onVnodeMounted)) { const e = t; Co((() => Fa(a, d, e)), i); }(256 & t.shapeFlag || d && qr(d.vnode) && 256 & d.vnode.shapeFlag) && e.a && Co(e.a, i), e.isMounted = !0, __VUE_PROD_DEVTOOLS__ && jn(e), t = n = r = null;
            }
          }; e.scope.on(); const l = e.effect = new ye(s); e.scope.off(); const c = e.update = l.run.bind(l); const u = e.job = l.runIfDirty.bind(l); u.i = e, u.id = e.uid, l.scheduler = () => _n(u), Oo(e, !0), c();
        }; const V = (e, t, n) => { t.component = e; const r = e.vnode.props; e.vnode = t, e.next = null, (function (e, t, n, r) { const { props: i, attrs: o, vnode: { patchFlag: a } } = e; const s = Nt(i); const [l] = e.propsOptions; let c = !1; if (!(r || a > 0) || 16 & a) { let r; fo(e, t, i, o) && (c = !0); for (const o in s)t && (h(t, o) || (r = D(o)) !== o && h(t, r)) || (l ? !n || void 0 === n[o] && void 0 === n[r] || (i[o] = ho(l, s, o, void 0, e, !0)) : delete i[o]); if (o !== s) for (const e in o)t && h(t, e) || (delete o[e], c = !0); } else if (8 & a) { const n = e.vnode.dynamicProps; for (let r = 0; r < n.length; r++) { const a = n[r]; if (Xo(e.emitsOptions, a)) continue; const u = t[a]; if (l) if (h(o, a))u !== o[a] && (o[a] = u, c = !0); else { const t = I(a); i[t] = ho(l, s, t, u, e, !1); } else u !== o[a] && (o[a] = u, c = !0); } }c && We(e.attrs, 'set', ''); }(e, t.props, r, n)), _o(e, t.children, n), De(), kn(e), Re(); }; const B = (e, t, n, r, i, o, a, s, l = !1) => { const c = e && e.children; const u = e ? e.shapeFlag : 0; const d = t.children; const { patchFlag: p, shapeFlag: h } = t; if (p > 0) { if (128 & p) return void H(c, d, n, r, i, o, a, s, l); if (256 & p) return void q(c, d, n, r, i, o, a, s, l); }8 & h ? (16 & u && K(c, i, o), d !== c && f(n, d)) : 16 & u ? 16 & h ? H(c, d, n, r, i, o, a, s, l) : K(c, i, o, !0) : (8 & u && f(n, ''), 16 & h && C(d, n, r, i, o, a, s, l)); }; const q = (e, t, n, r, i, o, s, l, c) => { t = t || a; const u = (e = e || a).length; const d = t.length; const p = Math.min(u, d); let f; for (f = 0; f < p; f++) { const r = t[f] = c ? Ra(t[f]) : Da(t[f]); b(e[f], r, n, null, i, o, s, l, c); }u > d ? K(e, i, o, !0, !1, p) : C(t, n, r, i, o, s, l, c, p); }; const H = (e, t, n, r, i, o, s, l, c) => { let u = 0; const d = t.length; let p = e.length - 1; let f = d - 1; for (;u <= p && u <= f;) { const r = e[u]; const a = t[u] = c ? Ra(t[u]) : Da(t[u]); if (!Ta(r, a)) break; b(r, a, n, null, i, o, s, l, c), u++; } for (;u <= p && u <= f;) { const r = e[p]; const a = t[f] = c ? Ra(t[f]) : Da(t[f]); if (!Ta(r, a)) break; b(r, a, n, null, i, o, s, l, c), p--, f--; } if (u > p) { if (u <= f) { const e = f + 1; const a = e < d ? t[e].el : r; for (;u <= f;)b(null, t[u] = c ? Ra(t[u]) : Da(t[u]), n, a, i, o, s, l, c), u++; } } else if (u > f) for (;u <= p;)$(e[u], i, o, !0), u++; else { const h = u; const m = u; const v = new Map(); for (u = m; u <= f; u++) { const e = t[u] = c ? Ra(t[u]) : Da(t[u]); e.key != null && v.set(e.key, u); }let g; let y = 0; const w = f - m + 1; let S = !1; let x = 0; const E = new Array(w); for (u = 0; u < w; u++)E[u] = 0; for (u = h; u <= p; u++) { const r = e[u]; if (y >= w) { $(r, i, o, !0); continue; }let a; if (r.key != null)a = v.get(r.key); else for (g = m; g <= f; g++) if (E[g - m] === 0 && Ta(r, t[g])) { a = g; break; } void 0 === a ? $(r, i, o, !0) : (E[a - m] = u + 1, a >= x ? x = a : S = !0, b(r, t[a], n, null, i, o, s, l, c), y++); } const T = S ? (function (e) { const t = e.slice(); const n = [0]; let r; let i; let o; let a; let s; const l = e.length; for (r = 0; r < l; r++) { const l = e[r]; if (l !== 0) { if (i = n[n.length - 1], e[i] < l) { t[r] = i, n.push(r); continue; } for (o = 0, a = n.length - 1; o < a;)s = o + a >> 1, e[n[s]] < l ? o = s + 1 : a = s; l < e[n[o]] && (o > 0 && (t[r] = n[o - 1]), n[o] = r); } } for (o = n.length, a = n[o - 1]; o-- > 0;)n[o] = a, a = t[a]; return n; }(E)) : a; for (g = T.length - 1, u = w - 1; u >= 0; u--) { const e = m + u; const a = t[e]; const p = e + 1 < d ? t[e + 1].el : r; E[u] === 0 ? b(null, a, n, p, i, o, s, l, c) : S && (g < 0 || u !== T[g] ? U(a, n, p, 2) : g--); } } }; const U = (e, t, n, i, o = null) => {
          const {
            el: a, type: s, transition: l, children: c, shapeFlag: u,
          } = e; if (6 & u)U(e.component.subTree, t, n, i); else if (128 & u)e.suspense.move(t, n, i); else if (64 & u)s.move(e, t, n, ee); else if (s !== ca) if (s !== pa) if (i !== 2 && 1 & u && l) if (i === 0)l.beforeEnter(a), r(a, t, n), Co((() => l.enter(a)), o); else { const { leave: e, delayLeave: i, afterLeave: o } = l; const s = () => r(a, t, n); const c = () => { e(a, (() => { s(), o && o(); })); }; i ? i(a, s, c) : c(); } else r(a, t, n); else (({ el: e, anchor: t }, n, i) => { let o; for (;e && e !== t;)o = v(e), r(e, n, i), e = o; r(t, n, i); })(e, t, n); else { r(a, t, n); for (let e = 0; e < c.length; e++)U(c[e], t, n, i); r(e.anchor, t, n); }
        }; const $ = (e, t, n, r = !1, i = !1) => {
          const {
            type: o, props: a, ref: s, children: l, dynamicChildren: c, shapeFlag: u, patchFlag: d, dirs: p, cacheIndex: f,
          } = e; if (d === -2 && (i = !1), s != null && Lr(s, null, n, e, !0), f != null && (t.renderCache[f] = void 0), 256 & u) return void t.ctx.deactivate(e); const h = 1 & u && p; const m = !qr(e); let v; if (m && (v = a && a.onVnodeBeforeUnmount) && Fa(v, t, e), 6 & u)X(e.component, n, r); else { if (128 & u) return void e.suspense.unmount(n, r); h && Kn(e, null, t, 'beforeUnmount'), 64 & u ? e.type.remove(e, t, n, ee, r) : c && !c.hasOnce && (o !== ca || d > 0 && 64 & d) ? K(c, t, n, !1, !0) : (o === ca && 384 & d || !i && 16 & u) && K(l, t, n), r && W(e); }(m && (v = a && a.onVnodeUnmounted) || h) && Co((() => { v && Fa(v, t, e), h && Kn(e, null, t, 'unmounted'); }), n);
        }; const W = (e) => {
          const {
            type: t, el: n, anchor: r, transition: o,
          } = e; if (t === ca) return void Y(n, r); if (t === pa) return void (({ el: e, anchor: t }) => { let n; for (;e && e !== t;)n = v(e), i(e), e = n; i(t); })(e); const a = () => { i(n), o && !o.persisted && o.afterLeave && o.afterLeave(); }; if (1 & e.shapeFlag && o && !o.persisted) { const { leave: t, delayLeave: r } = o; const i = () => t(n, a); r ? r(e.el, a, i) : i(); } else a();
        }; const Y = (e, t) => { let n; for (;e !== t;)n = v(e), i(e), e = n; i(t); }; const X = (e, t, n) => {
          const {
            bum: r, scope: i, job: o, subTree: a, um: s, m: l, a: c,
          } = e; Do(l), Do(c), r && F(r), i.stop(), o && (o.flags |= 8, $(a, e, t, n)), s && Co(s, t), Co((() => { e.isUnmounted = !0; }), t), t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--, t.deps === 0 && t.resolve()), __VUE_PROD_DEVTOOLS__ && zn(e);
        }; const K = (e, t, n, r = !1, i = !1, o = 0) => { for (let a = o; a < e.length; a++)$(e[a], t, n, r, i); }; const J = (e) => { if (6 & e.shapeFlag) return J(e.component.subTree); if (128 & e.shapeFlag) return e.suspense.next(); const t = v(e.anchor || e.el); const n = t && t[Jn]; return n ? v(n) : t; }; let Q = !1; const Z = (e, t, n) => { e == null ? t._vnode && $(t._vnode, null, null, !0) : b(t._vnode || null, e, t, null, null, null, n), t._vnode = e, Q || (Q = !0, kn(), Mn(), Q = !1); }; const ee = {
          p: b, um: $, m: U, r: W, mt: N, mc: C, pc: B, pbc: k, n: J, o: e,
        }; let te; let ne; return t && ([te, ne] = t(ee)), { render: Z, hydrate: te, createApp: io(Z, te) };
      } function Ao({ type: e, props: t }, n) { return n === 'svg' && e === 'foreignObject' || n === 'mathml' && e === 'annotation-xml' && t && t.encoding && t.encoding.includes('html') ? void 0 : n; } function Oo({ effect: e, job: t }, n) { n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5); } function Po(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted; } function Io(e, t, n = !1) { const r = e.children; const i = t.children; if (m(r) && m(i)) for (let e = 0; e < r.length; e++) { const t = r[e]; let o = i[e]; 1 & o.shapeFlag && !o.dynamicChildren && ((o.patchFlag <= 0 || o.patchFlag === 32) && (o = i[e] = Ra(i[e]), o.el = t.el), n || o.patchFlag === -2 || Io(t, o)), o.type === ua && (o.el = t.el); } } function No(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : No(t); } function Do(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8; } const Ro = Symbol.for('v-scx'); const jo = () => so(Ro); function Vo(e, t) { return qo(e, null, t); } function Fo(e, t) { return qo(e, null, { flush: 'post' }); } function zo(e, t) { return qo(e, null, { flush: 'sync' }); } function Bo(e, t, n) { return qo(e, t, n); } function qo(e, t, n = o) {
        const {
          immediate: r, deep: i, flush: a, once: l,
        } = n; const c = { ...n }; const u = t && r || !t && a !== 'post'; let f; if (Qa) if (a === 'sync') { const e = jo(); f = e.__watcherHandles || (e.__watcherHandles = []); } else if (!u) { const e = () => {}; return e.stop = s, e.resume = s, e.pause = s, e; } const h = Ha; c.call = (e, t, n) => mn(e, h, t, n); let v = !1; a === 'post' ? c.scheduler = (e) => { Co(e, h && h.suspense); } : a !== 'sync' && (v = !0, c.scheduler = (e, t) => { t ? e() : _n(e); }), c.augmentJob = (e) => { t && (e.flags |= 4), v && (e.flags |= 2, h && (e.id = h.uid, e.i = h)); }; const g = (function (e, t, n = o) {
          const {
            immediate: r, deep: i, once: a, scheduler: l, augmentJob: c, call: u,
          } = n; const d = (e) => (i ? e : Pt(e) || !1 === i || i === 0 ? un(e, 1) : un(e)); let f; let h; let v; let g; let y = !1; let w = !1; if (Vt(e) ? (h = () => e.value, y = Pt(e)) : At(e) ? (h = () => d(e), y = !0) : m(e) ? (w = !0, y = e.some(((e) => At(e) || Pt(e))), h = () => e.map(((e) => (Vt(e) ? e.value : At(e) ? d(e) : b(e) ? u ? u(e, 2) : e() : void 0)))) : h = b(e) ? t ? u ? () => u(e, 2) : e : () => { if (v) { De(); try { v(); } finally { Re(); } } const t = sn; sn = f; try { return u ? u(e, 3, [g]) : e(g); } finally { sn = t; } } : s, t && i) { const e = h; const t = !0 === i ? 1 / 0 : i; h = () => un(e(), t); } const S = me(); const x = () => { f.stop(), S && S.active && p(S.effects, f); }; if (a && t) { const e = t; t = (...t) => { e(...t), x(); }; }let E = w ? new Array(e.length).fill(on) : on; const T = (e) => { if (1 & f.flags && (f.dirty || e)) if (t) { const e = f.run(); if (i || y || (w ? e.some(((e, t) => V(e, E[t]))) : V(e, E))) { v && v(); const n = sn; sn = f; try { const n = [e, E === on ? void 0 : w && E[0] === on ? [] : E, g]; u ? u(t, 3, n) : t(...n), E = e; } finally { sn = n; } } } else f.run(); }; return c && c(T), f = new ye(h), f.scheduler = l ? () => l(T, !1) : T, g = (e) => cn(e, !1, f), v = f.onStop = () => { const e = an.get(f); if (e) { if (u)u(e, 4); else for (const t of e)t(); an.delete(f); } }, t ? r ? T(!0) : E = f.run() : l ? l(T.bind(null, !0), !0) : f.run(), x.pause = f.pause.bind(f), x.resume = f.resume.bind(f), x.stop = x, x;
        }(e, t, c)); return Qa && (f ? f.push(g) : u && g()), g;
      } function Ho(e, t, n) { const r = this.proxy; const i = w(e) ? e.includes('.') ? Go(r, e) : () => r[e] : e.bind(r, r); let o; b(t) ? o = t : (o = t.handler, n = t); const a = Wa(this); const s = qo(i, o.bind(r), n); return a(), s; } function Go(e, t) { const n = t.split('.'); return () => { let t = e; for (let e = 0; e < n.length && t; e++)t = t[n[e]]; return t; }; } function Uo(e, t, n = o) { const r = Ga(); const i = I(t); const a = D(t); const s = $o(e, i); const l = Xt(((s, l) => { let c; let u; let d = o; return zo((() => { const t = e[i]; V(c, t) && (c = t, l()); })), { get: () => (s(), n.get ? n.get(c) : c), set(e) { const s = n.set ? n.set(e) : e; if (!(V(s, c) || d !== o && V(e, d))) return; const p = r.vnode.props; p && (t in p || i in p || a in p) && (`onUpdate:${t}` in p || `onUpdate:${i}` in p || `onUpdate:${a}` in p) || (c = e, l()), r.emit(`update:${t}`, s), V(e, s) && V(e, d) && !V(s, u) && l(), d = e, u = s; } }; })); return l[Symbol.iterator] = () => { let e = 0; return { next: () => (e < 2 ? { value: e++ ? s || o : l, done: !1 } : { done: !0 }) }; }, l; } const $o = (e, t) => (t === 'modelValue' || t === 'model-value' ? e.modelModifiers : e[`${t}Modifiers`] || e[`${I(t)}Modifiers`] || e[`${D(t)}Modifiers`]); function Wo(e, t, ...n) { if (e.isUnmounted) return; const r = e.vnode.props || o; let i = n; const a = t.startsWith('update:'); const s = a && $o(r, t.slice(7)); let l; s && (s.trim && (i = n.map(((e) => (w(e) ? e.trim() : e)))), s.number && (i = n.map(B))), __VUE_PROD_DEVTOOLS__ && (function (e, t, n) { Dn('component:emit', e.appContext.app, e, t, n); }(e, t, i)); let c = r[l = j(t)] || r[l = j(I(t))]; !c && a && (c = r[l = j(D(t))]), c && mn(c, e, 6, i); const u = r[`${l}Once`]; if (u) { if (e.emitted) { if (e.emitted[l]) return; } else e.emitted = {}; e.emitted[l] = !0, mn(u, e, 6, i); } } function Yo(e, t, n = !1) { const r = t.emitsCache; const i = r.get(e); if (void 0 !== i) return i; const o = e.emits; const a = {}; let s = !1; if (__VUE_OPTIONS_API__ && !b(e)) { const r = (e) => { const n = Yo(e, t, !0); n && (s = !0, d(a, n)); }; !n && t.mixins.length && t.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r); } return o || s ? (m(o) ? o.forEach(((e) => a[e] = null)) : d(a, o), x(e) && r.set(e, a), a) : (x(e) && r.set(e, null), null); } function Xo(e, t) { return !(!e || !c(t)) && (t = t.slice(2).replace(/Once$/, ''), h(e, t[0].toLowerCase() + t.slice(1)) || h(e, D(t)) || h(e, t)); } function Ko(e) {
        const {
          type: t, vnode: n, proxy: r, withProxy: i, propsOptions: [o], slots: a, attrs: s, emit: l, render: c, renderCache: d, props: p, data: f, setupState: h, ctx: m, inheritAttrs: v,
        } = e; const g = Gn(e); let y; let b; try { if (4 & n.shapeFlag) { const e = i || r; const t = e; y = Da(c.call(t, e, d, p, h, f, m)), b = s; } else { const e = t; y = Da(e.length > 1 ? e(p, { attrs: s, slots: a, emit: l }) : e(p, null)), b = t.props ? s : Jo(s); } } catch (t) { fa.length = 0, vn(t, e, 1), y = Ma(da); }let w = y; if (b && !1 !== v) { const e = Object.keys(b); const { shapeFlag: t } = w; e.length && 7 & t && (o && e.some(u) && (b = Qo(b, o)), w = Oa(w, b, !1, !0)); } return n.dirs && (w = Oa(w, null, !1, !0), w.dirs = w.dirs ? w.dirs.concat(n.dirs) : n.dirs), n.transition && Sr(w, n.transition), y = w, Gn(g), y;
      } const Jo = (e) => { let t; for (const n in e)(n === 'class' || n === 'style' || c(n)) && ((t || (t = {}))[n] = e[n]); return t; }; const Qo = (e, t) => { const n = {}; for (const r in e)u(r) && r.slice(9) in t || (n[r] = e[r]); return n; }; function Zo(e, t, n) { const r = Object.keys(t); if (r.length !== Object.keys(e).length) return !0; for (let i = 0; i < r.length; i++) { const o = r[i]; if (t[o] !== e[o] && !Xo(n, o)) return !0; } return !1; } function ea({ vnode: e, parent: t }, n) { for (;t;) { const r = t.subTree; if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el), r !== e) break; (e = t.vnode).el = n, t = t.parent; } } const ta = (e) => e.__isSuspense; let na = 0; const ra = {
        name: 'Suspense',
        __isSuspense: !0,
        process(e, t, n, r, i, o, a, s, l, c) {
          if (e == null)!(function (e, t, n, r, i, o, a, s, l) { const { p: c, o: { createElement: u } } = l; const d = u('div'); const p = e.suspense = oa(e, i, r, t, d, n, o, a, s, l); c(null, p.pendingBranch = e.ssContent, d, null, r, p, o, a), p.deps > 0 ? (ia(e, 'onPending'), ia(e, 'onFallback'), c(null, e.ssFallback, t, n, r, null, o, a), la(p, e.ssFallback)) : p.resolve(!1, !0); }(t, n, r, i, o, a, s, l, c)); else {
            if (o && o.deps > 0 && !e.suspense.isInFallback) return t.suspense = e.suspense, t.suspense.vnode = t, void (t.el = e.el); !(function (e, t, n, r, i, o, a, s, { p: l, um: c, o: { createElement: u } }) {
              const d = t.suspense = e.suspense; d.vnode = t, t.el = e.el; const p = t.ssContent; const f = t.ssFallback; const {
                activeBranch: h, pendingBranch: m, isInFallback: v, isHydrating: g,
              } = d; if (m)d.pendingBranch = p, Ta(p, m) ? (l(m, p, d.hiddenContainer, null, i, d, o, a, s), d.deps <= 0 ? d.resolve() : v && (g || (l(h, f, n, r, i, null, o, a, s), la(d, f)))) : (d.pendingId = na++, g ? (d.isHydrating = !1, d.activeBranch = m) : c(m, i, d), d.deps = 0, d.effects.length = 0, d.hiddenContainer = u('div'), v ? (l(null, p, d.hiddenContainer, null, i, d, o, a, s), d.deps <= 0 ? d.resolve() : (l(h, f, n, r, i, null, o, a, s), la(d, f))) : h && Ta(p, h) ? (l(h, p, n, r, i, d, o, a, s), d.resolve(!0)) : (l(null, p, d.hiddenContainer, null, i, d, o, a, s), d.deps <= 0 && d.resolve())); else if (h && Ta(p, h))l(h, p, n, r, i, d, o, a, s), la(d, p); else if (ia(t, 'onPending'), d.pendingBranch = p, 512 & p.shapeFlag ? d.pendingId = p.component.suspenseId : d.pendingId = na++, l(null, p, d.hiddenContainer, null, i, d, o, a, s), d.deps <= 0)d.resolve(); else { const { timeout: e, pendingId: t } = d; e > 0 ? setTimeout((() => { d.pendingId === t && d.fallback(f); }), e) : e === 0 && d.fallback(f); }
            }(e, t, n, r, i, a, s, l, c));
          }
        },
        hydrate(e, t, n, r, i, o, a, s, l) { const c = t.suspense = oa(t, r, n, e.parentNode, document.createElement('div'), null, i, o, a, s, !0); const u = l(e, c.pendingBranch = t.ssContent, n, c, o, a); return c.deps === 0 && c.resolve(!1, !0), u; },
        normalize(e) { const { shapeFlag: t, children: n } = e; const r = 32 & t; e.ssContent = aa(r ? n.default : n), e.ssFallback = r ? aa(n.fallback) : Ma(da); },
      }; function ia(e, t) { const n = e.props && e.props[t]; b(n) && n(); } function oa(e, t, n, r, i, o, a, s, l, c, u = !1) {
        const {
          p: d, m: p, um: f, n: h, o: { parentNode: m, remove: v },
        } = c; let g; const y = (function (e) { const t = e.props && e.props.suspensible; return t != null && !1 !== t; }(e)); y && t && t.pendingBranch && (g = t.pendingId, t.deps++); const b = e.props ? q(e.props.timeout) : void 0; const w = o; const S = {
          vnode: e,
          parent: t,
          parentComponent: n,
          namespace: a,
          container: r,
          hiddenContainer: i,
          deps: 0,
          pendingId: na++,
          timeout: typeof b === 'number' ? b : -1,
          activeBranch: null,
          pendingBranch: null,
          isInFallback: !u,
          isHydrating: u,
          isUnmounted: !1,
          effects: [],
          resolve(e = !1, n = !1) {
            const {
              vnode: r, activeBranch: i, pendingBranch: a, pendingId: s, effects: l, parentComponent: c, container: u,
            } = S; let d = !1; S.isHydrating ? S.isHydrating = !1 : e || (d = i && a.transition && a.transition.mode === 'out-in', d && (i.transition.afterLeave = () => { s === S.pendingId && (p(a, u, o === w ? h(i) : o, 0), Ln(l)); }), i && (m(i.el) === u && (o = h(i)), f(i, c, S, !0)), d || p(a, u, o, 0)), la(S, a), S.pendingBranch = null, S.isInFallback = !1; let v = S.parent; let b = !1; for (;v;) { if (v.pendingBranch) { v.effects.push(...l), b = !0; break; }v = v.parent; }b || d || Ln(l), S.effects = [], y && t && t.pendingBranch && g === t.pendingId && (t.deps--, t.deps !== 0 || n || t.resolve()), ia(r, 'onResolve');
          },
          fallback(e) {
            if (!S.pendingBranch) return; const {
              vnode: t, activeBranch: n, parentComponent: r, container: i, namespace: o,
            } = S; ia(t, 'onFallback'); const a = h(n); const c = () => { S.isInFallback && (d(null, e, i, a, r, null, o, s, l), la(S, e)); }; const u = e.transition && e.transition.mode === 'out-in'; u && (n.transition.afterLeave = c), S.isInFallback = !0, f(n, r, null, !0), u || c();
          },
          move(e, t, n) { S.activeBranch && p(S.activeBranch, e, t, n), S.container = e; },
          next: () => S.activeBranch && h(S.activeBranch),
          registerDep(e, t, n) { const r = !!S.pendingBranch; r && S.deps++; const i = e.vnode.el; e.asyncDep.catch(((t) => { vn(t, e, 0); })).then(((o) => { if (e.isUnmounted || S.isUnmounted || S.pendingId !== e.suspenseId) return; e.asyncResolved = !0; const { vnode: s } = e; es(e, o, !1), i && (s.el = i); const l = !i && e.subTree.el; t(e, s, m(i || e.subTree.el), i ? null : h(e.subTree), S, a, n), l && v(l), ea(e, s.el), r && --S.deps == 0 && S.resolve(); })); },
          unmount(e, t) { S.isUnmounted = !0, S.activeBranch && f(S.activeBranch, n, e, t), S.pendingBranch && f(S.pendingBranch, n, e, t); },
        }; return S;
      } function aa(e) { let t; if (b(e)) { const n = ya && e._c; n && (e._d = !1, ma()), e = e(), n && (e._d = !0, t = ha, va()); } if (m(e)) { const t = (function (e) { let t; for (let n = 0; n < e.length; n++) { const r = e[n]; if (!Ea(r)) return; if (r.type !== da || r.children === 'v-if') { if (t) return; t = r; } } return t; }(e)); e = t; } return e = Da(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter(((t) => t !== e))), e; } function sa(e, t) { t && t.pendingBranch ? m(e) ? t.effects.push(...e) : t.effects.push(e) : Ln(e); } function la(e, t) { e.activeBranch = t; const { vnode: n, parentComponent: r } = e; let i = t.el; for (;!i && t.component;)i = (t = t.component.subTree).el; n.el = i, r && r.subTree === n && (r.vnode.el = i, ea(r, i)); } const ca = Symbol.for('v-fgt'); const ua = Symbol.for('v-txt'); const da = Symbol.for('v-cmt'); const pa = Symbol.for('v-stc'); const fa = []; let ha = null; function ma(e = !1) { fa.push(ha = e ? null : []); } function va() { fa.pop(), ha = fa[fa.length - 1] || null; }let ga; let ya = 1; function ba(e, t = !1) { ya += e, e < 0 && ha && t && (ha.hasOnce = !0); } function wa(e) { return e.dynamicChildren = ya > 0 ? ha || a : null, va(), ya > 0 && ha && ha.push(e), e; } function Sa(e, t, n, r, i, o) { return wa(ka(e, t, n, r, i, o, !0)); } function xa(e, t, n, r, i) { return wa(Ma(e, t, n, r, i, !0)); } function Ea(e) { return !!e && !0 === e.__v_isVNode; } function Ta(e, t) { return e.type === t.type && e.key === t.key; } function _a(e) { ga = e; } const Ca = ({ key: e }) => (e != null ? e : null); const La = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e === 'number' && (e = `${e}`), e != null ? w(e) || Vt(e) || b(e) ? {
        i: qn, r: e, k: t, f: !!n,
      } : e : null); function ka(e, t = null, n = null, r = 0, i = null, o = (e === ca ? 0 : 1), a = !1, s = !1) {
        const l = {
          __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && Ca(t), ref: t && La(t), scopeId: Hn, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: o, patchFlag: r, dynamicProps: i, dynamicChildren: null, appContext: null, ctx: qn,
        }; return s ? (ja(l, n), 128 & o && e.normalize(l)) : n && (l.shapeFlag |= w(n) ? 8 : 16), ya > 0 && !a && ha && (l.patchFlag > 0 || 6 & o) && l.patchFlag !== 32 && ha.push(l), l;
      } const Ma = function (e, t = null, n = null, r = 0, i = null, o = !1) { if (e && e !== mi || (e = da), Ea(e)) { const r = Oa(e, t, !0); return n && ja(r, n), ya > 0 && !o && ha && (6 & r.shapeFlag ? ha[ha.indexOf(e)] = r : ha.push(r)), r.patchFlag = -2, r; } if (a = e, b(a) && '__vccOpts' in a && (e = e.__vccOpts), t) { t = Aa(t); let{ class: e, style: n } = t; e && !w(e) && (t.class = J(e)), x(n) && (It(n) && !m(n) && (n = { ...n }), t.style = $(n)); } let a; return ka(e, t, n, r, i, w(e) ? 1 : ta(e) ? 128 : Qn(e) ? 64 : x(e) ? 4 : b(e) ? 2 : 0, o, !0); }; function Aa(e) { return e ? It(e) || po(e) ? ({ ...e }) : e : null; } function Oa(e, t, n = !1, r = !1) {
        const {
          props: i, ref: o, patchFlag: a, children: s, transition: l,
        } = e; const c = t ? Va(i || {}, t) : i; const u = {
          __v_isVNode: !0, __v_skip: !0, type: e.type, props: c, key: c && Ca(c), ref: t && t.ref ? n && o ? m(o) ? o.concat(La(t)) : [o, La(t)] : La(t) : o, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: s, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== ca ? a === -1 ? 16 : 16 | a : a, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: l, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Oa(e.ssContent), ssFallback: e.ssFallback && Oa(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce,
        }; return l && r && Sr(u, l.clone(u)), u;
      } function Pa(e = ' ', t = 0) { return Ma(ua, null, e, t); } function Ia(e, t) { const n = Ma(pa, null, e); return n.staticCount = t, n; } function Na(e = '', t = !1) { return t ? (ma(), xa(da, null, e)) : Ma(da, null, e); } function Da(e) { return e == null || typeof e === 'boolean' ? Ma(da) : m(e) ? Ma(ca, null, e.slice()) : Ea(e) ? Ra(e) : Ma(ua, null, String(e)); } function Ra(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Oa(e); } function ja(e, t) { let n = 0; const { shapeFlag: r } = e; if (t == null)t = null; else if (m(t))n = 16; else if (typeof t === 'object') { if (65 & r) { const n = t.default; return void (n && (n._c && (n._d = !1), ja(e, n()), n._c && (n._d = !0))); } { n = 32; const r = t._; r || po(t) ? r === 3 && qn && (qn.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) : t._ctx = qn; } } else b(t) ? (t = { default: t, _ctx: qn }, n = 32) : (t = String(t), 64 & r ? (n = 16, t = [Pa(t)]) : n = 8); e.children = t, e.shapeFlag |= n; } function Va(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n]; for (const e in r) if (e === 'class')t.class !== r.class && (t.class = J([t.class, r.class])); else if (e === 'style')t.style = $([t.style, r.style]); else if (c(e)) { const n = t[e]; const i = r[e]; !i || n === i || m(n) && n.includes(i) || (t[e] = n ? [].concat(n, i) : i); } else e !== '' && (t[e] = r[e]); } return t; } function Fa(e, t, n, r = null) { mn(e, t, 7, [n, r]); } const za = no(); let Ba = 0; function qa(e, t, n) {
        const r = e.type; const i = (t ? t.appContext : e.appContext) || za; const a = {
          uid: Ba++, vnode: e, type: r, parent: t, appContext: i, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new fe(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(i.provides), ids: t ? t.ids : ['', 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: vo(r, i), emitsOptions: Yo(r, i), emit: null, emitted: null, propsDefaults: o, inheritAttrs: r.inheritAttrs, ctx: o, data: o, props: o, attrs: o, slots: o, refs: o, setupState: o, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null,
        }; return a.ctx = { _: a }, a.root = t ? t.root : a, a.emit = Wo.bind(null, a), e.ce && e.ce(a), a;
      }let Ha = null; const Ga = () => Ha || qn; let Ua; let $a; { const e = G(); const t = (t, n) => { let r; return (r = e[t]) || (r = e[t] = []), r.push(n), (e) => { r.length > 1 ? r.forEach(((t) => t(e))) : r[0](e); }; }; Ua = t('__VUE_INSTANCE_SETTERS__', ((e) => Ha = e)), $a = t('__VUE_SSR_SETTERS__', ((e) => Qa = e)); } const Wa = (e) => { const t = Ha; return Ua(e), e.scope.on(), () => { e.scope.off(), Ua(t); }; }; const Ya = () => { Ha && Ha.scope.off(), Ua(null); }; function Xa(e) { return 4 & e.vnode.shapeFlag; }let Ka; let Ja; let Qa = !1; function Za(e, t = !1, n = !1) { t && $a(t); const { props: r, children: i } = e.vnode; const o = Xa(e); !(function (e, t, n, r = !1) { const i = {}; const o = uo(); e.propsDefaults = Object.create(null), fo(e, t, i, o); for (const t in e.propsOptions[0])t in i || (i[t] = void 0); n ? e.props = r ? i : Ct(i) : e.type.props ? e.props = i : e.props = o, e.attrs = o; }(e, r, o, t)), To(e, i, n); const a = o ? (function (e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, ki); const { setup: r } = n; if (r) { De(); const n = e.setupContext = r.length > 1 ? os(e) : null; const i = Wa(e); const o = hn(r, e, 0, [e.props, n]); const a = E(o); if (Re(), i(), !a && !e.sp || qr(e) || _r(e), a) { if (o.then(Ya, Ya), t) return o.then(((n) => { es(e, n, t); })).catch(((t) => { vn(t, e, 0); })); e.asyncDep = o; } else es(e, o, t); } else rs(e, t); }(e, t)) : void 0; return t && $a(!1), a; } function es(e, t, n) { b(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : x(t) && (__VUE_PROD_DEVTOOLS__ && (e.devtoolsRawSetupState = t), e.setupState = Wt(t)), rs(e, n); } function ts(e) { Ka = e, Ja = (e) => { e.render._rc && (e.withProxy = new Proxy(e.ctx, Mi)); }; } const ns = () => !Ka; function rs(e, t, n) {
        const r = e.type; if (!e.render) {
          if (!t && Ka && !r.render) {
            const t = r.template || __VUE_OPTIONS_API__ && Yi(e).template; if (t) {
              const { isCustomElement: n, compilerOptions: i } = e.appContext.config; const { delimiters: o, compilerOptions: a } = r; const s = {
                isCustomElement: n, delimiters: o, ...i, ...a,
              }; r.render = Ka(t, s);
            }
          }e.render = r.render || s, Ja && Ja(e);
        } if (__VUE_OPTIONS_API__) {
          const t = Wa(e); De(); try {
            !(function (e) {
              const t = Yi(e); const n = e.proxy; const r = e.ctx; Ui = !1, t.beforeCreate && $i(t.beforeCreate, e, 'bc'); const {
                data: i, computed: o, methods: a, watch: l, provide: c, inject: u, created: d, beforeMount: p, mounted: f, beforeUpdate: h, updated: v, activated: g, deactivated: y, beforeDestroy: w, beforeUnmount: S, destroyed: E, unmounted: T, render: _, renderTracked: C, renderTriggered: L, errorCaptured: k, serverPrefetch: M, expose: A, inheritAttrs: O, components: P, directives: I, filters: N,
              } = t; if (u && (function (e, t) {
                m(e) && (e = Qi(e)); for (const n in e) {
                  const r = e[n]; let i; i = x(r) ? 'default' in r ? so(r.from || n, r.default, !0) : so(r.from || n) : so(r), Vt(i) ? Object.defineProperty(t, n, {
                    enumerable: !0, configurable: !0, get: () => i.value, set: (e) => i.value = e,
                  }) : t[n] = i;
                }
              }(u, r)), a) for (const e in a) { const t = a[e]; b(t) && (r[e] = t.bind(n)); } if (i) { const t = i.call(n, n); x(t) && (e.data = _t(t)); } if (Ui = !0, o) {
                for (const e in o) {
                  const t = o[e]; const i = b(t) ? t.bind(n, n) : b(t.get) ? t.get.bind(n, n) : s; const a = !b(t) && b(t.set) ? t.set.bind(n) : s; const l = ls({ get: i, set: a }); Object.defineProperty(r, e, {
                    enumerable: !0, configurable: !0, get: () => l.value, set: (e) => l.value = e,
                  });
                }
              } if (l) for (const e in l)Wi(l[e], r, n, e); if (c) { const e = b(c) ? c.call(n) : c; Reflect.ownKeys(e).forEach(((t) => { ao(t, e[t]); })); } function D(e, t) { m(t) ? t.forEach(((t) => e(t.bind(n)))) : t && e(t.bind(n)); } if (d && $i(d, e, 'c'), D(ni, p), D(ri, f), D(ii, h), D(oi, v), D(Yr, g), D(Xr, y), D(di, k), D(ui, C), D(ci, L), D(ai, S), D(si, T), D(li, M), m(A)) if (A.length) { const t = e.exposed || (e.exposed = {}); A.forEach(((e) => { Object.defineProperty(t, e, { get: () => n[e], set: (t) => n[e] = t }); })); } else e.exposed || (e.exposed = {}); _ && e.render === s && (e.render = _), O != null && (e.inheritAttrs = O), P && (e.components = P), I && (e.directives = I), M && _r(e);
            }(e));
          } finally { Re(), t(); }
        }
      } const is = { get: (e, t) => ($e(e, 0, ''), e[t]) }; function os(e) {
        return {
          attrs: new Proxy(e.attrs, is), slots: e.slots, emit: e.emit, expose: (t) => { e.exposed = t || {}; },
        };
      } function as(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Wt(Dt(e.exposed)), { get: (t, n) => (n in t ? t[n] : n in Ci ? Ci[n](e) : void 0), has: (e, t) => t in e || t in Ci })) : e.proxy; } function ss(e, t = !0) { return b(e) ? e.displayName || e.name : e.name || t && e.__name; } const ls = (e, t) => { const n = (function (e, t, n = !1) { let r; let i; return b(e) ? r = e : (r = e.get, i = e.set), new tn(r, i, n); }(e, 0, Qa)); return n; }; function cs(e, t, n) { const r = arguments.length; return r === 2 ? x(t) && !m(t) ? Ea(t) ? Ma(e, null, [t]) : Ma(e, t) : Ma(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Ea(n) && (n = [n]), Ma(e, t, n)); } function us() {} function ds(e, t, n, r) { const i = n[r]; if (i && ps(i, e)) return i; const o = t(); return o.memo = e.slice(), o.cacheIndex = r, n[r] = o; } function ps(e, t) { const n = e.memo; if (n.length != t.length) return !1; for (let e = 0; e < n.length; e++) if (V(n[e], t[e])) return !1; return ya > 0 && ha && ha.push(e), !0; } const fs = '3.5.13'; const hs = s; const ms = {
        sp: 'serverPrefetch hook', bc: 'beforeCreate hook', c: 'created hook', bm: 'beforeMount hook', m: 'mounted hook', bu: 'beforeUpdate hook', u: 'updated', bum: 'beforeUnmount hook', um: 'unmounted hook', a: 'activated hook', da: 'deactivated hook', ec: 'errorCaptured hook', rtc: 'renderTracked hook', rtg: 'renderTriggered hook', 0: 'setup function', 1: 'render function', 2: 'watcher getter', 3: 'watcher callback', 4: 'watcher cleanup function', 5: 'native event handler', 6: 'component event handler', 7: 'vnode hook', 8: 'directive hook', 9: 'transition hook', 10: 'app errorHandler', 11: 'app warnHandler', 12: 'ref function', 13: 'async component loader', 14: 'scheduler flush', 15: 'component update', 16: 'app unmount cleanup function',
      }; const vs = Pn; const gs = Rn; const ys = {
        createComponentInstance: qa, setupComponent: Za, renderComponentRoot: Ko, setCurrentRenderingInstance: Gn, isVNode: Ea, normalizeVNode: Da, getComponentPublicInstance: as, ensureValidVNode: Ei, pushWarningContext(e) { dn.push(e); }, popWarningContext() { dn.pop(); },
      }; const bs = null; const ws = null; const Ss = null; let xs; const Es = typeof window !== 'undefined' && window.trustedTypes; if (Es) try { xs = Es.createPolicy('vue', { createHTML: (e) => e }); } catch (e) {} const Ts = xs ? (e) => xs.createHTML(e) : (e) => e; const _s = typeof document !== 'undefined' ? document : null; const Cs = _s && _s.createElement('template'); const Ls = {
        insert: (e, t, n) => { t.insertBefore(e, n || null); }, remove: (e) => { const t = e.parentNode; t && t.removeChild(e); }, createElement: (e, t, n, r) => { const i = t === 'svg' ? _s.createElementNS('http://www.w3.org/2000/svg', e) : t === 'mathml' ? _s.createElementNS('http://www.w3.org/1998/Math/MathML', e) : n ? _s.createElement(e, { is: n }) : _s.createElement(e); return e === 'select' && r && r.multiple != null && i.setAttribute('multiple', r.multiple), i; }, createText: (e) => _s.createTextNode(e), createComment: (e) => _s.createComment(e), setText: (e, t) => { e.nodeValue = t; }, setElementText: (e, t) => { e.textContent = t; }, parentNode: (e) => e.parentNode, nextSibling: (e) => e.nextSibling, querySelector: (e) => _s.querySelector(e), setScopeId(e, t) { e.setAttribute(t, ''); }, insertStaticContent(e, t, n, r, i, o) { const a = n ? n.previousSibling : t.lastChild; if (i && (i === o || i.nextSibling)) for (;t.insertBefore(i.cloneNode(!0), n), i !== o && (i = i.nextSibling););else { Cs.innerHTML = Ts(r === 'svg' ? `<svg>${e}</svg>` : r === 'mathml' ? `<math>${e}</math>` : e); const i = Cs.content; if (r === 'svg' || r === 'mathml') { const e = i.firstChild; for (;e.firstChild;)i.appendChild(e.firstChild); i.removeChild(e); }t.insertBefore(i, n); } return [a ? a.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]; },
      }; const ks = 'transition'; const Ms = 'animation'; const As = Symbol('_vtc'); const Os = {
        name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String,
      }; const Ps = { ...fr, ...Os }; const Is = ((e) => (e.displayName = 'Transition', e.props = Ps, e))(((e, { slots: t }) => cs(vr, Rs(e), t))); const Ns = (e, t = []) => { m(e) ? e.forEach(((e) => e(...t))) : e && e(...t); }; const Ds = (e) => !!e && (m(e) ? e.some(((e) => e.length > 1)) : e.length > 1); function Rs(e) {
        const t = {}; for (const n in e)n in Os || (t[n] = e[n]); if (!1 === e.css) return t; const {
          name: n = 'v', type: r, duration: i, enterFromClass: o = `${n}-enter-from`, enterActiveClass: a = `${n}-enter-active`, enterToClass: s = `${n}-enter-to`, appearFromClass: l = o, appearActiveClass: c = a, appearToClass: u = s, leaveFromClass: p = `${n}-leave-from`, leaveActiveClass: f = `${n}-leave-active`, leaveToClass: h = `${n}-leave-to`,
        } = e; const m = (function (e) { if (e == null) return null; if (x(e)) return [js(e.enter), js(e.leave)]; { const t = js(e); return [t, t]; } }(i)); const v = m && m[0]; const g = m && m[1]; const {
          onBeforeEnter: y, onEnter: b, onEnterCancelled: w, onLeave: S, onLeaveCancelled: E, onBeforeAppear: T = y, onAppear: _ = b, onAppearCancelled: C = w,
        } = t; const L = (e, t, n, r) => { e._enterCancelled = r, Fs(e, t ? u : s), Fs(e, t ? c : a), n && n(); }; const k = (e, t) => { e._isLeaving = !1, Fs(e, p), Fs(e, h), Fs(e, f), t && t(); }; const M = (e) => (t, n) => { const i = e ? _ : b; const a = () => L(t, e, n); Ns(i, [t, a]), zs((() => { Fs(t, e ? l : o), Vs(t, e ? u : s), Ds(i) || qs(t, r, v, a); })); }; return d(t, {
          onBeforeEnter(e) { Ns(y, [e]), Vs(e, o), Vs(e, a); }, onBeforeAppear(e) { Ns(T, [e]), Vs(e, l), Vs(e, c); }, onEnter: M(!1), onAppear: M(!0), onLeave(e, t) { e._isLeaving = !0; const n = () => k(e, t); Vs(e, p), e._enterCancelled ? (Vs(e, f), $s()) : ($s(), Vs(e, f)), zs((() => { e._isLeaving && (Fs(e, p), Vs(e, h), Ds(S) || qs(e, r, g, n)); })), Ns(S, [e, n]); }, onEnterCancelled(e) { L(e, !1, void 0, !0), Ns(w, [e]); }, onAppearCancelled(e) { L(e, !0, void 0, !0), Ns(C, [e]); }, onLeaveCancelled(e) { k(e), Ns(E, [e]); },
        });
      } function js(e) { return q(e); } function Vs(e, t) { t.split(/\s+/).forEach(((t) => t && e.classList.add(t))), (e[As] || (e[As] = new Set())).add(t); } function Fs(e, t) { t.split(/\s+/).forEach(((t) => t && e.classList.remove(t))); const n = e[As]; n && (n.delete(t), n.size || (e[As] = void 0)); } function zs(e) { requestAnimationFrame((() => { requestAnimationFrame(e); })); }let Bs = 0; function qs(e, t, n, r) { const i = e._endId = ++Bs; const o = () => { i === e._endId && r(); }; if (n != null) return setTimeout(o, n); const { type: a, timeout: s, propCount: l } = Hs(e, t); if (!a) return r(); const c = `${a}end`; let u = 0; const d = () => { e.removeEventListener(c, p), o(); }; const p = (t) => { t.target === e && ++u >= l && d(); }; setTimeout((() => { u < l && d(); }), s + 1), e.addEventListener(c, p); } function Hs(e, t) {
        const n = window.getComputedStyle(e); const r = (e) => (n[e] || '').split(', '); const i = r(`${ks}Delay`); const o = r(`${ks}Duration`); const a = Gs(i, o); const s = r(`${Ms}Delay`); const l = r(`${Ms}Duration`); const c = Gs(s, l); let u = null; let d = 0; let p = 0; return t === ks ? a > 0 && (u = ks, d = a, p = o.length) : t === Ms ? c > 0 && (u = Ms, d = c, p = l.length) : (d = Math.max(a, c), u = d > 0 ? a > c ? ks : Ms : null, p = u ? u === ks ? o.length : l.length : 0), {
          type: u, timeout: d, propCount: p, hasTransform: u === ks && /\b(transform|all)(,|$)/.test(r(`${ks}Property`).toString()),
        };
      } function Gs(e, t) { for (;e.length < t.length;)e = e.concat(e); return Math.max(...t.map(((t, n) => Us(t) + Us(e[n])))); } function Us(e) { return e === 'auto' ? 0 : 1e3 * Number(e.slice(0, -1).replace(',', '.')); } function $s() { return document.body.offsetHeight; } const Ws = Symbol('_vod'); const Ys = Symbol('_vsh'); const Xs = {
        beforeMount(e, { value: t }, { transition: n }) { e[Ws] = e.style.display === 'none' ? '' : e.style.display, n && t ? n.beforeEnter(e) : Ks(e, t); }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e); }, updated(e, { value: t, oldValue: n }, { transition: r }) { !t != !n && (r ? t ? (r.beforeEnter(e), Ks(e, !0), r.enter(e)) : r.leave(e, (() => { Ks(e, !1); })) : Ks(e, t)); }, beforeUnmount(e, { value: t }) { Ks(e, t); },
      }; function Ks(e, t) { e.style.display = t ? e[Ws] : 'none', e[Ys] = !t; } const Js = Symbol(''); function Qs(e) { const t = Ga(); if (!t) return; const n = t.ut = (n = e(t.proxy)) => { Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(((e) => el(e, n))); }; const r = () => { const r = e(t.proxy); t.ce ? el(t.ce, r) : Zs(t.subTree, r), n(r); }; ii((() => { Ln(r); })), ri((() => { Bo(r, s, { flush: 'post' }); const e = new MutationObserver(r); e.observe(t.subTree.el.parentNode, { childList: !0 }), si((() => e.disconnect())); })); } function Zs(e, t) { if (128 & e.shapeFlag) { const n = e.suspense; e = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push((() => { Zs(n.activeBranch, t); })); } for (;e.component;)e = e.component.subTree; if (1 & e.shapeFlag && e.el)el(e.el, t); else if (e.type === ca)e.children.forEach(((e) => Zs(e, t))); else if (e.type === pa) { let{ el: n, anchor: r } = e; for (;n && (el(n, t), n !== r);)n = n.nextSibling; } } function el(e, t) { if (e.nodeType === 1) { const n = e.style; let r = ''; for (const e in t)n.setProperty(`--${e}`, t[e]), r += `--${e}: ${t[e]};`; n[Js] = r; } } const tl = /(^|;)\s*display\s*:/; const nl = /\s*!important$/; function rl(e, t, n) { if (m(n))n.forEach(((n) => rl(e, t, n))); else if (n == null && (n = ''), t.startsWith('--'))e.setProperty(t, n); else { const r = (function (e, t) { const n = ol[t]; if (n) return n; let r = I(t); if (r !== 'filter' && r in e) return ol[t] = r; r = R(r); for (let n = 0; n < il.length; n++) { const i = il[n] + r; if (i in e) return ol[t] = i; } return t; }(e, t)); nl.test(n) ? e.setProperty(D(r), n.replace(nl, ''), 'important') : e[r] = n; } } const il = ['Webkit', 'Moz', 'ms']; const ol = {}; const al = 'http://www.w3.org/1999/xlink'; function sl(e, t, n, r, i, o = re(t)) { r && t.startsWith('xlink:') ? n == null ? e.removeAttributeNS(al, t.slice(6, t.length)) : e.setAttributeNS(al, t, n) : n == null || o && !ie(n) ? e.removeAttribute(t) : e.setAttribute(t, o ? '' : S(n) ? String(n) : n); } function ll(e, t, n, r, i) { if (t === 'innerHTML' || t === 'textContent') return void (n != null && (e[t] = t === 'innerHTML' ? Ts(n) : n)); const o = e.tagName; if (t === 'value' && o !== 'PROGRESS' && !o.includes('-')) { const r = o === 'OPTION' ? e.getAttribute('value') || '' : e.value; const i = n == null ? e.type === 'checkbox' ? 'on' : '' : String(n); return r === i && '_value' in e || (e.value = i), n == null && e.removeAttribute(t), void (e._value = n); }let a = !1; if (n === '' || n == null) { const r = typeof e[t]; r === 'boolean' ? n = ie(n) : n == null && r === 'string' ? (n = '', a = !0) : r === 'number' && (n = 0, a = !0); } try { e[t] = n; } catch (e) {}a && e.removeAttribute(i || t); } function cl(e, t, n, r) { e.addEventListener(t, n, r); } const ul = Symbol('_vei'); const dl = /(?:Once|Passive|Capture)$/; let pl = 0; const fl = Promise.resolve(); const hl = () => pl || (fl.then((() => pl = 0)), pl = Date.now()); const ml = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123; const vl = {}; function gl(e, t, n) { const r = Er(e, t); L(r) && d(r, t); class i extends wl {constructor(e) { super(r, e, n); }} return i.def = r, i; } const yl = (e, t) => gl(e, t, ac); const bl = typeof HTMLElement !== 'undefined' ? HTMLElement : class {}; class wl extends bl {
        constructor(e, t = {}, n = oc) { super(), this._def = e, this._props = t, this._createApp = n, this._isVueCE = !0, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = !1, this._resolved = !1, this._numberProps = null, this._styleChildren = new WeakSet(), this._ob = null, this.shadowRoot && n !== oc ? this._root = this.shadowRoot : !1 !== e.shadowRoot ? (this.attachShadow({ mode: 'open' }), this._root = this.shadowRoot) : this._root = this, this._def.__asyncLoader || this._resolveProps(this._def); }

        connectedCallback() { if (!this.isConnected) return; this.shadowRoot || this._parseSlots(), this._connected = !0; let e = this; for (;e = e && (e.parentNode || e.host);) if (e instanceof wl) { this._parent = e; break; } this._instance || (this._resolved ? (this._setParent(), this._update()) : e && e._pendingResolve ? this._pendingResolve = e._pendingResolve.then((() => { this._pendingResolve = void 0, this._resolveDef(); })) : this._resolveDef()); }

        _setParent(e = this._parent) { e && (this._instance.parent = e._instance, this._instance.provides = e._instance.provides); }

        disconnectedCallback() { this._connected = !1, Tn((() => { this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null); })); }

        _resolveDef() { if (this._pendingResolve) return; for (let e = 0; e < this.attributes.length; e++) this._setAttr(this.attributes[e].name); this._ob = new MutationObserver(((e) => { for (const t of e) this._setAttr(t.attributeName); })), this._ob.observe(this, { attributes: !0 }); const e = (e, t = !1) => { this._resolved = !0, this._pendingResolve = void 0; const { props: n, styles: r } = e; let i; if (n && !m(n)) for (const e in n) { const t = n[e]; (t === Number || t && t.type === Number) && (e in this._props && (this._props[e] = q(this._props[e])), (i || (i = Object.create(null)))[I(e)] = !0); } this._numberProps = i, t && this._resolveProps(e), this.shadowRoot && this._applyStyles(r), this._mount(e); }; const t = this._def.__asyncLoader; t ? this._pendingResolve = t().then(((t) => e(this._def = t, !0))) : e(this._def); }

        _mount(e) { __VUE_PROD_DEVTOOLS__ && !e.name && (e.name = 'VueElement'), this._app = this._createApp(e), e.configureApp && e.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root); const t = this._instance && this._instance.exposed; if (t) for (const e in t)h(this, e) || Object.defineProperty(this, e, { get: () => Gt(t[e]) }); }

        _resolveProps(e) { const { props: t } = e; const n = m(t) ? t : Object.keys(t || {}); for (const e of Object.keys(this))e[0] !== '_' && n.includes(e) && this._setProp(e, this[e]); for (const e of n.map(I))Object.defineProperty(this, e, { get() { return this._getProp(e); }, set(t) { this._setProp(e, t, !0, !0); } }); }

        _setAttr(e) { if (e.startsWith('data-v-')) return; const t = this.hasAttribute(e); let n = t ? this.getAttribute(e) : vl; const r = I(e); t && this._numberProps && this._numberProps[r] && (n = q(n)), this._setProp(r, n, !1, !0); }

        _getProp(e) { return this._props[e]; }

        _setProp(e, t, n = !0, r = !1) { if (t !== this._props[e] && (t === vl ? delete this._props[e] : (this._props[e] = t, e === 'key' && this._app && (this._app._ceVNode.key = t)), r && this._instance && this._update(), n)) { const n = this._ob; n && n.disconnect(), !0 === t ? this.setAttribute(D(e), '') : typeof t === 'string' || typeof t === 'number' ? this.setAttribute(D(e), `${t}`) : t || this.removeAttribute(D(e)), n && n.observe(this, { attributes: !0 }); } }

        _update() { rc(this._createVNode(), this._root); }

        _createVNode() { const e = {}; this.shadowRoot || (e.onVnodeMounted = e.onVnodeUpdated = this._renderSlots.bind(this)); const t = Ma(this._def, d(e, this._props)); return this._instance || (t.ce = (e) => { this._instance = e, e.ce = this, e.isCE = !0; const t = (e, t) => { this.dispatchEvent(new CustomEvent(e, L(t[0]) ? ({ detail: t, ...t[0] }) : { detail: t })); }; e.emit = (e, ...n) => { t(e, n), D(e) !== e && t(D(e), n); }, this._setParent(); }), t; }

        _applyStyles(e, t) { if (!e) return; if (t) { if (t === this._def || this._styleChildren.has(t)) return; this._styleChildren.add(t); } const n = this._nonce; for (let t = e.length - 1; t >= 0; t--) { const r = document.createElement('style'); n && r.setAttribute('nonce', n), r.textContent = e[t], this.shadowRoot.prepend(r); } }

        _parseSlots() { const e = this._slots = {}; let t; for (;t = this.firstChild;) { const n = t.nodeType === 1 && t.getAttribute('slot') || 'default'; (e[n] || (e[n] = [])).push(t), this.removeChild(t); } }

        _renderSlots() { const e = (this._teleportTarget || this).querySelectorAll('slot'); const t = this._instance.type.__scopeId; for (let n = 0; n < e.length; n++) { const r = e[n]; const i = r.getAttribute('name') || 'default'; const o = this._slots[i]; const a = r.parentNode; if (o) for (const e of o) { if (t && e.nodeType === 1) { const n = `${t}-s`; const r = document.createTreeWalker(e, 1); let i; for (e.setAttribute(n, ''); i = r.nextNode();)i.setAttribute(n, ''); }a.insertBefore(e, r); } else for (;r.firstChild;)a.insertBefore(r.firstChild, r); a.removeChild(r); } }

        _injectChildStyle(e) { this._applyStyles(e.styles, e); }

        _removeChildStyle(e) {}
      } function Sl(e) { const t = Ga(); return t && t.ce || null; } function xl() { const e = Sl(); return e && e.shadowRoot; } function El(e = '$style') { { const t = Ga(); if (!t) return o; const n = t.type.__cssModules; if (!n) return o; return n[e] || o; } } const Tl = new WeakMap(); const _l = new WeakMap(); const Cl = Symbol('_moveCb'); const Ll = Symbol('_enterCb'); const
        kl = ((e) => (delete e.props.mode, e))({ name: 'TransitionGroup', props: { ...Ps, tag: String, moveClass: String }, setup(e, { slots: t }) { const n = Ga(); const r = dr(); let i; let o; return oi((() => { if (!i.length) return; const t = e.moveClass || `${e.name || 'v'}-move`; if (!(function (e, t, n) { const r = e.cloneNode(); const i = e[As]; i && i.forEach(((e) => { e.split(/\s+/).forEach(((e) => e && r.classList.remove(e))); })), n.split(/\s+/).forEach(((e) => e && r.classList.add(e))), r.style.display = 'none'; const o = t.nodeType === 1 ? t : t.parentNode; o.appendChild(r); const { hasTransform: a } = Hs(r); return o.removeChild(r), a; }(i[0].el, n.vnode.el, t))) return; i.forEach(Ml), i.forEach(Al); const r = i.filter(Ol); $s(), r.forEach(((e) => { const n = e.el; const r = n.style; Vs(n, t), r.transform = r.webkitTransform = r.transitionDuration = ''; const i = n[Cl] = (e) => { e && e.target !== n || e && !/transform$/.test(e.propertyName) || (n.removeEventListener('transitionend', i), n[Cl] = null, Fs(n, t)); }; n.addEventListener('transitionend', i); })); })), () => { const a = Nt(e); const s = Rs(a); const l = a.tag || ca; if (i = [], o) for (let e = 0; e < o.length; e++) { const t = o[e]; t.el && t.el instanceof Element && (i.push(t), Sr(t, yr(t, s, r, n)), Tl.set(t, t.el.getBoundingClientRect())); }o = t.default ? xr(t.default()) : []; for (let e = 0; e < o.length; e++) { const t = o[e]; t.key != null && Sr(t, yr(t, s, r, n)); } return Ma(l, null, o); }; } }); function Ml(e) { const t = e.el; t[Cl] && t[Cl](), t[Ll] && t[Ll](); } function Al(e) { _l.set(e, e.el.getBoundingClientRect()); } function Ol(e) { const t = Tl.get(e); const n = _l.get(e); const r = t.left - n.left; const i = t.top - n.top; if (r || i) { const t = e.el.style; return t.transform = t.webkitTransform = `translate(${r}px,${i}px)`, t.transitionDuration = '0s', e; } } const Pl = (e) => { const t = e.props['onUpdate:modelValue'] || !1; return m(t) ? (e) => F(t, e) : t; }; function Il(e) { e.target.composing = !0; } function Nl(e) { const t = e.target; t.composing && (t.composing = !1, t.dispatchEvent(new Event('input'))); } const Dl = Symbol('_assign'); const Rl = { created(e, { modifiers: { lazy: t, trim: n, number: r } }, i) { e[Dl] = Pl(i); const o = r || i.props && i.props.type === 'number'; cl(e, t ? 'change' : 'input', ((t) => { if (t.target.composing) return; let r = e.value; n && (r = r.trim()), o && (r = B(r)), e[Dl](r); })), n && cl(e, 'change', (() => { e.value = e.value.trim(); })), t || (cl(e, 'compositionstart', Il), cl(e, 'compositionend', Nl), cl(e, 'change', Nl)); }, mounted(e, { value: t }) { e.value = t == null ? '' : t; }, beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: r, trim: i, number: o } }, a) { if (e[Dl] = Pl(a), e.composing) return; const s = t == null ? '' : t; if ((!o && e.type !== 'number' || /^0\d/.test(e.value) ? e.value : B(e.value)) !== s) { if (document.activeElement === e && e.type !== 'range') { if (r && t === n) return; if (i && e.value.trim() === s) return; }e.value = s; } } }; const jl = {
        deep: !0, created(e, t, n) { e[Dl] = Pl(n), cl(e, 'change', (() => { const t = e._modelValue; const n = ql(e); const r = e.checked; const i = e[Dl]; if (m(t)) { const e = ae(t, n); const o = e !== -1; if (r && !o)i(t.concat(n)); else if (!r && o) { const n = [...t]; n.splice(e, 1), i(n); } } else if (g(t)) { const e = new Set(t); r ? e.add(n) : e.delete(n), i(e); } else i(Hl(e, r)); })); }, mounted: Vl, beforeUpdate(e, t, n) { e[Dl] = Pl(n), Vl(e, t, n); },
      }; function Vl(e, { value: t, oldValue: n }, r) { let i; if (e._modelValue = t, m(t))i = ae(t, r.props.value) > -1; else if (g(t))i = t.has(r.props.value); else { if (t === n) return; i = oe(t, Hl(e, !0)); }e.checked !== i && (e.checked = i); } const Fl = { created(e, { value: t }, n) { e.checked = oe(t, n.props.value), e[Dl] = Pl(n), cl(e, 'change', (() => { e[Dl](ql(e)); })); }, beforeUpdate(e, { value: t, oldValue: n }, r) { e[Dl] = Pl(r), t !== n && (e.checked = oe(t, r.props.value)); } }; const zl = {
        deep: !0, created(e, { value: t, modifiers: { number: n } }, r) { const i = g(t); cl(e, 'change', (() => { const t = Array.prototype.filter.call(e.options, ((e) => e.selected)).map(((e) => (n ? B(ql(e)) : ql(e)))); e[Dl](e.multiple ? i ? new Set(t) : t : t[0]), e._assigning = !0, Tn((() => { e._assigning = !1; })); })), e[Dl] = Pl(r); }, mounted(e, { value: t }) { Bl(e, t); }, beforeUpdate(e, t, n) { e[Dl] = Pl(n); }, updated(e, { value: t }) { e._assigning || Bl(e, t); },
      }; function Bl(e, t) { const n = e.multiple; const r = m(t); if (!n || r || g(t)) { for (let i = 0, o = e.options.length; i < o; i++) { const o = e.options[i]; const a = ql(o); if (n) if (r) { const e = typeof a; o.selected = e === 'string' || e === 'number' ? t.some(((e) => String(e) === String(a))) : ae(t, a) > -1; } else o.selected = t.has(a); else if (oe(ql(o), t)) return void (e.selectedIndex !== i && (e.selectedIndex = i)); }n || e.selectedIndex === -1 || (e.selectedIndex = -1); } } function ql(e) { return '_value' in e ? e._value : e.value; } function Hl(e, t) { const n = t ? '_trueValue' : '_falseValue'; return n in e ? e[n] : t; } const Gl = {
        created(e, t, n) { $l(e, t, n, null, 'created'); }, mounted(e, t, n) { $l(e, t, n, null, 'mounted'); }, beforeUpdate(e, t, n, r) { $l(e, t, n, r, 'beforeUpdate'); }, updated(e, t, n, r) { $l(e, t, n, r, 'updated'); },
      }; function Ul(e, t) { switch (e) { case 'SELECT': return zl; case 'TEXTAREA': return Rl; default: switch (t) { case 'checkbox': return jl; case 'radio': return Fl; default: return Rl; } } } function $l(e, t, n, r, i) { const o = Ul(e.tagName, n.props && n.props.type)[i]; o && o(e, t, n, r); } const Wl = ['ctrl', 'shift', 'alt', 'meta']; const Yl = {
        stop: (e) => e.stopPropagation(), prevent: (e) => e.preventDefault(), self: (e) => e.target !== e.currentTarget, ctrl: (e) => !e.ctrlKey, shift: (e) => !e.shiftKey, alt: (e) => !e.altKey, meta: (e) => !e.metaKey, left: (e) => 'button' in e && e.button !== 0, middle: (e) => 'button' in e && e.button !== 1, right: (e) => 'button' in e && e.button !== 2, exact: (e, t) => Wl.some(((n) => e[`${n}Key`] && !t.includes(n))),
      }; const Xl = (e, t) => { const n = e._withMods || (e._withMods = {}); const r = t.join('.'); return n[r] || (n[r] = (n, ...r) => { for (let e = 0; e < t.length; e++) { const r = Yl[t[e]]; if (r && r(n, t)) return; } return e(n, ...r); }); }; const Kl = {
        esc: 'escape', space: ' ', up: 'arrow-up', left: 'arrow-left', right: 'arrow-right', down: 'arrow-down', delete: 'backspace',
      }; const Jl = (e, t) => { const n = e._withKeys || (e._withKeys = {}); const r = t.join('.'); return n[r] || (n[r] = (n) => { if (!('key' in n)) return; const r = D(n.key); return t.some(((e) => e === r || Kl[e] === r)) ? e(n) : void 0; }); }; const Ql = { patchProp: (e, t, n, r, i, o) => { const a = i === 'svg'; t === 'class' ? (function (e, t, n) { const r = e[As]; r && (t = (t ? [t, ...r] : [...r]).join(' ')), t == null ? e.removeAttribute('class') : n ? e.setAttribute('class', t) : e.className = t; }(e, r, a)) : t === 'style' ? (function (e, t, n) { const r = e.style; const i = w(n); let o = !1; if (n && !i) { if (t) if (w(t)) for (const e of t.split(';')) { const t = e.slice(0, e.indexOf(':')).trim(); n[t] == null && rl(r, t, ''); } else for (const e in t)n[e] == null && rl(r, e, ''); for (const e in n)e === 'display' && (o = !0), rl(r, e, n[e]); } else if (i) { if (t !== n) { const e = r[Js]; e && (n += `;${e}`), r.cssText = n, o = tl.test(n); } } else t && e.removeAttribute('style'); Ws in e && (e[Ws] = o ? r.display : '', e[Ys] && (r.display = 'none')); }(e, n, r)) : c(t) ? u(t) || (function (e, t, n, r, i = null) { const o = e[ul] || (e[ul] = {}); const a = o[t]; if (r && a)a.value = r; else { const [n, s] = (function (e) { let t; if (dl.test(e)) { let n; for (t = {}; n = e.match(dl);)e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0; } return [e[2] === ':' ? e.slice(3) : D(e.slice(2)), t]; }(t)); if (r) { const a = o[t] = (function (e, t) { const n = (e) => { if (e._vts) { if (e._vts <= n.attached) return; } else e._vts = Date.now(); mn((function (e, t) { if (m(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0; }, t.map(((e) => (t) => !t._stopped && e && e(t))); } return t; }(e, n.value)), t, 5, [e]); }; return n.value = e, n.attached = hl(), n; }(r, i)); cl(e, n, a, s); } else a && ((function (e, t, n, r) { e.removeEventListener(t, n, r); }(e, n, a, s)), o[t] = void 0); } }(e, t, 0, r, o)) : (t[0] === '.' ? (t = t.slice(1), 1) : t[0] === '^' ? (t = t.slice(1), 0) : (function (e, t, n, r) { if (r) return t === 'innerHTML' || t === 'textContent' || !!(t in e && ml(t) && b(n)); if (t === 'spellcheck' || t === 'draggable' || t === 'translate') return !1; if (t === 'form') return !1; if (t === 'list' && e.tagName === 'INPUT') return !1; if (t === 'type' && e.tagName === 'TEXTAREA') return !1; if (t === 'width' || t === 'height') { const t = e.tagName; if (t === 'IMG' || t === 'VIDEO' || t === 'CANVAS' || t === 'SOURCE') return !1; } return (!ml(t) || !w(n)) && t in e; }(e, t, r, a))) ? (ll(e, t, r), e.tagName.includes('-') || t !== 'value' && t !== 'checked' && t !== 'selected' || sl(e, t, r, a, 0, t !== 'value')) : !e._isVueCE || !/[A-Z]/.test(t) && w(r) ? (t === 'true-value' ? e._trueValue = r : t === 'false-value' && (e._falseValue = r), sl(e, t, r, a)) : ll(e, I(t), r, 0, t); }, ...Ls }; let Zl; let ec = !1; function tc() { return Zl || (Zl = Lo(Ql)); } function nc() { return Zl = ec ? Zl : ko(Ql), ec = !0, Zl; } const rc = (...e) => { tc().render(...e); }; const ic = (...e) => { nc().hydrate(...e); }; const oc = (...e) => { const t = tc().createApp(...e); const { mount: n } = t; return t.mount = (e) => { const r = lc(e); if (!r) return; const i = t._component; b(i) || i.render || i.template || (i.template = r.innerHTML), r.nodeType === 1 && (r.textContent = ''); const o = n(r, !1, sc(r)); return r instanceof Element && (r.removeAttribute('v-cloak'), r.setAttribute('data-v-app', '')), o; }, t; }; const ac = (...e) => { const t = nc().createApp(...e); const { mount: n } = t; return t.mount = (e) => { const t = lc(e); if (t) return n(t, !0, sc(t)); }, t; }; function sc(e) { return e instanceof SVGElement ? 'svg' : typeof MathMLElement === 'function' && e instanceof MathMLElement ? 'mathml' : void 0; } function lc(e) { return w(e) ? document.querySelector(e) : e; }let cc = !1; const uc = () => { cc || (cc = !0, Rl.getSSRProps = ({ value: e }) => ({ value: e }), Fl.getSSRProps = ({ value: e }, t) => { if (t.props && oe(t.props.value, e)) return { checked: !0 }; }, jl.getSSRProps = ({ value: e }, t) => { if (m(e)) { if (t.props && ae(e, t.props.value) > -1) return { checked: !0 }; } else if (g(e)) { if (t.props && e.has(t.props.value)) return { checked: !0 }; } else if (e) return { checked: !0 }; }, Gl.getSSRProps = (e, t) => { if (typeof t.type !== 'string') return; const n = Ul(t.type.toUpperCase(), t.props && t.props.type); return n.getSSRProps ? n.getSSRProps(e, t) : void 0; }, Xs.getSSRProps = ({ value: e }) => { if (!e) return { style: { display: 'none' } }; }); }; const dc = Symbol(''); const pc = Symbol(''); const fc = Symbol(''); const hc = Symbol(''); const mc = Symbol(''); const vc = Symbol(''); const gc = Symbol(''); const yc = Symbol(''); const bc = Symbol(''); const wc = Symbol(''); const Sc = Symbol(''); const xc = Symbol(''); const Ec = Symbol(''); const Tc = Symbol(''); const _c = Symbol(''); const Cc = Symbol(''); const Lc = Symbol(''); const kc = Symbol(''); const Mc = Symbol(''); const Ac = Symbol(''); const Oc = Symbol(''); const Pc = Symbol(''); const Ic = Symbol(''); const Nc = Symbol(''); const Dc = Symbol(''); const Rc = Symbol(''); const jc = Symbol(''); const Vc = Symbol(''); const Fc = Symbol(''); const zc = Symbol(''); const Bc = Symbol(''); const qc = Symbol(''); const Hc = Symbol(''); const Gc = Symbol(''); const Uc = Symbol(''); const $c = Symbol(''); const Wc = Symbol(''); const Yc = Symbol(''); const Xc = Symbol(''); const Kc = {
        [dc]: 'Fragment', [pc]: 'Teleport', [fc]: 'Suspense', [hc]: 'KeepAlive', [mc]: 'BaseTransition', [vc]: 'openBlock', [gc]: 'createBlock', [yc]: 'createElementBlock', [bc]: 'createVNode', [wc]: 'createElementVNode', [Sc]: 'createCommentVNode', [xc]: 'createTextVNode', [Ec]: 'createStaticVNode', [Tc]: 'resolveComponent', [_c]: 'resolveDynamicComponent', [Cc]: 'resolveDirective', [Lc]: 'resolveFilter', [kc]: 'withDirectives', [Mc]: 'renderList', [Ac]: 'renderSlot', [Oc]: 'createSlots', [Pc]: 'toDisplayString', [Ic]: 'mergeProps', [Nc]: 'normalizeClass', [Dc]: 'normalizeStyle', [Rc]: 'normalizeProps', [jc]: 'guardReactiveProps', [Vc]: 'toHandlers', [Fc]: 'camelize', [zc]: 'capitalize', [Bc]: 'toHandlerKey', [qc]: 'setBlockTracking', [Hc]: 'pushScopeId', [Gc]: 'popScopeId', [Uc]: 'withCtx', [$c]: 'unref', [Wc]: 'isRef', [Yc]: 'withMemo', [Xc]: 'isMemoSame',
      }; const Jc = { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 }, source: '' }; function Qc(e, t, n, r, i, o, a, s = !1, l = !1, c = !1, u = Jc) {
        return e && (s ? (e.helper(vc), e.helper(lu(e.inSSR, c))) : e.helper(su(e.inSSR, c)), a && e.helper(kc)), {
          type: 13, tag: t, props: n, children: r, patchFlag: i, dynamicProps: o, directives: a, isBlock: s, disableTracking: l, isComponent: c, loc: u,
        };
      } function Zc(e, t = Jc) { return { type: 17, loc: t, elements: e }; } function eu(e, t = Jc) { return { type: 15, loc: t, properties: e }; } function tu(e, t) {
        return {
          type: 16, loc: Jc, key: w(e) ? nu(e, !0) : e, value: t,
        };
      } function nu(e, t = !1, n = Jc, r = 0) {
        return {
          type: 4, loc: n, content: e, isStatic: t, constType: t ? 3 : r,
        };
      } function ru(e, t = Jc) { return { type: 8, loc: t, children: e }; } function iu(e, t = [], n = Jc) {
        return {
          type: 14, loc: n, callee: e, arguments: t,
        };
      } function ou(e, t = void 0, n = !1, r = !1, i = Jc) {
        return {
          type: 18, params: e, returns: t, newline: n, isSlot: r, loc: i,
        };
      } function au(e, t, n, r = !0) {
        return {
          type: 19, test: e, consequent: t, alternate: n, newline: r, loc: Jc,
        };
      } function su(e, t) { return e || t ? bc : wc; } function lu(e, t) { return e || t ? gc : yc; } function cu(e, { helper: t, removeHelper: n, inSSR: r }) { e.isBlock || (e.isBlock = !0, n(su(r, e.isComponent)), t(vc), t(lu(r, e.isComponent))); } const uu = new Uint8Array([123, 123]); const du = new Uint8Array([125, 125]); function pu(e) { return e >= 97 && e <= 122 || e >= 65 && e <= 90; } function fu(e) { return e === 32 || e === 10 || e === 9 || e === 12 || e === 13; } function hu(e) { return e === 47 || e === 62 || fu(e); } function mu(e) { const t = new Uint8Array(e.length); for (let n = 0; n < e.length; n++)t[n] = e.charCodeAt(n); return t; } const vu = {
        Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]), CdataEnd: new Uint8Array([93, 93, 62]), CommentEnd: new Uint8Array([45, 45, 62]), ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]), StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]), TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]), TextareaEnd: new Uint8Array([60, 47, 116, 101, 120, 116, 97, 114, 101, 97]),
      }; function gu(e, { compatConfig: t }) { const n = t && t[e]; return e === 'MODE' ? n || 3 : n; } function yu(e, t) { const n = gu('MODE', t); const r = gu(e, t); return n === 3 ? !0 === r : !1 !== r; } function bu(e, t, n, ...r) { return yu(e, t); } function wu(e) { throw e; } function Su(e) {} function xu(e, t, n, r) { const i = new SyntaxError(String(`https://vuejs.org/error-reference/#compiler-${e}`)); return i.code = e, i.loc = t, i; } const Eu = (e) => e.type === 4 && e.isStatic; function Tu(e) { switch (e) { case 'Teleport': case 'teleport': return pc; case 'Suspense': case 'suspense': return fc; case 'KeepAlive': case 'keep-alive': return hc; case 'BaseTransition': case 'base-transition': return mc; } } const _u = /^\d|[^\$\w\xA0-\uFFFF]/; const Cu = (e) => !_u.test(e); const Lu = /[A-Za-z_$\xA0-\uFFFF]/; const ku = /[\.\?\w$\xA0-\uFFFF]/; const Mu = /\s+[.[]\s*|\s*[.[]\s+/g; const Au = (e) => (e.type === 4 ? e.content : e.loc.source); const Ou = (e) => { const t = Au(e).trim().replace(Mu, ((e) => e.trim())); let n = 0; const r = []; let i = 0; let o = 0; let a = null; for (let e = 0; e < t.length; e++) { const s = t.charAt(e); switch (n) { case 0: if (s === '[')r.push(n), n = 1, i++; else if (s === '(')r.push(n), n = 2, o++; else if (!(e === 0 ? Lu : ku).test(s)) return !1; break; case 1: s === "'" || s === '"' || s === '`' ? (r.push(n), n = 3, a = s) : s === '[' ? i++ : s === ']' && (--i || (n = r.pop())); break; case 2: if (s === "'" || s === '"' || s === '`')r.push(n), n = 3, a = s; else if (s === '(')o++; else if (s === ')') { if (e === t.length - 1) return !1; --o || (n = r.pop()); } break; case 3: s === a && (n = r.pop(), a = null); } } return !i && !o; }; const Pu = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/; function Iu(e, t, n = !1) { for (let r = 0; r < e.props.length; r++) { const i = e.props[r]; if (i.type === 7 && (n || i.exp) && (w(t) ? i.name === t : t.test(i.name))) return i; } } function Nu(e, t, n = !1, r = !1) { for (let i = 0; i < e.props.length; i++) { const o = e.props[i]; if (o.type === 6) { if (n) continue; if (o.name === t && (o.value || r)) return o; } else if (o.name === 'bind' && (o.exp || r) && Du(o.arg, t)) return o; } } function Du(e, t) { return !(!e || !Eu(e) || e.content !== t); } function Ru(e) { return e.type === 5 || e.type === 2; } function ju(e) { return e.type === 7 && e.name === 'slot'; } function Vu(e) { return e.type === 1 && e.tagType === 3; } function Fu(e) { return e.type === 1 && e.tagType === 2; } const zu = new Set([Rc, jc]); function Bu(e, t = []) { if (e && !w(e) && e.type === 14) { const n = e.callee; if (!w(n) && zu.has(n)) return Bu(e.arguments[0], t.concat(e)); } return [e, t]; } function qu(e, t, n) { let r; let i; let o = e.type === 13 ? e.props : e.arguments[2]; let a = []; if (o && !w(o) && o.type === 14) { const e = Bu(o); o = e[0], a = e[1], i = a[a.length - 1]; } if (o == null || w(o))r = eu([t]); else if (o.type === 14) { const e = o.arguments[0]; w(e) || e.type !== 15 ? o.callee === Vc ? r = iu(n.helper(Ic), [eu([t]), o]) : o.arguments.unshift(eu([t])) : Hu(t, e) || e.properties.unshift(t), !r && (r = o); } else o.type === 15 ? (Hu(t, o) || o.properties.unshift(t), r = o) : (r = iu(n.helper(Ic), [eu([t]), o]), i && i.callee === jc && (i = a[a.length - 2])); e.type === 13 ? i ? i.arguments[0] = r : e.props = r : i ? i.arguments[0] = r : e.arguments[2] = r; } function Hu(e, t) { let n = !1; if (e.key.type === 4) { const r = e.key.content; n = t.properties.some(((e) => e.key.type === 4 && e.key.content === r)); } return n; } function Gu(e, t) { return `_${t}_${e.replace(/[^\w]/g, ((t, n) => (t === '-' ? '_' : e.charCodeAt(n).toString())))}`; } const Uu = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/; const $u = {
        parseMode: 'base', ns: 0, delimiters: ['{{', '}}'], getNamespace: () => 0, isVoidTag: l, isPreTag: l, isIgnoreNewlineTag: l, isCustomElement: l, onError: wu, onWarn: Su, comments: !1, prefixIdentifiers: !1,
      }; let Wu = $u; let Yu = null; let Xu = ''; let Ku = null; let Ju = null; let Qu = ''; let Zu = -1; let ed = -1; let td = 0; let nd = !1; let rd = null; const id = []; const od = new class {
        constructor(e, t) { this.stack = e, this.cbs = t, this.state = 1, this.buffer = '', this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = 1, this.inRCDATA = !1, this.inXML = !1, this.inVPre = !1, this.newlines = [], this.mode = 0, this.delimiterOpen = uu, this.delimiterClose = du, this.delimiterIndex = -1, this.currentSequence = void 0, this.sequenceIndex = 0; }

        get inSFCRoot() { return this.mode === 2 && this.stack.length === 0; }

        reset() { this.state = 1, this.mode = 0, this.buffer = '', this.sectionStart = 0, this.index = 0, this.baseState = 1, this.inRCDATA = !1, this.currentSequence = void 0, this.newlines.length = 0, this.delimiterOpen = uu, this.delimiterClose = du; }

        getPos(e) { let t = 1; let n = e + 1; for (let r = this.newlines.length - 1; r >= 0; r--) { const i = this.newlines[r]; if (e > i) { t = r + 2, n = e - i; break; } } return { column: n, line: t, offset: e }; }

        peek() { return this.buffer.charCodeAt(this.index + 1); }

        stateText(e) { e === 60 ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = 5, this.sectionStart = this.index) : this.inVPre || e !== this.delimiterOpen[0] || (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e)); }

        stateInterpolationOpen(e) { if (e === this.delimiterOpen[this.delimiterIndex]) if (this.delimiterIndex === this.delimiterOpen.length - 1) { const e = this.index + 1 - this.delimiterOpen.length; e > this.sectionStart && this.cbs.ontext(this.sectionStart, e), this.state = 3, this.sectionStart = e; } else this.delimiterIndex++; else this.inRCDATA ? (this.state = 32, this.stateInRCDATA(e)) : (this.state = 1, this.stateText(e)); }

        stateInterpolation(e) { e === this.delimiterClose[0] && (this.state = 4, this.delimiterIndex = 0, this.stateInterpolationClose(e)); }

        stateInterpolationClose(e) { e === this.delimiterClose[this.delimiterIndex] ? this.delimiterIndex === this.delimiterClose.length - 1 ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : this.delimiterIndex++ : (this.state = 3, this.stateInterpolation(e)); }

        stateSpecialStartSequence(e) { const t = this.sequenceIndex === this.currentSequence.length; if (t ? hu(e) : (32 | e) === this.currentSequence[this.sequenceIndex]) { if (!t) return void this.sequenceIndex++; } else this.inRCDATA = !1; this.sequenceIndex = 0, this.state = 6, this.stateInTagName(e); }

        stateInRCDATA(e) { if (this.sequenceIndex === this.currentSequence.length) { if (e === 62 || fu(e)) { const t = this.index - this.currentSequence.length; if (this.sectionStart < t) { const e = this.index; this.index = t, this.cbs.ontext(this.sectionStart, t), this.index = e; } return this.sectionStart = t + 2, this.stateInClosingTagName(e), void (this.inRCDATA = !1); } this.sequenceIndex = 0; }(32 | e) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === vu.TitleEnd || this.currentSequence === vu.TextareaEnd && !this.inSFCRoot ? this.inVPre || e !== this.delimiterOpen[0] || (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e)) : this.fastForwardTo(60) && (this.sequenceIndex = 1) : this.sequenceIndex = Number(e === 60); }

        stateCDATASequence(e) { e === vu.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === vu.Cdata.length && (this.state = 28, this.currentSequence = vu.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = 23, this.stateInDeclaration(e)); }

        fastForwardTo(e) { for (;++this.index < this.buffer.length;) { const t = this.buffer.charCodeAt(this.index); if (t === 10 && this.newlines.push(this.index), t === e) return !0; } return this.index = this.buffer.length - 1, !1; }

        stateInCommentLike(e) { e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === vu.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index - 2) : this.cbs.oncomment(this.sectionStart, this.index - 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = 1) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0); }

        startSpecial(e, t) { this.enterRCDATA(e, t), this.state = 31; }

        enterRCDATA(e, t) { this.inRCDATA = !0, this.currentSequence = e, this.sequenceIndex = t; }

        stateBeforeTagName(e) { e === 33 ? (this.state = 22, this.sectionStart = this.index + 1) : e === 63 ? (this.state = 24, this.sectionStart = this.index + 1) : pu(e) ? (this.sectionStart = this.index, this.mode === 0 ? this.state = 6 : this.inSFCRoot ? this.state = 34 : this.inXML ? this.state = 6 : this.state = e === 116 ? 30 : e === 115 ? 29 : 6) : e === 47 ? this.state = 8 : (this.state = 1, this.stateText(e)); }

        stateInTagName(e) { hu(e) && this.handleTagName(e); }

        stateInSFCRootTagName(e) { if (hu(e)) { const t = this.buffer.slice(this.sectionStart, this.index); t !== 'template' && this.enterRCDATA(mu(`</${t}`), 0), this.handleTagName(e); } }

        handleTagName(e) { this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e); }

        stateBeforeClosingTagName(e) { fu(e) || (e === 62 ? (this.state = 1, this.sectionStart = this.index + 1) : (this.state = pu(e) ? 9 : 27, this.sectionStart = this.index)); }

        stateInClosingTagName(e) { (e === 62 || fu(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = 10, this.stateAfterClosingTagName(e)); }

        stateAfterClosingTagName(e) { e === 62 && (this.state = 1, this.sectionStart = this.index + 1); }

        stateBeforeAttrName(e) { e === 62 ? (this.cbs.onopentagend(this.index), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : e === 47 ? this.state = 7 : e === 60 && this.peek() === 47 ? (this.cbs.onopentagend(this.index), this.state = 5, this.sectionStart = this.index) : fu(e) || this.handleAttrStart(e); }

        handleAttrStart(e) { e === 118 && this.peek() === 45 ? (this.state = 13, this.sectionStart = this.index) : e === 46 || e === 58 || e === 64 || e === 35 ? (this.cbs.ondirname(this.index, this.index + 1), this.state = 14, this.sectionStart = this.index + 1) : (this.state = 12, this.sectionStart = this.index); }

        stateInSelfClosingTag(e) { e === 62 ? (this.cbs.onselfclosingtag(this.index), this.state = 1, this.sectionStart = this.index + 1, this.inRCDATA = !1) : fu(e) || (this.state = 11, this.stateBeforeAttrName(e)); }

        stateInAttrName(e) { (e === 61 || hu(e)) && (this.cbs.onattribname(this.sectionStart, this.index), this.handleAttrNameEnd(e)); }

        stateInDirName(e) { e === 61 || hu(e) ? (this.cbs.ondirname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 58 ? (this.cbs.ondirname(this.sectionStart, this.index), this.state = 14, this.sectionStart = this.index + 1) : e === 46 && (this.cbs.ondirname(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1); }

        stateInDirArg(e) { e === 61 || hu(e) ? (this.cbs.ondirarg(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 91 ? this.state = 15 : e === 46 && (this.cbs.ondirarg(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1); }

        stateInDynamicDirArg(e) { e === 93 ? this.state = 14 : (e === 61 || hu(e)) && (this.cbs.ondirarg(this.sectionStart, this.index + 1), this.handleAttrNameEnd(e)); }

        stateInDirModifier(e) { e === 61 || hu(e) ? (this.cbs.ondirmodifier(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 46 && (this.cbs.ondirmodifier(this.sectionStart, this.index), this.sectionStart = this.index + 1); }

        handleAttrNameEnd(e) { this.sectionStart = this.index, this.state = 17, this.cbs.onattribnameend(this.index), this.stateAfterAttrName(e); }

        stateAfterAttrName(e) { e === 61 ? this.state = 18 : e === 47 || e === 62 ? (this.cbs.onattribend(0, this.sectionStart), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e)) : fu(e) || (this.cbs.onattribend(0, this.sectionStart), this.handleAttrStart(e)); }

        stateBeforeAttrValue(e) { e === 34 ? (this.state = 19, this.sectionStart = this.index + 1) : e === 39 ? (this.state = 20, this.sectionStart = this.index + 1) : fu(e) || (this.sectionStart = this.index, this.state = 21, this.stateInAttrValueNoQuotes(e)); }

        handleInAttrValue(e, t) { (e === t || this.fastForwardTo(t)) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(t === 34 ? 3 : 2, this.index + 1), this.state = 11); }

        stateInAttrValueDoubleQuotes(e) { this.handleInAttrValue(e, 34); }

        stateInAttrValueSingleQuotes(e) { this.handleInAttrValue(e, 39); }

        stateInAttrValueNoQuotes(e) { fu(e) || e === 62 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(1, this.index), this.state = 11, this.stateBeforeAttrName(e)) : e !== 39 && e !== 60 && e !== 61 && e !== 96 || this.cbs.onerr(18, this.index); }

        stateBeforeDeclaration(e) { e === 91 ? (this.state = 26, this.sequenceIndex = 0) : this.state = e === 45 ? 25 : 23; }

        stateInDeclaration(e) { (e === 62 || this.fastForwardTo(62)) && (this.state = 1, this.sectionStart = this.index + 1); }

        stateInProcessingInstruction(e) { (e === 62 || this.fastForwardTo(62)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1); }

        stateBeforeComment(e) { e === 45 ? (this.state = 28, this.currentSequence = vu.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = 23; }

        stateInSpecialComment(e) { (e === 62 || this.fastForwardTo(62)) && (this.cbs.oncomment(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1); }

        stateBeforeSpecialS(e) { e === vu.ScriptEnd[3] ? this.startSpecial(vu.ScriptEnd, 4) : e === vu.StyleEnd[3] ? this.startSpecial(vu.StyleEnd, 4) : (this.state = 6, this.stateInTagName(e)); }

        stateBeforeSpecialT(e) { e === vu.TitleEnd[3] ? this.startSpecial(vu.TitleEnd, 4) : e === vu.TextareaEnd[3] ? this.startSpecial(vu.TextareaEnd, 4) : (this.state = 6, this.stateInTagName(e)); }

        startEntity() {}

        stateInEntity() {}

        parse(e) { for (this.buffer = e; this.index < this.buffer.length;) { const e = this.buffer.charCodeAt(this.index); switch (e === 10 && this.newlines.push(this.index), this.state) { case 1: this.stateText(e); break; case 2: this.stateInterpolationOpen(e); break; case 3: this.stateInterpolation(e); break; case 4: this.stateInterpolationClose(e); break; case 31: this.stateSpecialStartSequence(e); break; case 32: this.stateInRCDATA(e); break; case 26: this.stateCDATASequence(e); break; case 19: this.stateInAttrValueDoubleQuotes(e); break; case 12: this.stateInAttrName(e); break; case 13: this.stateInDirName(e); break; case 14: this.stateInDirArg(e); break; case 15: this.stateInDynamicDirArg(e); break; case 16: this.stateInDirModifier(e); break; case 28: this.stateInCommentLike(e); break; case 27: this.stateInSpecialComment(e); break; case 11: this.stateBeforeAttrName(e); break; case 6: this.stateInTagName(e); break; case 34: this.stateInSFCRootTagName(e); break; case 9: this.stateInClosingTagName(e); break; case 5: this.stateBeforeTagName(e); break; case 17: this.stateAfterAttrName(e); break; case 20: this.stateInAttrValueSingleQuotes(e); break; case 18: this.stateBeforeAttrValue(e); break; case 8: this.stateBeforeClosingTagName(e); break; case 10: this.stateAfterClosingTagName(e); break; case 29: this.stateBeforeSpecialS(e); break; case 30: this.stateBeforeSpecialT(e); break; case 21: this.stateInAttrValueNoQuotes(e); break; case 7: this.stateInSelfClosingTag(e); break; case 23: this.stateInDeclaration(e); break; case 22: this.stateBeforeDeclaration(e); break; case 25: this.stateBeforeComment(e); break; case 24: this.stateInProcessingInstruction(e); break; case 33: this.stateInEntity(); } this.index++; } this.cleanup(), this.finish(); }

        cleanup() { this.sectionStart !== this.index && (this.state === 1 || this.state === 32 && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : this.state !== 19 && this.state !== 20 && this.state !== 21 || (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index)); }

        finish() { this.handleTrailingData(), this.cbs.onend(); }

        handleTrailingData() { const e = this.buffer.length; this.sectionStart >= e || (this.state === 28 ? this.currentSequence === vu.CdataEnd ? this.cbs.oncdata(this.sectionStart, e) : this.cbs.oncomment(this.sectionStart, e) : this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9 || this.cbs.ontext(this.sectionStart, e)); }

        emitCodePoint(e, t) {}
      }(id, {
        onerr: _d,
        ontext(e, t) { ud(ld(e, t), e, t); },
        ontextentity(e, t, n) { ud(e, t, n); },
        oninterpolation(e, t) { if (nd) return ud(ld(e, t), e, t); let n = e + od.delimiterOpen.length; let r = t - od.delimiterClose.length; for (;fu(Xu.charCodeAt(n));)n++; for (;fu(Xu.charCodeAt(r - 1));)r--; let i = ld(n, r); i.includes('&') && (i = Wu.decodeEntities(i, !1)), wd({ type: 5, content: Td(i, !1, Sd(n, r)), loc: Sd(e, t) }); },
        onopentagname(e, t) {
          const n = ld(e, t); Ku = {
            type: 1, tag: n, ns: Wu.getNamespace(n, id[0], Wu.ns), tagType: 0, props: [], children: [], loc: Sd(e - 1, t), codegenNode: void 0,
          };
        },
        onopentagend(e) { cd(e); },
        onclosetag(e, t) { const n = ld(e, t); if (!Wu.isVoidTag(n)) { let r = !1; for (let e = 0; e < id.length; e++) if (id[e].tag.toLowerCase() === n.toLowerCase()) { r = !0, e > 0 && _d(24, id[0].loc.start.offset); for (let n = 0; n <= e; n++)dd(id.shift(), t, n < e); break; }r || _d(23, pd(e, 60)); } },
        onselfclosingtag(e) { const t = Ku.tag; Ku.isSelfClosing = !0, cd(e), id[0] && id[0].tag === t && dd(id.shift(), e); },
        onattribname(e, t) {
          Ju = {
            type: 6, name: ld(e, t), nameLoc: Sd(e, t), value: void 0, loc: Sd(e),
          };
        },
        ondirname(e, t) {
          const n = ld(e, t); const r = n === '.' || n === ':' ? 'bind' : n === '@' ? 'on' : n === '#' ? 'slot' : n.slice(2); if (nd || r !== '' || _d(26, e), nd || r === '') {
            Ju = {
              type: 6, name: n, nameLoc: Sd(e, t), value: void 0, loc: Sd(e),
            };
          } else if (Ju = {
            type: 7, name: r, rawName: n, exp: void 0, arg: void 0, modifiers: n === '.' ? [nu('prop')] : [], loc: Sd(e),
          }, r === 'pre') { nd = od.inVPre = !0, rd = Ku; const e = Ku.props; for (let t = 0; t < e.length; t++)e[t].type === 7 && (e[t] = Ed(e[t])); }
        },
        ondirarg(e, t) { if (e === t) return; const n = ld(e, t); if (nd)Ju.name += n, xd(Ju.nameLoc, t); else { const r = n[0] !== '['; Ju.arg = Td(r ? n : n.slice(1, -1), r, Sd(e, t), r ? 3 : 0); } },
        ondirmodifier(e, t) { const n = ld(e, t); if (nd)Ju.name += `.${n}`, xd(Ju.nameLoc, t); else if (Ju.name === 'slot') { const e = Ju.arg; e && (e.content += `.${n}`, xd(e.loc, t)); } else { const r = nu(n, !0, Sd(e, t)); Ju.modifiers.push(r); } },
        onattribdata(e, t) { Qu += ld(e, t), Zu < 0 && (Zu = e), ed = t; },
        onattribentity(e, t, n) { Qu += e, Zu < 0 && (Zu = t), ed = n; },
        onattribnameend(e) { const t = Ju.loc.start.offset; const n = ld(t, e); Ju.type === 7 && (Ju.rawName = n), Ku.props.some(((e) => (e.type === 7 ? e.rawName : e.name) === n)) && _d(2, t); },
        onattribend(e, t) {
          if (Ku && Ju) {
            if (xd(Ju.loc, t), e !== 0) {
              if (Qu.includes('&') && (Qu = Wu.decodeEntities(Qu, !0)), Ju.type === 6)Ju.name === 'class' && (Qu = bd(Qu).trim()), e !== 1 || Qu || _d(13, t), Ju.value = { type: 2, content: Qu, loc: e === 1 ? Sd(Zu, ed) : Sd(Zu - 1, ed + 1) }, od.inSFCRoot && Ku.tag === 'template' && Ju.name === 'lang' && Qu && Qu !== 'html' && od.enterRCDATA(mu('</template'), 0); else {
                const e = 0; Ju.exp = Td(Qu, !1, Sd(Zu, ed), 0, e), Ju.name === 'for' && (Ju.forParseResult = (function (e) {
                  const t = e.loc; const n = e.content; const r = n.match(Uu); if (!r) return; const [, i, o] = r; const a = (e, n, r = !1) => { const i = t.start.offset + n; return Td(e, !1, Sd(i, i + e.length), 0, r ? 1 : 0); }; const s = {
                    source: a(o.trim(), n.indexOf(o, i.length)), value: void 0, key: void 0, index: void 0, finalized: !1,
                  }; let l = i.trim().replace(sd, '').trim(); const c = i.indexOf(l); const u = l.match(ad); if (u) { l = l.replace(ad, '').trim(); const e = u[1].trim(); let t; if (e && (t = n.indexOf(e, c + l.length), s.key = a(e, t, !0)), u[2]) { const r = u[2].trim(); r && (s.index = a(r, n.indexOf(r, s.key ? t + e.length : c + l.length), !0)); } } return l && (s.value = a(l, c, !0)), s;
                }(Ju.exp))); let t = -1; Ju.name === 'bind' && (t = Ju.modifiers.findIndex(((e) => e.content === 'sync'))) > -1 && bu('COMPILER_V_BIND_SYNC', Wu, Ju.loc, Ju.rawName) && (Ju.name = 'model', Ju.modifiers.splice(t, 1));
              }
            }Ju.type === 7 && Ju.name === 'pre' || Ku.props.push(Ju);
          }Qu = '', Zu = ed = -1;
        },
        oncomment(e, t) { Wu.comments && wd({ type: 3, content: ld(e, t), loc: Sd(e - 4, t + 3) }); },
        onend() { const e = Xu.length; for (let t = 0; t < id.length; t++)dd(id[t], e - 1), _d(24, id[t].loc.start.offset); },
        oncdata(e, t) { id[0].ns !== 0 ? ud(ld(e, t), e, t) : _d(1, e - 9); },
        onprocessinginstruction(e) { (id[0] ? id[0].ns : Wu.ns) === 0 && _d(21, e - 1); },
      }); const ad = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/; const sd = /^\(|\)$/g; function ld(e, t) { return Xu.slice(e, t); } function cd(e) { od.inSFCRoot && (Ku.innerLoc = Sd(e + 1, e + 1)), wd(Ku); const { tag: t, ns: n } = Ku; n === 0 && Wu.isPreTag(t) && td++, Wu.isVoidTag(t) ? dd(Ku, e) : (id.unshift(Ku), n !== 1 && n !== 2 || (od.inXML = !0)), Ku = null; } function ud(e, t, n) { { const t = id[0] && id[0].tag; t !== 'script' && t !== 'style' && e.includes('&') && (e = Wu.decodeEntities(e, !1)); } const r = id[0] || Yu; const i = r.children[r.children.length - 1]; i && i.type === 2 ? (i.content += e, xd(i.loc, n)) : r.children.push({ type: 2, content: e, loc: Sd(t, n) }); } function dd(e, t, n = !1) { xd(e.loc, n ? pd(t, 60) : (function (e) { let t = e; for (;Xu.charCodeAt(t) !== 62 && t < Xu.length - 1;)t++; return t; }(t)) + 1), od.inSFCRoot && (e.children.length ? e.innerLoc.end = { ...e.children[e.children.length - 1].loc.end } : e.innerLoc.end = { ...e.innerLoc.start }, e.innerLoc.source = ld(e.innerLoc.start.offset, e.innerLoc.end.offset)); const { tag: r, ns: i, children: o } = e; if (nd || (r === 'slot' ? e.tagType = 2 : hd(e) ? e.tagType = 3 : (function ({ tag: e, props: t }) { if (Wu.isCustomElement(e)) return !1; if (e === 'component' || (n = e.charCodeAt(0)) > 64 && n < 91 || Tu(e) || Wu.isBuiltInComponent && Wu.isBuiltInComponent(e) || Wu.isNativeTag && !Wu.isNativeTag(e)) return !0; let n; for (let e = 0; e < t.length; e++) { const n = t[e]; if (n.type === 6) { if (n.name === 'is' && n.value) { if (n.value.content.startsWith('vue:')) return !0; if (bu('COMPILER_IS_ON_ELEMENT', Wu, n.loc)) return !0; } } else if (n.name === 'bind' && Du(n.arg, 'is') && bu('COMPILER_IS_ON_ELEMENT', Wu, n.loc)) return !0; } return !1; }(e)) && (e.tagType = 1)), od.inRCDATA || (e.children = vd(o)), i === 0 && Wu.isIgnoreNewlineTag(r)) { const e = o[0]; e && e.type === 2 && (e.content = e.content.replace(/^\r?\n/, '')); }i === 0 && Wu.isPreTag(r) && td--, rd === e && (nd = od.inVPre = !1, rd = null), od.inXML && (id[0] ? id[0].ns : Wu.ns) === 0 && (od.inXML = !1); { const t = e.props; if (!od.inSFCRoot && yu('COMPILER_NATIVE_TEMPLATE', Wu) && e.tag === 'template' && !hd(e)) { const t = id[0] || Yu; const n = t.children.indexOf(e); t.children.splice(n, 1, ...e.children); } const n = t.find(((e) => e.type === 6 && e.name === 'inline-template')); n && bu('COMPILER_INLINE_TEMPLATE', Wu, n.loc) && e.children.length && (n.value = { type: 2, content: ld(e.children[0].loc.start.offset, e.children[e.children.length - 1].loc.end.offset), loc: n.loc }); } } function pd(e, t) { let n = e; for (;Xu.charCodeAt(n) !== t && n >= 0;)n--; return n; } const fd = new Set(['if', 'else', 'else-if', 'for', 'slot']); function hd({ tag: e, props: t }) { if (e === 'template') for (let e = 0; e < t.length; e++) if (t[e].type === 7 && fd.has(t[e].name)) return !0; return !1; } const md = /\r\n/g; function vd(e, t) { const n = Wu.whitespace !== 'preserve'; let r = !1; for (let t = 0; t < e.length; t++) { const i = e[t]; if (i.type === 2) if (td)i.content = i.content.replace(md, '\n'); else if (gd(i.content)) { const o = e[t - 1] && e[t - 1].type; const a = e[t + 1] && e[t + 1].type; !o || !a || n && (o === 3 && (a === 3 || a === 1) || o === 1 && (a === 3 || a === 1 && yd(i.content))) ? (r = !0, e[t] = null) : i.content = ' '; } else n && (i.content = bd(i.content)); } return r ? e.filter(Boolean) : e; } function gd(e) { for (let t = 0; t < e.length; t++) if (!fu(e.charCodeAt(t))) return !1; return !0; } function yd(e) { for (let t = 0; t < e.length; t++) { const n = e.charCodeAt(t); if (n === 10 || n === 13) return !0; } return !1; } function bd(e) { let t = ''; let n = !1; for (let r = 0; r < e.length; r++)fu(e.charCodeAt(r)) ? n || (t += ' ', n = !0) : (t += e[r], n = !1); return t; } function wd(e) { (id[0] || Yu).children.push(e); } function Sd(e, t) { return { start: od.getPos(e), end: t == null ? t : od.getPos(t), source: t == null ? t : ld(e, t) }; } function xd(e, t) { e.end = od.getPos(t), e.source = ld(e.start.offset, t); } function Ed(e) {
        const t = {
          type: 6, name: e.rawName, nameLoc: Sd(e.loc.start.offset, e.loc.start.offset + e.rawName.length), value: void 0, loc: e.loc,
        }; if (e.exp) { const n = e.exp.loc; n.end.offset < e.loc.end.offset && (n.start.offset--, n.start.column--, n.end.offset++, n.end.column++), t.value = { type: 2, content: e.exp.content, loc: n }; } return t;
      } function Td(e, t = !1, n, r = 0, i = 0) { return nu(e, t, n, r); } function _d(e, t, n) { Wu.onError(xu(e, Sd(t, t))); } function Cd(e, t) { kd(e, void 0, t, Ld(e, e.children[0])); } function Ld(e, t) { const { children: n } = e; return n.length === 1 && t.type === 1 && !Fu(t); } function kd(e, t, n, r = !1, i = !1) { const { children: o } = e; const a = []; for (let t = 0; t < o.length; t++) { const s = o[t]; if (s.type === 1 && s.tagType === 0) { const e = r ? 0 : Md(s, n); if (e > 0) { if (e >= 2) { s.codegenNode.patchFlag = -1, a.push(s); continue; } } else { const e = s.codegenNode; if (e.type === 13) { const t = e.patchFlag; if ((void 0 === t || t === 512 || t === 1) && Pd(s, n) >= 2) { const t = Id(s); t && (e.props = n.hoist(t)); }e.dynamicProps && (e.dynamicProps = n.hoist(e.dynamicProps)); } } } else if (s.type === 12 && (r ? 0 : Md(s, n)) >= 2) { a.push(s); continue; } if (s.type === 1) { const t = s.tagType === 1; t && n.scopes.vSlot++, kd(s, e, n, !1, i), t && n.scopes.vSlot--; } else if (s.type === 11)kd(s, e, n, s.children.length === 1, !0); else if (s.type === 9) for (let t = 0; t < s.branches.length; t++)kd(s.branches[t], e, n, s.branches[t].children.length === 1, i); }let s = !1; if (a.length === o.length && e.type === 1) if (e.tagType === 0 && e.codegenNode && e.codegenNode.type === 13 && m(e.codegenNode.children))e.codegenNode.children = l(Zc(e.codegenNode.children)), s = !0; else if (e.tagType === 1 && e.codegenNode && e.codegenNode.type === 13 && e.codegenNode.children && !m(e.codegenNode.children) && e.codegenNode.children.type === 15) { const t = c(e.codegenNode, 'default'); t && (t.returns = l(Zc(t.returns)), s = !0); } else if (e.tagType === 3 && t && t.type === 1 && t.tagType === 1 && t.codegenNode && t.codegenNode.type === 13 && t.codegenNode.children && !m(t.codegenNode.children) && t.codegenNode.children.type === 15) { const n = Iu(e, 'slot', !0); const r = n && n.arg && c(t.codegenNode, n.arg); r && (r.returns = l(Zc(r.returns)), s = !0); } if (!s) for (const e of a)e.codegenNode = n.cache(e.codegenNode); function l(e) { const t = n.cache(e); return i && n.hmr && (t.needArraySpread = !0), t; } function c(e, t) { if (e.children && !m(e.children) && e.children.type === 15) { const n = e.children.properties.find(((e) => e.key === t || e.key.content === t)); return n && n.value; } }a.length && n.transformHoist && n.transformHoist(o, n, e); } function Md(e, t) { const { constantCache: n } = t; switch (e.type) { case 1: if (e.tagType !== 0) return 0; const r = n.get(e); if (void 0 !== r) return r; const i = e.codegenNode; if (i.type !== 13) return 0; if (i.isBlock && e.tag !== 'svg' && e.tag !== 'foreignObject' && e.tag !== 'math') return 0; if (void 0 === i.patchFlag) { let r = 3; const o = Pd(e, t); if (o === 0) return n.set(e, 0), 0; o < r && (r = o); for (let i = 0; i < e.children.length; i++) { const o = Md(e.children[i], t); if (o === 0) return n.set(e, 0), 0; o < r && (r = o); } if (r > 1) for (let i = 0; i < e.props.length; i++) { const o = e.props[i]; if (o.type === 7 && o.name === 'bind' && o.exp) { const i = Md(o.exp, t); if (i === 0) return n.set(e, 0), 0; i < r && (r = i); } } if (i.isBlock) { for (let t = 0; t < e.props.length; t++) if (e.props[t].type === 7) return n.set(e, 0), 0; t.removeHelper(vc), t.removeHelper(lu(t.inSSR, i.isComponent)), i.isBlock = !1, t.helper(su(t.inSSR, i.isComponent)); } return n.set(e, r), r; } return n.set(e, 0), 0; case 2: case 3: return 3; case 9: case 11: case 10: default: return 0; case 5: case 12: return Md(e.content, t); case 4: return e.constType; case 8: let o = 3; for (let n = 0; n < e.children.length; n++) { const r = e.children[n]; if (w(r) || S(r)) continue; const i = Md(r, t); if (i === 0) return 0; i < o && (o = i); } return o; case 20: return 2; } } const Ad = new Set([Nc, Dc, Rc, jc]); function Od(e, t) { if (e.type === 14 && !w(e.callee) && Ad.has(e.callee)) { const n = e.arguments[0]; if (n.type === 4) return Md(n, t); if (n.type === 14) return Od(n, t); } return 0; } function Pd(e, t) { let n = 3; const r = Id(e); if (r && r.type === 15) { const { properties: e } = r; for (let r = 0; r < e.length; r++) { const { key: i, value: o } = e[r]; const a = Md(i, t); if (a === 0) return a; let s; if (a < n && (n = a), s = o.type === 4 ? Md(o, t) : o.type === 14 ? Od(o, t) : 0, s === 0) return s; s < n && (n = s); } } return n; } function Id(e) { const t = e.codegenNode; if (t.type === 13) return t.props; } function Nd(e, t) {
        const n = (function (e, {
          filename: t = '', prefixIdentifiers: n = !1, hoistStatic: r = !1, hmr: i = !1, cacheHandlers: a = !1, nodeTransforms: l = [], directiveTransforms: c = {}, transformHoist: u = null, isBuiltInComponent: d = s, isCustomElement: p = s, expressionPlugins: f = [], scopeId: h = null, slotted: m = !0, ssr: v = !1, inSSR: g = !1, ssrCssVars: y = '', bindingMetadata: b = o, inline: S = !1, isTS: x = !1, onError: E = wu, onWarn: T = Su, compatConfig: _,
        }) {
          const C = t.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/); const L = {
            filename: t,
            selfName: C && R(I(C[1])),
            prefixIdentifiers: n,
            hoistStatic: r,
            hmr: i,
            cacheHandlers: a,
            nodeTransforms: l,
            directiveTransforms: c,
            transformHoist: u,
            isBuiltInComponent: d,
            isCustomElement: p,
            expressionPlugins: f,
            scopeId: h,
            slotted: m,
            ssr: v,
            inSSR: g,
            ssrCssVars: y,
            bindingMetadata: b,
            inline: S,
            isTS: x,
            onError: E,
            onWarn: T,
            compatConfig: _,
            root: e,
            helpers: new Map(),
            components: new Set(),
            directives: new Set(),
            hoists: [],
            imports: [],
            cached: [],
            constantCache: new WeakMap(),
            temps: 0,
            identifiers: Object.create(null),
            scopes: {
              vFor: 0, vSlot: 0, vPre: 0, vOnce: 0,
            },
            parent: null,
            grandParent: null,
            currentNode: e,
            childIndex: 0,
            inVOnce: !1,
            helper(e) { const t = L.helpers.get(e) || 0; return L.helpers.set(e, t + 1), e; },
            removeHelper(e) { const t = L.helpers.get(e); if (t) { const n = t - 1; n ? L.helpers.set(e, n) : L.helpers.delete(e); } },
            helperString: (e) => `_${Kc[L.helper(e)]}`,
            replaceNode(e) { L.parent.children[L.childIndex] = L.currentNode = e; },
            removeNode(e) { const t = L.parent.children; const n = e ? t.indexOf(e) : L.currentNode ? L.childIndex : -1; e && e !== L.currentNode ? L.childIndex > n && (L.childIndex--, L.onNodeRemoved()) : (L.currentNode = null, L.onNodeRemoved()), L.parent.children.splice(n, 1); },
            onNodeRemoved: s,
            addIdentifiers(e) {},
            removeIdentifiers(e) {},
            hoist(e) { w(e) && (e = nu(e)), L.hoists.push(e); const t = nu(`_hoisted_${L.hoists.length}`, !1, e.loc, 2); return t.hoisted = e, t; },
            cache(e, t = !1, n = !1) {
              const r = (function (e, t, n = !1, r = !1) {
                return {
                  type: 20, index: e, value: t, needPauseTracking: n, inVOnce: r, needArraySpread: !1, loc: Jc,
                };
              }(L.cached.length, e, t, n)); return L.cached.push(r), r;
            },
          }; return L.filters = new Set(), L;
        }(e, t)); Dd(e, n), t.hoistStatic && Cd(e, n), t.ssr || (function (e, t) { const { helper: n } = t; const { children: r } = e; if (r.length === 1) { const n = r[0]; if (Ld(e, n) && n.codegenNode) { const r = n.codegenNode; r.type === 13 && cu(r, t), e.codegenNode = r; } else e.codegenNode = n; } else if (r.length > 1) { const r = 64; e.codegenNode = Qc(t, n(dc), void 0, e.children, r, void 0, void 0, !0, void 0, !1); } }(e, n)), e.helpers = new Set([...n.helpers.keys()]), e.components = [...n.components], e.directives = [...n.directives], e.imports = n.imports, e.hoists = n.hoists, e.temps = n.temps, e.cached = n.cached, e.transformed = !0, e.filters = [...n.filters];
      } function Dd(e, t) { t.currentNode = e; const { nodeTransforms: n } = t; const r = []; for (let i = 0; i < n.length; i++) { const o = n[i](e, t); if (o && (m(o) ? r.push(...o) : r.push(o)), !t.currentNode) return; e = t.currentNode; } switch (e.type) { case 3: t.ssr || t.helper(Sc); break; case 5: t.ssr || t.helper(Pc); break; case 9: for (let n = 0; n < e.branches.length; n++)Dd(e.branches[n], t); break; case 10: case 11: case 1: case 0: !(function (e, t) { let n = 0; const r = () => { n--; }; for (;n < e.children.length; n++) { const i = e.children[n]; w(i) || (t.grandParent = t.parent, t.parent = e, t.childIndex = n, t.onNodeRemoved = r, Dd(i, t)); } }(e, t)); }t.currentNode = e; let i = r.length; for (;i--;)r[i](); } function Rd(e, t) { const n = w(e) ? (t) => t === e : (t) => e.test(t); return (e, r) => { if (e.type === 1) { const { props: i } = e; if (e.tagType === 3 && i.some(ju)) return; const o = []; for (let a = 0; a < i.length; a++) { const s = i[a]; if (s.type === 7 && n(s.name)) { i.splice(a, 1), a--; const n = t(e, s, r); n && o.push(n); } } return o; } }; } const jd = '/*@__PURE__*/'; const Vd = (e) => `${Kc[e]}: _${Kc[e]}`; function Fd(e, t, {
        helper: n, push: r, newline: i, isTS: o,
      }) { const a = n(t === 'filter' ? Lc : t === 'component' ? Tc : Cc); for (let n = 0; n < e.length; n++) { let s = e[n]; const l = s.endsWith('__self'); l && (s = s.slice(0, -6)), r(`const ${Gu(s, t)} = ${a}(${JSON.stringify(s)}${l ? ', true' : ''})${o ? '!' : ''}`), n < e.length - 1 && i(); } } function zd(e, t) { const n = e.length > 3 || !1; t.push('['), n && t.indent(), Bd(e, t, n), n && t.deindent(), t.push(']'); } function Bd(e, t, n = !1, r = !0) { const { push: i, newline: o } = t; for (let a = 0; a < e.length; a++) { const s = e[a]; w(s) ? i(s, -3) : m(s) ? zd(s, t) : qd(s, t), a < e.length - 1 && (n ? (r && i(','), o()) : r && i(', ')); } } function qd(e, t) {
        if (w(e))t.push(e, -3); else if (S(e))t.push(t.helper(e)); else {
          switch (e.type) {
            case 1: case 9: case 11: case 12: qd(e.codegenNode, t); break; case 2: !(function (e, t) { t.push(JSON.stringify(e.content), -3, e); }(e, t)); break; case 4: Hd(e, t); break; case 5: !(function (e, t) { const { push: n, helper: r, pure: i } = t; i && n(jd), n(`${r(Pc)}(`), qd(e.content, t), n(')'); }(e, t)); break; case 8: Gd(e, t); break; case 3: !(function (e, t) { const { push: n, helper: r, pure: i } = t; i && n(jd), n(`${r(Sc)}(${JSON.stringify(e.content)})`, -3, e); }(e, t)); break; case 13: !(function (e, t) {
              const { push: n, helper: r, pure: i } = t; const {
                tag: o, props: a, children: s, patchFlag: l, dynamicProps: c, directives: u, isBlock: d, disableTracking: p, isComponent: f,
              } = e; let h; l && (h = String(l)), u && n(`${r(kc)}(`), d && n(`(${r(vc)}(${p ? 'true' : ''}), `), i && n(jd); n(`${r(d ? lu(t.inSSR, f) : su(t.inSSR, f))}(`, -2, e), Bd((function (e) { let t = e.length; for (;t-- && e[t] == null;);return e.slice(0, t + 1).map(((e) => e || 'null')); }([o, a, s, h, c])), t), n(')'), d && n(')'), u && (n(', '), qd(u, t), n(')'));
            }(e, t)); break; case 14: !(function (e, t) { const { push: n, helper: r, pure: i } = t; const o = w(e.callee) ? e.callee : r(e.callee); i && n(jd), n(`${o}(`, -2, e), Bd(e.arguments, t), n(')'); }(e, t)); break; case 15: !(function (e, t) {
              const {
                push: n, indent: r, deindent: i, newline: o,
              } = t; const { properties: a } = e; if (!a.length) return void n('{}', -2, e); const s = a.length > 1 || !1; n(s ? '{' : '{ '), s && r(); for (let e = 0; e < a.length; e++) { const { key: r, value: i } = a[e]; Ud(r, t), n(': '), qd(i, t), e < a.length - 1 && (n(','), o()); }s && i(), n(s ? '}' : ' }');
            }(e, t)); break; case 17: !(function (e, t) { zd(e.elements, t); }(e, t)); break; case 18: !(function (e, t) {
              const { push: n, indent: r, deindent: i } = t; const {
                params: o, returns: a, body: s, newline: l, isSlot: c,
              } = e; c && n(`_${Kc[Uc]}(`), n('(', -2, e), m(o) ? Bd(o, t) : o && qd(o, t), n(') => '), (l || s) && (n('{'), r()), a ? (l && n('return '), m(a) ? zd(a, t) : qd(a, t)) : s && qd(s, t), (l || s) && (i(), n('}')), c && (e.isNonScopedSlot && n(', undefined, true'), n(')'));
            }(e, t)); break; case 19: !(function (e, t) {
              const {
                test: n, consequent: r, alternate: i, newline: o,
              } = e; const {
                push: a, indent: s, deindent: l, newline: c,
              } = t; if (n.type === 4) { const e = !Cu(n.content); e && a('('), Hd(n, t), e && a(')'); } else a('('), qd(n, t), a(')'); o && s(), t.indentLevel++, o || a(' '), a('? '), qd(r, t), t.indentLevel--, o && c(), o || a(' '), a(': '); const u = i.type === 19; u || t.indentLevel++, qd(i, t), u || t.indentLevel--, o && l(!0);
            }(e, t)); break; case 20: !(function (e, t) {
              const {
                push: n, helper: r, indent: i, deindent: o, newline: a,
              } = t; const { needPauseTracking: s, needArraySpread: l } = e; l && n('[...('), n(`_cache[${e.index}] || (`), s && (i(), n(`${r(qc)}(-1`), e.inVOnce && n(', true'), n('),'), a(), n('(')), n(`_cache[${e.index}] = `), qd(e.value, t), s && (n(`).cacheIndex = ${e.index},`), a(), n(`${r(qc)}(1),`), a(), n(`_cache[${e.index}]`), o()), n(')'), l && n(')]');
            }(e, t)); break; case 21: Bd(e.body, t, !0, !1);
          }
        }
      } function Hd(e, t) { const { content: n, isStatic: r } = e; t.push(r ? JSON.stringify(n) : n, -3, e); } function Gd(e, t) { for (let n = 0; n < e.children.length; n++) { const r = e.children[n]; w(r) ? t.push(r, -3) : qd(r, t); } } function Ud(e, t) { const { push: n } = t; e.type === 8 ? (n('['), Gd(e, t), n(']')) : e.isStatic ? n(Cu(e.content) ? e.content : JSON.stringify(e.content), -2, e) : n(`[${e.content}]`, -3, e); } new RegExp(`\\b${'arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield'.split(',').join('\\b|\\b')}\\b`); const $d = Rd(/^(if|else|else-if)$/, ((e, t, n) => (function (e, t, n, r) { if (!(t.name === 'else' || t.exp && t.exp.content.trim())) { const r = t.exp ? t.exp.loc : e.loc; n.onError(xu(28, t.loc)), t.exp = nu('true', !1, r); } if (t.name === 'if') { const o = Wd(e, t); const a = { type: 9, loc: (i = e.loc, Sd(i.start.offset, i.end.offset)), branches: [o] }; if (n.replaceNode(a), r) return r(a, o, !0); } else { const i = n.parent.children; let o = i.indexOf(e); for (;o-- >= -1;) { const a = i[o]; if (a && a.type === 3)n.removeNode(a); else { if (!a || a.type !== 2 || a.content.trim().length) { if (a && a.type === 9) { t.name === 'else-if' && void 0 === a.branches[a.branches.length - 1].condition && n.onError(xu(30, e.loc)), n.removeNode(); const i = Wd(e, t); a.branches.push(i); const o = r && r(a, i, !1); Dd(i, n), o && o(), n.currentNode = null; } else n.onError(xu(30, e.loc)); break; }n.removeNode(a); } } } let i; }(e, t, n, ((e, t, r) => { const i = n.parent.children; let o = i.indexOf(e); let a = 0; for (;o-- >= 0;) { const e = i[o]; e && e.type === 9 && (a += e.branches.length); } return () => { if (r)e.codegenNode = Yd(t, a, n); else { const r = (function (e) { for (;;) if (e.type === 19) { if (e.alternate.type !== 19) return e; e = e.alternate; } else e.type === 20 && (e = e.value); }(e.codegenNode)); r.alternate = Yd(t, a + e.branches.length - 1, n); } }; }))))); function Wd(e, t) {
        const n = e.tagType === 3; return {
          type: 10, loc: e.loc, condition: t.name === 'else' ? void 0 : t.exp, children: n && !Iu(e, 'for') ? e.children : [e], userKey: Nu(e, 'key'), isTemplateIf: n,
        };
      } function Yd(e, t, n) { return e.condition ? au(e.condition, Xd(e, t, n), iu(n.helper(Sc), ['""', 'true'])) : Xd(e, t, n); } function Xd(e, t, n) { const { helper: r } = n; const i = tu('key', nu(`${t}`, !1, Jc, 2)); const { children: o } = e; const a = o[0]; if (o.length !== 1 || a.type !== 1) { if (o.length === 1 && a.type === 11) { const e = a.codegenNode; return qu(e, i, n), e; } { const t = 64; return Qc(n, r(dc), eu([i]), o, t, void 0, void 0, !0, !1, !1, e.loc); } } { const e = a.codegenNode; const t = (s = e).type === 14 && s.callee === Yc ? s.arguments[1].returns : s; return t.type === 13 && cu(t, n), qu(t, i, n), e; } let s; } const Kd = (e, t, n) => { const { modifiers: r, loc: i } = e; const o = e.arg; let{ exp: a } = e; if (a && a.type === 4 && !a.content.trim() && (a = void 0), !a) { if (o.type !== 4 || !o.isStatic) return n.onError(xu(52, o.loc)), { props: [tu(o, nu('', !0, i))] }; Jd(e), a = e.exp; } return o.type !== 4 ? (o.children.unshift('('), o.children.push(') || ""')) : o.isStatic || (o.content = `${o.content} || ""`), r.some(((e) => e.content === 'camel')) && (o.type === 4 ? o.isStatic ? o.content = I(o.content) : o.content = `${n.helperString(Fc)}(${o.content})` : (o.children.unshift(`${n.helperString(Fc)}(`), o.children.push(')'))), n.inSSR || (r.some(((e) => e.content === 'prop')) && Qd(o, '.'), r.some(((e) => e.content === 'attr')) && Qd(o, '^')), { props: [tu(o, a)] }; }; const Jd = (e, t) => { const n = e.arg; const r = I(n.content); e.exp = nu(r, !1, n.loc); }; const Qd = (e, t) => { e.type === 4 ? e.isStatic ? e.content = t + e.content : e.content = `\`${t}\${${e.content}}\`` : (e.children.unshift(`'${t}' + (`), e.children.push(')')); }; const Zd = Rd('for', ((e, t, n) => {
        const { helper: r, removeHelper: i } = n; return (function (e, t, n, r) {
          if (!t.exp) return void n.onError(xu(31, t.loc)); const i = t.forParseResult; if (!i) return void n.onError(xu(32, t.loc)); ep(i); const { addIdentifiers: o, removeIdentifiers: a, scopes: s } = n; const {
            source: l, value: c, key: u, index: d,
          } = i; const p = {
            type: 11, loc: t.loc, source: l, valueAlias: c, keyAlias: u, objectIndexAlias: d, parseResult: i, children: Vu(e) ? e.children : [e],
          }; n.replaceNode(p), s.vFor++; const f = r && r(p); return () => { s.vFor--, f && f(); };
        }(e, t, n, ((t) => { const o = iu(r(Mc), [t.source]); const a = Vu(e); const s = Iu(e, 'memo'); const l = Nu(e, 'key', !1, !0); l && l.type === 7 && !l.exp && Jd(l); const c = l && (l.type === 6 ? l.value ? nu(l.value.content, !0) : void 0 : l.exp); const u = l && c ? tu('key', c) : null; const d = t.source.type === 4 && t.source.constType > 0; const p = d ? 64 : l ? 128 : 256; return t.codegenNode = Qc(n, r(dc), void 0, o, p, void 0, void 0, !0, !d, !1, e.loc), () => { let l; const { children: p } = t; const f = p.length !== 1 || p[0].type !== 1; const h = Fu(e) ? e : a && e.children.length === 1 && Fu(e.children[0]) ? e.children[0] : null; if (h ? (l = h.codegenNode, a && u && qu(l, u, n)) : f ? l = Qc(n, r(dc), u ? eu([u]) : void 0, e.children, 64, void 0, void 0, !0, void 0, !1) : (l = p[0].codegenNode, a && u && qu(l, u, n), l.isBlock !== !d && (l.isBlock ? (i(vc), i(lu(n.inSSR, l.isComponent))) : i(su(n.inSSR, l.isComponent))), l.isBlock = !d, l.isBlock ? (r(vc), r(lu(n.inSSR, l.isComponent))) : r(su(n.inSSR, l.isComponent))), s) { const e = ou(tp(t.parseResult, [nu('_cached')])); e.body = { type: 21, body: [ru(['const _memo = (', s.exp, ')']), ru(['if (_cached', ...c ? [' && _cached.key === ', c] : [], ` && ${n.helperString(Xc)}(_cached, _memo)) return _cached`]), ru(['const _item = ', l]), nu('_item.memo = _memo'), nu('return _item')], loc: Jc }, o.arguments.push(e, nu('_cache'), nu(String(n.cached.length))), n.cached.push(null); } else o.arguments.push(ou(tp(t.parseResult), l, !0)); }; })));
      })); function ep(e, t) { e.finalized || (e.finalized = !0); } function tp({ value: e, key: t, index: n }, r = []) { return (function (e) { let t = e.length; for (;t-- && !e[t];);return e.slice(0, t + 1).map(((e, t) => e || nu('_'.repeat(t + 1), !1))); }([e, t, n, ...r])); } const np = nu('undefined', !1); const rp = (e, t) => { if (e.type === 1 && (e.tagType === 1 || e.tagType === 3)) { const n = Iu(e, 'slot'); if (n) return n.exp, t.scopes.vSlot++, () => { t.scopes.vSlot--; }; } }; const ip = (e, t, n, r) => ou(e, n, !1, !0, n.length ? n[0].loc : r); function op(e, t, n = ip) { t.helper(Uc); const { children: r, loc: i } = e; const o = []; const a = []; let s = t.scopes.vSlot > 0 || t.scopes.vFor > 0; const l = Iu(e, 'slot', !0); if (l) { const { arg: e, exp: t } = l; e && !Eu(e) && (s = !0), o.push(tu(e || nu('default', !0), n(t, void 0, r, i))); }let c = !1; let u = !1; const d = []; const p = new Set(); let f = 0; for (let e = 0; e < r.length; e++) { const i = r[e]; let h; if (!Vu(i) || !(h = Iu(i, 'slot', !0))) { i.type !== 3 && d.push(i); continue; } if (l) { t.onError(xu(37, h.loc)); break; }c = !0; const { children: m, loc: v } = i; const { arg: g = nu('default', !0), exp: y, loc: b } = h; let w; Eu(g) ? w = g ? g.content : 'default' : s = !0; const S = Iu(i, 'for'); const x = n(y, S, m, v); let E; let T; if (E = Iu(i, 'if'))s = !0, a.push(au(E.exp, ap(g, x, f++), np)); else if (T = Iu(i, /^else(-if)?$/, !0)) { let n; let i = e; for (;i-- && (n = r[i], n.type === 3););if (n && Vu(n) && Iu(n, /^(else-)?if$/)) { let e = a[a.length - 1]; for (;e.alternate.type === 19;)e = e.alternate; e.alternate = T.exp ? au(T.exp, ap(g, x, f++), np) : ap(g, x, f++); } else t.onError(xu(30, T.loc)); } else if (S) { s = !0; const e = S.forParseResult; e ? (ep(e), a.push(iu(t.helper(Mc), [e.source, ou(tp(e), ap(g, x), !0)]))) : t.onError(xu(32, S.loc)); } else { if (w) { if (p.has(w)) { t.onError(xu(38, b)); continue; }p.add(w), w === 'default' && (u = !0); }o.push(tu(g, x)); } } if (!l) { const e = (e, r) => { const o = n(e, void 0, r, i); return t.compatConfig && (o.isNonScopedSlot = !0), tu('default', o); }; c ? d.length && d.some(((e) => lp(e))) && (u ? t.onError(xu(39, d[0].loc)) : o.push(e(void 0, d))) : o.push(e(void 0, r)); } const h = s ? 2 : sp(e.children) ? 3 : 1; let m = eu(o.concat(tu('_', nu(`${h}`, !1))), i); return a.length && (m = iu(t.helper(Oc), [m, Zc(a)])), { slots: m, hasDynamicSlots: s }; } function ap(e, t, n) { const r = [tu('name', e), tu('fn', t)]; return n != null && r.push(tu('key', nu(String(n), !0))), eu(r); } function sp(e) { for (let t = 0; t < e.length; t++) { const n = e[t]; switch (n.type) { case 1: if (n.tagType === 2 || sp(n.children)) return !0; break; case 9: if (sp(n.branches)) return !0; break; case 10: case 11: if (sp(n.children)) return !0; } } return !1; } function lp(e) { return e.type !== 2 && e.type !== 12 || (e.type === 2 ? !!e.content.trim() : lp(e.content)); } const cp = new WeakMap(); const
        up = (e, t) => function () { if ((e = t.currentNode).type !== 1 || e.tagType !== 0 && e.tagType !== 1) return; const { tag: n, props: r } = e; const i = e.tagType === 1; const o = i ? (function (e, t, n = !1) { let{ tag: r } = e; const i = hp(r); const o = Nu(e, 'is', !1, !0); if (o) if (i || yu('COMPILER_IS_ON_ELEMENT', t)) { let e; if (o.type === 6 ? e = o.value && nu(o.value.content, !0) : (e = o.exp, e || (e = nu('is', !1, o.arg.loc))), e) return iu(t.helper(_c), [e]); } else o.type === 6 && o.value.content.startsWith('vue:') && (r = o.value.content.slice(4)); const a = Tu(r) || t.isBuiltInComponent(r); return a ? (n || t.helper(a), a) : (t.helper(Tc), t.components.add(r), Gu(r, 'component')); }(e, t)) : `"${n}"`; const a = x(o) && o.callee === _c; let s; let l; let c; let u; let d; let p = 0; let f = a || o === pc || o === fc || !i && (n === 'svg' || n === 'foreignObject' || n === 'math'); if (r.length > 0) { const n = dp(e, t, void 0, i, a); s = n.props, p = n.patchFlag, u = n.dynamicPropNames; const r = n.directives; d = r && r.length ? Zc(r.map(((e) => (function (e, t) { const n = []; const r = cp.get(e); r ? n.push(t.helperString(r)) : (t.helper(Cc), t.directives.add(e.name), n.push(Gu(e.name, 'directive'))); const { loc: i } = e; if (e.exp && n.push(e.exp), e.arg && (e.exp || n.push('void 0'), n.push(e.arg)), Object.keys(e.modifiers).length) { e.arg || (e.exp || n.push('void 0'), n.push('void 0')); const t = nu('true', !1, i); n.push(eu(e.modifiers.map(((e) => tu(e, t))), i)); } return Zc(n, e.loc); }(e, t))))) : void 0, n.shouldUseBlock && (f = !0); } if (e.children.length > 0) if (o === hc && (f = !0, p |= 1024), i && o !== pc && o !== hc) { const { slots: n, hasDynamicSlots: r } = op(e, t); l = n, r && (p |= 1024); } else if (e.children.length === 1 && o !== pc) { const n = e.children[0]; const r = n.type; const i = r === 5 || r === 8; i && Md(n, t) === 0 && (p |= 1), l = i || r === 2 ? n : e.children; } else l = e.children; u && u.length && (c = (function (e) { let t = '['; for (let n = 0, r = e.length; n < r; n++)t += JSON.stringify(e[n]), n < r - 1 && (t += ', '); return `${t}]`; }(u))), e.codegenNode = Qc(t, o, s, l, p === 0 ? void 0 : p, c, d, !!f, !1, i, e.loc); }; function dp(e, t, n = e.props, r, i, o = !1) {
        const { tag: a, loc: s, children: l } = e; let u = []; const d = []; const p = []; const f = l.length > 0; let h = !1; let m = 0; let v = !1; let g = !1; let y = !1; let b = !1; let w = !1; let x = !1; const E = []; const T = (e) => { u.length && (d.push(eu(pp(u), s)), u = []), e && d.push(e); }; const _ = () => { t.scopes.vFor > 0 && u.push(tu(nu('ref_for', !0), nu('true'))); }; const C = ({ key: e, value: n }) => { if (Eu(e)) { const o = e.content; const a = c(o); if (!a || r && !i || o.toLowerCase() === 'onclick' || o === 'onUpdate:modelValue' || M(o) || (b = !0), a && M(o) && (x = !0), a && n.type === 14 && (n = n.arguments[0]), n.type === 20 || (n.type === 4 || n.type === 8) && Md(n, t) > 0) return; o === 'ref' ? v = !0 : o === 'class' ? g = !0 : o === 'style' ? y = !0 : o === 'key' || E.includes(o) || E.push(o), !r || o !== 'class' && o !== 'style' || E.includes(o) || E.push(o); } else w = !0; }; for (let i = 0; i < n.length; i++) {
          const l = n[i]; if (l.type === 6) {
            const {
              loc: e, name: n, nameLoc: r, value: i,
            } = l; const o = !0; if (n === 'ref' && (v = !0, _()), n === 'is' && (hp(a) || i && i.content.startsWith('vue:') || yu('COMPILER_IS_ON_ELEMENT', t))) continue; u.push(tu(nu(n, !0, r), nu(i ? i.content : '', o, i ? i.loc : e)));
          } else {
            const {
              name: n, arg: i, exp: c, loc: v, modifiers: g,
            } = l; const y = n === 'bind'; const b = n === 'on'; if (n === 'slot') { r || t.onError(xu(40, v)); continue; } if (n === 'once' || n === 'memo') continue; if (n === 'is' || y && Du(i, 'is') && (hp(a) || yu('COMPILER_IS_ON_ELEMENT', t))) continue; if (b && o) continue; if ((y && Du(i, 'key') || b && f && Du(i, 'vue:before-update')) && (h = !0), y && Du(i, 'ref') && _(), !i && (y || b)) {
              if (w = !0, c) {
                if (y) { if (_(), T(), yu('COMPILER_V_BIND_OBJECT_ORDER', t)) { d.unshift(c); continue; }d.push(c); } else {
                  T({
                    type: 14, loc: v, callee: t.helper(Vc), arguments: r ? [c] : [c, 'true'],
                  });
                }
              } else t.onError(xu(y ? 34 : 35, v)); continue;
            }y && g.some(((e) => e.content === 'prop')) && (m |= 32); const x = t.directiveTransforms[n]; if (x) { const { props: n, needRuntime: r } = x(l, e, t); !o && n.forEach(C), b && i && !Eu(i) ? T(eu(n, s)) : u.push(...n), r && (p.push(l), S(r) && cp.set(l, r)); } else A(n) || (p.push(l), f && (h = !0));
          }
        }let L; if (d.length ? (T(), L = d.length > 1 ? iu(t.helper(Ic), d, s) : d[0]) : u.length && (L = eu(pp(u), s)), w ? m |= 16 : (g && !r && (m |= 2), y && !r && (m |= 4), E.length && (m |= 8), b && (m |= 32)), h || m !== 0 && m !== 32 || !(v || x || p.length > 0) || (m |= 512), !t.inSSR && L) switch (L.type) { case 15: let e = -1; let n = -1; let r = !1; for (let t = 0; t < L.properties.length; t++) { const i = L.properties[t].key; Eu(i) ? i.content === 'class' ? e = t : i.content === 'style' && (n = t) : i.isHandlerKey || (r = !0); } const i = L.properties[e]; const o = L.properties[n]; r ? L = iu(t.helper(Rc), [L]) : (i && !Eu(i.value) && (i.value = iu(t.helper(Nc), [i.value])), o && (y || o.value.type === 4 && o.value.content.trim()[0] === '[' || o.value.type === 17) && (o.value = iu(t.helper(Dc), [o.value]))); break; case 14: break; default: L = iu(t.helper(Rc), [iu(t.helper(jc), [L])]); } return {
          props: L, directives: p, patchFlag: m, dynamicPropNames: E, shouldUseBlock: h,
        };
      } function pp(e) {
        const t = new Map(); const
          n = []; for (let r = 0; r < e.length; r++) { const i = e[r]; if (i.key.type === 8 || !i.key.isStatic) { n.push(i); continue; } const o = i.key.content; const a = t.get(o); a ? (o === 'style' || o === 'class' || c(o)) && fp(a, i) : (t.set(o, i), n.push(i)); } return n;
      } function fp(e, t) { e.value.type === 17 ? e.value.elements.push(t.value) : e.value = Zc([e.value, t.value], e.loc); } function hp(e) { return e === 'component' || e === 'Component'; } const mp = (e, t) => { if (Fu(e)) { const { children: n, loc: r } = e; const { slotName: i, slotProps: o } = (function (e, t) { let n; let r = '"default"'; const i = []; for (let t = 0; t < e.props.length; t++) { const n = e.props[t]; if (n.type === 6)n.value && (n.name === 'name' ? r = JSON.stringify(n.value.content) : (n.name = I(n.name), i.push(n))); else if (n.name === 'bind' && Du(n.arg, 'name')) { if (n.exp)r = n.exp; else if (n.arg && n.arg.type === 4) { const e = I(n.arg.content); r = n.exp = nu(e, !1, n.arg.loc); } } else n.name === 'bind' && n.arg && Eu(n.arg) && (n.arg.content = I(n.arg.content)), i.push(n); } if (i.length > 0) { const { props: r, directives: o } = dp(e, t, i, !1, !1); n = r, o.length && t.onError(xu(36, o[0].loc)); } return { slotName: r, slotProps: n }; }(e, t)); const a = [t.prefixIdentifiers ? '_ctx.$slots' : '$slots', i, '{}', 'undefined', 'true']; let s = 2; o && (a[2] = o, s = 3), n.length && (a[3] = ou([], n, !1, !1, r), s = 4), t.scopeId && !t.slotted && (s = 5), a.splice(s), e.codegenNode = iu(t.helper(Ac), a, r); } }; const vp = (e, t, n, r) => { const { loc: i, modifiers: o, arg: a } = e; let s; if (e.exp || o.length || n.onError(xu(35, i)), a.type === 4) if (a.isStatic) { let e = a.content; e.startsWith('vue:') && (e = `vnode-${e.slice(4)}`), s = nu(t.tagType !== 0 || e.startsWith('vnode') || !/[A-Z]/.test(e) ? j(I(e)) : `on:${e}`, !0, a.loc); } else s = ru([`${n.helperString(Bc)}(`, a, ')']); else s = a, s.children.unshift(`${n.helperString(Bc)}(`), s.children.push(')'); let l = e.exp; l && !l.content.trim() && (l = void 0); const c = n.cacheHandlers && !l && !n.inVOnce; if (l) { const e = Ou(l); const t = !(e || ((e) => Pu.test(Au(e)))(l)); const n = l.content.includes(';'); (t || c && e) && (l = ru([`${t ? '$event' : '(...args)'} => ${n ? '{' : '('}`, l, n ? '}' : ')'])); }let u = { props: [tu(s, l || nu('() => {}', !1, i))] }; return r && (u = r(u)), c && (u.props[0].value = n.cache(u.props[0].value)), u.props.forEach(((e) => e.key.isHandlerKey = !0)), u; }; const gp = (e, t) => {
        if (e.type === 0 || e.type === 1 || e.type === 11 || e.type === 10) {
          return () => {
            const n = e.children; let r; let i = !1; for (let e = 0; e < n.length; e++) { const t = n[e]; if (Ru(t)) { i = !0; for (let i = e + 1; i < n.length; i++) { const o = n[i]; if (!Ru(o)) { r = void 0; break; }r || (r = n[e] = ru([t], t.loc)), r.children.push(' + ', o), n.splice(i, 1), i--; } } } if (i && (n.length !== 1 || e.type !== 0 && (e.type !== 1 || e.tagType !== 0 || e.props.find(((e) => e.type === 7 && !t.directiveTransforms[e.name])) || e.tag === 'template'))) {
              for (let e = 0; e < n.length; e++) {
                const r = n[e]; if (Ru(r) || r.type === 8) {
                  const i = []; r.type === 2 && r.content === ' ' || i.push(r), t.ssr || Md(r, t) !== 0 || i.push('1'), n[e] = {
                    type: 12, content: r, loc: r.loc, codegenNode: iu(t.helper(xc), i),
                  };
                }
              }
            }
          };
        }
      }; const yp = new WeakSet(); const bp = (e, t) => { if (e.type === 1 && Iu(e, 'once', !0)) { if (yp.has(e) || t.inVOnce || t.inSSR) return; return yp.add(e), t.inVOnce = !0, t.helper(qc), () => { t.inVOnce = !1; const e = t.currentNode; e.codegenNode && (e.codegenNode = t.cache(e.codegenNode, !0, !0)); }; } }; const wp = (e, t, n) => { const { exp: r, arg: i } = e; if (!r) return n.onError(xu(41, e.loc)), Sp(); const o = r.loc.source.trim(); const a = r.type === 4 ? r.content : o; const s = n.bindingMetadata[o]; if (s === 'props' || s === 'props-aliased') return n.onError(xu(44, r.loc)), Sp(); if (!a.trim() || !Ou(r)) return n.onError(xu(42, r.loc)), Sp(); const l = i || nu('modelValue', !0); const c = i ? Eu(i) ? `onUpdate:${I(i.content)}` : ru(['"onUpdate:" + ', i]) : 'onUpdate:modelValue'; let u; u = ru([`${n.isTS ? '($event: any)' : '$event'} => ((`, r, ') = $event)']); const d = [tu(l, e.exp), tu(c, u)]; if (e.modifiers.length && t.tagType === 1) { const t = e.modifiers.map(((e) => e.content)).map(((e) => `${Cu(e) ? e : JSON.stringify(e)}: true`)).join(', '); const n = i ? Eu(i) ? `${i.content}Modifiers` : ru([i, ' + "Modifiers"']) : 'modelModifiers'; d.push(tu(n, nu(`{ ${t} }`, !1, e.loc, 2))); } return Sp(d); }; function Sp(e = []) { return { props: e }; } const xp = /[\w).+\-_$\]]/; const Ep = (e, t) => { yu('COMPILER_FILTERS', t) && (e.type === 5 ? Tp(e.content, t) : e.type === 1 && e.props.forEach(((e) => { e.type === 7 && e.name !== 'for' && e.exp && Tp(e.exp, t); }))); }; function Tp(e, t) { if (e.type === 4)_p(e, t); else for (let n = 0; n < e.children.length; n++) { const r = e.children[n]; typeof r === 'object' && (r.type === 4 ? _p(r, t) : r.type === 8 ? Tp(e, t) : r.type === 5 && Tp(r.content, t)); } } function _p(e, t) { const n = e.content; let r; let i; let o; let a; let s = !1; let l = !1; let c = !1; let u = !1; let d = 0; let p = 0; let f = 0; let h = 0; const m = []; for (o = 0; o < n.length; o++) if (i = r, r = n.charCodeAt(o), s)r === 39 && i !== 92 && (s = !1); else if (l)r === 34 && i !== 92 && (l = !1); else if (c)r === 96 && i !== 92 && (c = !1); else if (u)r === 47 && i !== 92 && (u = !1); else if (r !== 124 || n.charCodeAt(o + 1) === 124 || n.charCodeAt(o - 1) === 124 || d || p || f) { switch (r) { case 34: l = !0; break; case 39: s = !0; break; case 96: c = !0; break; case 40: f++; break; case 41: f--; break; case 91: p++; break; case 93: p--; break; case 123: d++; break; case 125: d--; } if (r === 47) { let e; let t = o - 1; for (;t >= 0 && (e = n.charAt(t), e === ' '); t--);e && xp.test(e) || (u = !0); } } else void 0 === a ? (h = o + 1, a = n.slice(0, o).trim()) : v(); function v() { m.push(n.slice(h, o).trim()), h = o + 1; } if (void 0 === a ? a = n.slice(0, o).trim() : h !== 0 && v(), m.length) { for (o = 0; o < m.length; o++)a = Cp(a, m[o], t); e.content = a, e.ast = void 0; } } function Cp(e, t, n) { n.helper(Lc); const r = t.indexOf('('); if (r < 0) return n.filters.add(t), `${Gu(t, 'filter')}(${e})`; { const i = t.slice(0, r); const o = t.slice(r + 1); return n.filters.add(i), `${Gu(i, 'filter')}(${e}${o !== ')' ? `,${o}` : o}`; } } const Lp = new WeakSet(); const
        kp = (e, t) => { if (e.type === 1) { const n = Iu(e, 'memo'); if (!n || Lp.has(e)) return; return Lp.add(e), () => { const r = e.codegenNode || t.currentNode.codegenNode; r && r.type === 13 && (e.tagType !== 1 && cu(r, t), e.codegenNode = iu(t.helper(Yc), [n.exp, ou(void 0, r), '_cache', String(t.cached.length)]), t.cached.push(null)); }; } }; function Mp(e, t = {}) {
        const n = t.onError || wu; const r = t.mode === 'module'; !0 === t.prefixIdentifiers ? n(xu(47)) : r && n(xu(48)), t.cacheHandlers && n(xu(49)), t.scopeId && !r && n(xu(50)); const i = { ...t, prefixIdentifiers: !1 }; const o = w(e) ? (function (e, t) {
          if (od.reset(), Ku = null, Ju = null, Qu = '', Zu = -1, ed = -1, id.length = 0, Xu = e, Wu = { ...$u }, t) { let e; for (e in t)t[e] != null && (Wu[e] = t[e]); }od.mode = Wu.parseMode === 'html' ? 1 : Wu.parseMode === 'sfc' ? 2 : 0, od.inXML = Wu.ns === 1 || Wu.ns === 2; const n = t && t.delimiters; n && (od.delimiterOpen = mu(n[0]), od.delimiterClose = mu(n[1])); const r = Yu = (function (e, t = '') {
            return {
              type: 0, source: t, children: [], helpers: new Set(), components: [], directives: [], hoists: [], imports: [], cached: [], temps: 0, codegenNode: void 0, loc: Jc,
            };
          }(0, e)); return od.parse(Xu), r.loc = Sd(0, e.length), r.children = vd(r.children), Yu = null, r;
        }(e, i)) : e; const [a, s] = [[bp, $d, kp, Zd, Ep, mp, up, rp, gp], { on: vp, bind: Kd, model: wp }]; return Nd(o, { ...i, nodeTransforms: [...a, ...t.nodeTransforms || []], directiveTransforms: { ...s, ...t.directiveTransforms || {} } }), (function (e, t = {}) {
          const n = (function (e, {
            mode: t = 'function', prefixIdentifiers: n = t === 'module', sourceMap: r = !1, filename: i = 'template.vue.html', scopeId: o = null, optimizeImports: a = !1, runtimeGlobalName: s = 'Vue', runtimeModuleName: l = 'vue', ssrRuntimeModuleName: c = 'vue/server-renderer', ssr: u = !1, isTS: d = !1, inSSR: p = !1,
          }) {
            const f = {
              mode: t, prefixIdentifiers: n, sourceMap: r, filename: i, scopeId: o, optimizeImports: a, runtimeGlobalName: s, runtimeModuleName: l, ssrRuntimeModuleName: c, ssr: u, isTS: d, inSSR: p, source: e.source, code: '', column: 1, line: 1, offset: 0, indentLevel: 0, pure: !1, map: void 0, helper: (e) => `_${Kc[e]}`, push(e, t = -2, n) { f.code += e; }, indent() { h(++f.indentLevel); }, deindent(e = !1) { e ? --f.indentLevel : h(--f.indentLevel); }, newline() { h(f.indentLevel); },
            }; function h(e) { f.push(`\n${'  '.repeat(e)}`, 0); } return f;
          }(e, t)); t.onContextCreated && t.onContextCreated(n); const {
            mode: r, push: i, prefixIdentifiers: o, indent: a, deindent: s, newline: l, scopeId: c, ssr: u,
          } = n; const d = Array.from(e.helpers); const p = d.length > 0; const f = !o && r !== 'module'; if ((function (e, t) {
            const {
              ssr: n, prefixIdentifiers: r, push: i, newline: o, runtimeModuleName: a, runtimeGlobalName: s, ssrRuntimeModuleName: l,
            } = t; const c = s; const u = Array.from(e.helpers); u.length > 0 && (i(`const _Vue = ${c}\n`, -1), e.hoists.length) && i(`const { ${[bc, wc, Sc, xc, Ec].filter(((e) => u.includes(e))).map(Vd).join(', ')} } = _Vue\n`, -1), (function (e, t) { if (!e.length) return; t.pure = !0; const { push: n, newline: r } = t; r(); for (let i = 0; i < e.length; i++) { const o = e[i]; o && (n(`const _hoisted_${i + 1} = `), qd(o, t), r()); }t.pure = !1; }(e.hoists, t)), o(), i('return ');
          }(e, n)), i(`function ${u ? 'ssrRender' : 'render'}(${(u ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']).join(', ')}) {`), a(), f && (i('with (_ctx) {'), a(), p && (i(`const { ${d.map(Vd).join(', ')} } = _Vue\n`, -1), l())), e.components.length && (Fd(e.components, 'component', n), (e.directives.length || e.temps > 0) && l()), e.directives.length && (Fd(e.directives, 'directive', n), e.temps > 0 && l()), e.filters && e.filters.length && (l(), Fd(e.filters, 'filter', n), l()), e.temps > 0) { i('let '); for (let t = 0; t < e.temps; t++)i(`${t > 0 ? ', ' : ''}_temp${t}`); } return (e.components.length || e.directives.length || e.temps) && (i('\n', 0), l()), u || i('return '), e.codegenNode ? qd(e.codegenNode, n) : i('null'), f && (s(), i('}')), s(), i('}'), {
            ast: e, code: n.code, preamble: '', map: n.map ? n.map.toJSON() : void 0,
          };
        }(o, i));
      } const Ap = Symbol(''); const Op = Symbol(''); const Pp = Symbol(''); const Ip = Symbol(''); const Np = Symbol(''); const Dp = Symbol(''); const Rp = Symbol(''); const jp = Symbol(''); const Vp = Symbol(''); const Fp = Symbol(''); let zp; let Bp; zp = {
        [Ap]: 'vModelRadio', [Op]: 'vModelCheckbox', [Pp]: 'vModelText', [Ip]: 'vModelSelect', [Np]: 'vModelDynamic', [Dp]: 'withModifiers', [Rp]: 'withKeys', [jp]: 'vShow', [Vp]: 'Transition', [Fp]: 'TransitionGroup',
      }, Object.getOwnPropertySymbols(zp).forEach(((e) => { Kc[e] = zp[e]; })); const qp = {
        parseMode: 'html', isVoidTag: ne, isNativeTag: (e) => Z(e) || ee(e) || te(e), isPreTag: (e) => e === 'pre', isIgnoreNewlineTag: (e) => e === 'pre' || e === 'textarea', decodeEntities(e, t = !1) { return Bp || (Bp = document.createElement('div')), t ? (Bp.innerHTML = `<div foo="${e.replace(/"/g, '&quot;')}">`, Bp.children[0].getAttribute('foo')) : (Bp.innerHTML = e, Bp.textContent); }, isBuiltInComponent: (e) => (e === 'Transition' || e === 'transition' ? Vp : e === 'TransitionGroup' || e === 'transition-group' ? Fp : void 0), getNamespace(e, t, n) { let r = t ? t.ns : n; if (t && r === 2) if (t.tag === 'annotation-xml') { if (e === 'svg') return 1; t.props.some(((e) => e.type === 6 && e.name === 'encoding' && e.value != null && (e.value.content === 'text/html' || e.value.content === 'application/xhtml+xml'))) && (r = 0); } else /^m(?:[ions]|text)$/.test(t.tag) && e !== 'mglyph' && e !== 'malignmark' && (r = 0); else t && r === 1 && (t.tag !== 'foreignObject' && t.tag !== 'desc' && t.tag !== 'title' || (r = 0)); if (r === 0) { if (e === 'svg') return 1; if (e === 'math') return 2; } return r; },
      }; const Hp = (e, t) => { const n = K(e); return nu(JSON.stringify(n), !1, t, 3); }; function Gp(e, t) { return xu(e, t); } const Up = i('passive,once,capture'); const $p = i('stop,prevent,self,ctrl,shift,alt,meta,exact,middle'); const Wp = i('left,right'); const Yp = i('onkeyup,onkeydown,onkeypress'); const Xp = (e, t) => (Eu(e) && e.content.toLowerCase() === 'onclick' ? nu(t, !0) : e.type !== 4 ? ru(['(', e, `) === "onClick" ? "${t}" : (`, e, ')']) : e); const Kp = (e, t) => { e.type !== 1 || e.tagType !== 0 || e.tag !== 'script' && e.tag !== 'style' || t.removeNode(); }; const Jp = [(e) => {
        e.type === 1 && e.props.forEach(((t, n) => {
          t.type === 6 && t.name === 'style' && t.value && (e.props[n] = {
            type: 7, name: 'bind', arg: nu('style', !0, t.loc), exp: Hp(t.value.content, t.loc), modifiers: [], loc: t.loc,
          });
        }));
      }]; const Qp = {
        cloak: () => ({ props: [] }), html: (e, t, n) => { const { exp: r, loc: i } = e; return r || n.onError(Gp(53, i)), t.children.length && (n.onError(Gp(54, i)), t.children.length = 0), { props: [tu(nu('innerHTML', !0, i), r || nu('', !0))] }; }, text: (e, t, n) => { const { exp: r, loc: i } = e; return r || n.onError(Gp(55, i)), t.children.length && (n.onError(Gp(56, i)), t.children.length = 0), { props: [tu(nu('textContent', !0), r ? Md(r, n) > 0 ? r : iu(n.helperString(Pc), [r], i) : nu('', !0))] }; }, model: (e, t, n) => { const r = wp(e, t, n); if (!r.props.length || t.tagType === 1) return r; e.arg && n.onError(Gp(58, e.arg.loc)); const { tag: i } = t; const o = n.isCustomElement(i); if (i === 'input' || i === 'textarea' || i === 'select' || o) { let a = Pp; let s = !1; if (i === 'input' || o) { const r = Nu(t, 'type'); if (r) { if (r.type === 7)a = Np; else if (r.value) switch (r.value.content) { case 'radio': a = Ap; break; case 'checkbox': a = Op; break; case 'file': s = !0, n.onError(Gp(59, e.loc)); } } else (function (e) { return e.props.some(((e) => !(e.type !== 7 || e.name !== 'bind' || e.arg && e.arg.type === 4 && e.arg.isStatic))); }(t)) && (a = Np); } else i === 'select' && (a = Ip); s || (r.needRuntime = n.helper(a)); } else n.onError(Gp(57, e.loc)); return r.props = r.props.filter(((e) => !(e.key.type === 4 && e.key.content === 'modelValue'))), r; }, on: (e, t, n) => vp(e, t, n, ((t) => { const { modifiers: r } = e; if (!r.length) return t; let{ key: i, value: o } = t.props[0]; const { keyModifiers: a, nonKeyModifiers: s, eventOptionModifiers: l } = ((e, t, n) => { const r = []; const i = []; const o = []; for (let a = 0; a < t.length; a++) { const s = t[a].content; s === 'native' && bu('COMPILER_V_ON_NATIVE', n) || Up(s) ? o.push(s) : Wp(s) ? Eu(e) ? Yp(e.content.toLowerCase()) ? r.push(s) : i.push(s) : (r.push(s), i.push(s)) : $p(s) ? i.push(s) : r.push(s); } return { keyModifiers: r, nonKeyModifiers: i, eventOptionModifiers: o }; })(i, r, n, e.loc); if (s.includes('right') && (i = Xp(i, 'onContextmenu')), s.includes('middle') && (i = Xp(i, 'onMouseup')), s.length && (o = iu(n.helper(Dp), [o, JSON.stringify(s)])), !a.length || Eu(i) && !Yp(i.content.toLowerCase()) || (o = iu(n.helper(Rp), [o, JSON.stringify(a)])), l.length) { const e = l.map(R).join(''); i = Eu(i) ? nu(`${i.content}${e}`, !0) : ru(['(', i, `) + "${e}"`]); } return { props: [tu(i, o)] }; })), show: (e, t, n) => { const { exp: r, loc: i } = e; return r || n.onError(Gp(61, i)), { props: [], needRuntime: n.helper(jp) }; },
      }; const Zp = Object.create(null); ts(((e, t) => {
        if (!w(e)) { if (!e.nodeType) return s; e = e.innerHTML; } const n = (function (e, t) { return e + JSON.stringify(t, ((e, t) => (typeof t === 'function' ? t.toString() : t))); }(e, t)); const i = Zp[n]; if (i) return i; if (e[0] === '#') { const t = document.querySelector(e); e = t ? t.innerHTML : ''; } const o = {
          hoistStatic: !0, onError: void 0, onWarn: s, ...t,
        }; o.isCustomElement || typeof customElements === 'undefined' || (o.isCustomElement = (e) => !!customElements.get(e)); const { code: a } = (function (e, t = {}) {
          return Mp(e, {
            ...qp, ...t, nodeTransforms: [Kp, ...Jp, ...t.nodeTransforms || []], directiveTransforms: { ...Qp, ...t.directiveTransforms || {} }, transformHoist: null,
          });
        }(e, o)); const l = new Function('Vue', a)(r); return l._rc = !0, Zp[n] = l;
      }));
    },
    927: (e, t, n) => {
      function r(e, t = {}) {
        r.baseURL = r.baseURL || new URL(window.RUM_BASE == null ? 'https://rum.hlx.page' : window.RUM_BASE, window.location), r.defer = r.defer || []; const n = (e) => { r[e] = r[e] || ((...t) => r.defer.push({ fnname: e, args: t })); }; r.drain = r.drain || ((e, t) => { r[e] = t, r.defer.filter((({ fnname: t }) => e === t)).forEach((({ fnname: e, args: t }) => r[e](...t))); }), r.always = r.always || [], r.always.on = (e, t) => { r.always[e] = t; }, r.on = (e, t) => { r.cases[e] = t; }, n('observe'), n('cwv'); try {
          if (window.hlx = window.hlx || {}, !window.hlx.rum) {
            const e = new URLSearchParams(window.location.search).get('rum') === 'on' ? 1 : 100; const t = Math.random().toString(36).slice(-4); const n = Math.random(); const i = n * e < 1; const o = window.performance ? window.performance.timeOrigin : Date.now(); const a = { full: () => window.location.href, origin: () => window.location.origin, path: () => window.location.href.replace(/\?.*$/, '') }; window.hlx.rum = {
              weight: e, id: t, random: n, isSelected: i, firstReadTime: o, sampleRUM: r, sanitizeURL: a[window.hlx.RUM_MASK_URL || 'path'],
            };
          } const { weight: n, id: i, firstReadTime: o } = window.hlx.rum; if (window.hlx && window.hlx.rum && window.hlx.rum.isSelected) {
            const a = ['weight', 'id', 'referer', 'checkpoint', 't', 'source', 'target', 'cwv', 'CLS', 'FID', 'LCP', 'INP', 'TTFB']; const s = (s = t) => {
              const l = Math.round(window.performance ? window.performance.now() : Date.now() - o); const c = JSON.stringify({
                weight: n, id: i, referer: window.hlx.rum.sanitizeURL(), checkpoint: e, t: l, ...t,
              }, a); const u = new URL(`.rum/${n}`, r.baseURL).href; navigator.sendBeacon(u, c), console.debug(`ping:${e}`, s);
            }; r.cases = r.cases || { cwv: () => r.cwv(t) || !0, lazy: () => { const e = document.createElement('script'); return e.src = new URL('.rum/@adobe/helix-rum-enhancer@^1/src/index.js', r.baseURL).href, document.head.appendChild(e), !0; } }, s(t), r.cases[e] && r.cases[e]();
          }r.always[e] && r.always[e](t);
        } catch (e) {}
      } function i(e) { return typeof e === 'string' ? e.toLowerCase().replace(/[^0-9a-z]/gi, '-').replace(/-+/g, '-').replace(/^-|-$/g, '') : ''; } async function o(e) { return new Promise(((t, n) => { if (document.querySelector(`head > link[href="${e}"]`))t(); else { const r = document.createElement('link'); r.rel = 'stylesheet', r.href = e, r.onload = t, r.onerror = n, document.head.append(r); } })); } function a(e, t = document) { const n = e && e.includes(':') ? 'property' : 'name'; return [...t.head.querySelectorAll(`meta[${n}="${e}"]`)].map(((e) => e.content)).join(', ') || ''; } function s(e, t = '', n = !1, r = [{ media: '(min-width: 600px)', width: '2000' }, { width: '750' }]) { const i = new URL(e, window.location.href); const o = document.createElement('picture'); const { pathname: a } = i; const s = a.substring(a.lastIndexOf('.') + 1); return r.forEach(((e) => { const t = document.createElement('source'); e.media && t.setAttribute('media', e.media), t.setAttribute('type', 'image/webp'), t.setAttribute('srcset', `${a}?width=${e.width}&format=webply&optimize=medium`), o.appendChild(t); })), r.forEach(((e, i) => { if (i < r.length - 1) { const t = document.createElement('source'); e.media && t.setAttribute('media', e.media), t.setAttribute('srcset', `${a}?width=${e.width}&format=${s}&optimize=medium`), o.appendChild(t); } else { const r = document.createElement('img'); r.setAttribute('loading', n ? 'eager' : 'lazy'), r.setAttribute('alt', t), o.appendChild(r), r.setAttribute('src', `${a}?width=${e.width}&format=${s}&optimize=medium`); } })), o; } function l() { const e = (e, t) => { t.split(',').forEach(((t) => { e.classList.add(i(t.trim())); })); }; const t = a('template'); t && e(document.body, t); const n = a('theme'); n && e(document.body, n); } function c(e) { e.querySelectorAll('a').forEach(((e) => { if (e.title = e.title || e.textContent, e.href !== e.textContent) { const t = e.parentElement; const n = e.parentElement.parentElement; e.querySelector('img') || (t.childNodes.length !== 1 || t.tagName !== 'P' && t.tagName !== 'DIV' || (e.className = 'button', t.classList.add('button-container')), t.childNodes.length === 1 && t.tagName === 'STRONG' && n.childNodes.length === 1 && n.tagName === 'P' && (e.className = 'button primary', n.classList.add('button-container')), t.childNodes.length === 1 && t.tagName === 'EM' && n.childNodes.length === 1 && n.tagName === 'P' && (e.className = 'button secondary', n.classList.add('button-container'))); } })); } function u(e, t = '') { [...e.querySelectorAll('span.icon')].forEach(((e) => { !(function (e, t = '', n = '') { if (Array.from(e.classList).find(((e) => e.includes('icon-images')))) { const r = e.classList[1]?.split('-'); const i = `/${r.slice(1, 2).join('/')}/${r.slice(2, -1).join('-')}.${r.slice(-1)}`; const o = document.createElement('img'); o.dataset.iconName = i, o.src = `${window.hlx.codeBasePath}${t + i}`, o.alt = n, o.loading = 'lazy', e.append(o); } else { const r = Array.from(e.classList).find(((e) => e.startsWith('icon-'))).substring(5); const i = document.createElement('img'); i.dataset.iconName = r, i.src = `${window.hlx.codeBasePath}${t}/icons/${r}.svg`, i.alt = n, i.loading = 'lazy', e.append(i); } }(e, t)); })); } function d(e) { e.querySelectorAll(':scope > div:not([data-section-status])').forEach(((e) => { const t = []; let n = !1; [...e.children].forEach(((e) => { if (e.tagName === 'DIV' && e.className || !n) { const r = document.createElement('div'); t.push(r), n = e.tagName !== 'DIV' || !e.className, n && r.classList.add('default-content-wrapper'); }t[t.length - 1].append(e); })), t.forEach(((t) => e.append(t))), e.classList.add('section'), e.dataset.sectionStatus = 'initialized', e.style.display = 'none'; const r = e.querySelector('div.section-metadata'); if (r) { const t = (function (e) { const t = {}; return e.querySelectorAll(':scope > div').forEach(((e) => { if (e.children) { const n = [...e.children]; if (n[1]) { const r = n[1]; const o = i(n[0].textContent); let a = ''; if (r.querySelector('a')) { const e = [...r.querySelectorAll('a')]; a = e.length === 1 ? e[0].href : e.map(((e) => e.href)); } else if (r.querySelector('img')) { const e = [...r.querySelectorAll('img')]; a = e.length === 1 ? e[0].src : e.map(((e) => e.src)); } else if (r.querySelector('p')) { const e = [...r.querySelectorAll('p')]; a = e.length === 1 ? e[0].textContent : e.map(((e) => e.textContent)); } else a = e.children[1].textContent; t[o] = a; } } })), t; }(r)); Object.keys(t).forEach(((n) => { let r; n === 'style' ? t.style.split(',').filter(((e) => e)).map(((e) => i(e.trim()))).forEach(((t) => e.classList.add(t))) : n === 'background-image' ? e.style.backgroundImage = `url(${t[n]})` : e.dataset[(r = n, i(r).replace(/-([a-z])/g, ((e) => e[1].toUpperCase())))] = t[n]; })), r.parentNode.remove(); } })); } function p(e) { const t = [...e.querySelectorAll(':scope > div.section')]; for (let e = 0; e < t.length; e += 1) { const n = t[e]; if (n.dataset.sectionStatus !== 'loaded') { if (n.querySelector('.block[data-block-status="initialized"], .block[data-block-status="loading"]')) { n.dataset.sectionStatus = 'loading'; break; }n.dataset.sectionStatus = 'loaded', n.style.display = null; } } } function f(e, t) { const n = Array.isArray(t) ? t : [[t]]; const r = document.createElement('div'); return r.classList.add(e), n.forEach(((e) => { const t = document.createElement('div'); e.forEach(((e) => { const n = document.createElement('div'); (e.elems ? e.elems : [e]).forEach(((e) => { e && (typeof e === 'string' ? n.innerHTML += e : n.appendChild(e)); })), t.appendChild(n); })), r.appendChild(t); })), r; } async function h(e) { const t = e.dataset.blockStatus; if (t !== 'loading' && t !== 'loaded') { e.dataset.blockStatus = 'loading'; const { blockName: t } = e.dataset; try { const r = o(`${window.hlx.codeBasePath}/blocks/${t}/${t}.css`); const i = new Promise(((r) => { (async () => { try { const r = await n(320)(`./${t}/${t}.js`); r.default && await r.default(e); } catch (e) { console.log(`failed to load module for ${t}`, e); }r(); })(); })); await Promise.all([r, i]); } catch (e) { console.log(`failed to load block ${t}`, e); }e.dataset.blockStatus = 'loaded'; } return e; } async function m(e) { p(e); const t = [...e.querySelectorAll('div.block')]; for (let n = 0; n < t.length; n += 1) await h(t[n]), p(e); } function v(e) { const t = e.classList[0]; if (t && !e.dataset.blockStatus) { e.classList.add('block'), e.dataset.blockName = t, e.dataset.blockStatus = 'initialized', (function (e) { const t = ['P', 'PRE', 'UL', 'OL', 'PICTURE', 'TABLE', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6']; const n = (e) => { const t = document.createElement('p'); t.append(...e.childNodes), [...e.attributes].filter((({ nodeName: e }) => e === 'class' || e.startsWith('data-aue') || e.startsWith('data-richtext'))).forEach((({ nodeName: n, nodeValue: r }) => { t.setAttribute(n, r), e.removeAttribute(n); })), e.append(t); }; e.querySelectorAll(':scope > div > div').forEach(((e) => { e.hasChildNodes() && (e.firstElementChild && t.some(((t) => e.firstElementChild.tagName === t)) ? e.firstElementChild.tagName === 'PICTURE' && (e.children.length > 1 || e.textContent.trim()) && n(e) : n(e)); })); }(e)), e.parentElement.classList.add(`${t}-wrapper`); const n = e.closest('.section'); n && n.classList.add(`${t}-container`), c(e); } } function g(e) { e.querySelectorAll('div.section > div > div').forEach(v); } async function y(e) { const t = f('header', ''); return e.append(t), v(t), h(t); } async function b(e) { const t = f('footer', ''); return e.append(t), v(t), h(t); } async function w(e) { const t = document.querySelector('.block'); t && e.includes(t.dataset.blockName) && await h(t), document.body.style.display = null; const n = document.querySelector('main img'); await new Promise(((e) => { n && !n.complete ? (n.setAttribute('loading', 'eager'), n.addEventListener('load', e), n.addEventListener('error', e)) : e(); })); }n.d(t, {
        HI: () => c, KG: () => f, L4: () => i, O3: () => l, W1: () => w, Y7: () => y, dC: () => r, ez: () => h, fg: () => v, gD: () => s, iB: () => b, iK: () => g, sT: () => u, tB: () => m, y6: () => o, yb: () => a, yd: () => d,
      }), (function () { window.hlx = window.hlx || {}, window.hlx.RUM_MASK_URL = 'full', window.hlx.codeBasePath = '', window.hlx.lighthouse = new URLSearchParams(window.location.search).get('lighthouse') === 'on'; const e = document.querySelector('script[src$="/scripts/scripts.js"]'); if (e) try { const t = new URL(e.src, window.location); t.host === window.location.host ? [window.hlx.codeBasePath] = t.pathname.split('/scripts/scripts.js') : [window.hlx.codeBasePath] = t.href.split('/scripts/scripts.js'); } catch (e) { console.log(e); } }()), r('top'), window.addEventListener('load', (() => r('load'))), ['error', 'unhandledrejection'].forEach(((e) => {
        window.addEventListener(e, (({ reason: e, error: t }) => {
          const n = { source: 'undefined error' }; try {
            n.target = (e || t).toString(), n.source = (e || t).stack.split('\n').filter(((e) => e.match(/https?:\/\//))).shift().replace(/at ([^ ]+) \((.+)\)/, '$1@$2')
              .trim();
          } catch (e) {}r('error', n);
        }));
      }));
    },
    215: (e, t, n) => {
      n.r(t), (0, n(927).dC)('cwv'), (function () { const e = document.createElement('script'); e.append('\n(function (w, d, s, l, i) {\n    w[l] = w[l] || [];\n    w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });\n    var f = d.getElementsByTagName(s)[0],\n        j = d.createElement(s),\n        dl = l != "dataLayer" ? "&l=" + l : "";\n    j.async = true;\n    j.src = "https://www.googletagmanager.com/gtm.js?id=" + i + dl;\n    f.parentNode.insertBefore(j, f);\n})(window, document, "script", "dataLayer", "GTM-597MK8TP");\n    '), document.head.append(e); }());
    },
    658: (e, t, n) => {
      n.d(t, { LL: () => c, U2: () => o, n: () => s }); const r = n(927); n(425); const i = []; function o(e, t) { !(function (e, t, n) { n || (n = [...e.attributes].map((({ nodeName: e }) => e))), n.forEach(((n) => { const r = e.getAttribute(n); r && (t.setAttribute(n, r), e.removeAttribute(n)); })); }(e, t, [...e.attributes].map((({ nodeName: e }) => e)).filter(((e) => e.startsWith('data-aue-') || e.startsWith('data-richtext-'))))); } async function a() { await (0, r.y6)(`${window.hlx.codeBasePath}/styles/fonts.css`); try { window.location.hostname.includes('localhost') || sessionStorage.setItem('fonts-loaded', 'true'); } catch (e) {} } function s(e, t = {}) { const { classes: n = [], props: r = {} } = t; const i = document.createElement(e); const o = typeof n === 'string'; if (n || o && n !== '' || !o && n.length > 0) { const e = o ? [n] : n; i.classList.add(...e); } return o || n.length !== 0 || i.removeAttribute('class'), r && Object.keys(r).forEach(((e) => { if (e === 'allowfullscreen' || e === 'autoplay' || e === 'muted' || e === 'controls')r[e] && i.setAttribute(e, ''); else { const t = r[e]; i.setAttribute(e, t); } })), i; } function l(e) { (0, r.HI)(e), (0, r.sT)(e), (0, r.yd)(e), (0, r.iK)(e); } async function c(e) { if (e && e.startsWith('/')) { e = e.replace(/(\.plain)?\.html/, ''); const t = await fetch(`${e}.plain.html`); if (t.ok) { const n = document.createElement('main'); n.innerHTML = await t.text(); const i = (t, r) => { n.querySelectorAll(`${t}[${r}^="./media_"]`).forEach(((t) => { t[r] = new URL(t.getAttribute(r), new URL(e, window.location)).href; })); }; return i('img', 'src'), i('source', 'srcset'), l(n), await (0, r.tB)(n), n; } } return null; }!(async function () { (0, r.Y7)(document.querySelector('header')), await (async function (e) { document.documentElement.lang = 'en', (0, r.O3)(); const t = e.querySelector('main'); t && (l(t), document.body.classList.add('appear'), await (0, r.W1)(i)); try { (window.innerWidth >= 900 || sessionStorage.getItem('fonts-loaded')) && a(); } catch (e) {} }(document)), await (async function (e) { !(function (e) { e.addEventListener('click', (async (e) => { const t = e.target.closest('a'); if (t && t.href && t.href.includes('/modals/')) { e.preventDefault(); const { openModal: r } = await n(776)(`${window.hlx.codeBasePath}/blocks/modal/modal.js`); r(t.href); } })); }(e)), (function (e) { e.querySelectorAll('a').forEach((async (e) => { if (e.href.includes('fragements')) { const t = e ? e.getAttribute('href') : e.textContent.trim(); const n = await c(t); if (n) { const t = n.querySelector(':scope .section'); t && (e.classList.add(...t.classList), e.replaceWith(...n.childNodes)); } } })); }(e)); const t = e.querySelector('main'); await (0, r.tB)(t); const { hash: i } = window.location; const o = !!i && e.getElementById(i.substring(1)); i && o && o.scrollIntoView(), (0, r.iB)(e.querySelector('footer')), (0, r.y6)(`${window.hlx.codeBasePath}/styles/lazy-styles.css`), a(), (0, r.dC)('lazy'), r.dC.observe(t.querySelectorAll('div[data-block-name]')), r.dC.observe(t.querySelectorAll('picture > img')); }(document)), window.setTimeout((() => Promise.resolve().then(n.bind(n, 215))), 3e3), n.e(773).then(n.bind(n, 773)).then((({ initSidekick: e }) => e())); }());
    },
    776: (e) => { function t(e) { return Promise.resolve().then((() => { const t = new Error(`Cannot find module '${e}'`); throw t.code = 'MODULE_NOT_FOUND', t; })); }t.keys = () => [], t.resolve = t, t.id = 776, e.exports = t; },
  }; const o = {}; function a(e) { const t = o[e]; if (void 0 !== t) return t.exports; const n = o[e] = { exports: {} }; return i[e](n, n.exports, a), n.exports; }a.m = i, t = Object.getPrototypeOf ? (e) => Object.getPrototypeOf(e) : (e) => e.__proto__, a.t = function (n, r) { if (1 & r && (n = this(n)), 8 & r) return n; if (typeof n === 'object' && n) { if (4 & r && n.__esModule) return n; if (16 & r && typeof n.then === 'function') return n; } const i = Object.create(null); a.r(i); const o = {}; e = e || [null, t({}), t([]), t(t)]; for (let s = 2 & r && n; typeof s === 'object' && !~e.indexOf(s); s = t(s))Object.getOwnPropertyNames(s).forEach(((e) => o[e] = () => n[e])); return o.default = () => n, a.d(i, o), i; }, a.d = (e, t) => { for (const n in t)a.o(t, n) && !a.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }); }, a.f = {}, a.e = (e) => Promise.all(Object.keys(a.f).reduce(((t, n) => (a.f[n](e, t), t)), [])), a.u = (e) => `${e}.bundle.js`, a.g = (function () { if (typeof globalThis === 'object') return globalThis; try { return this || new Function('return this')(); } catch (e) { if (typeof window === 'object') return window; } }()), a.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n = {}, r = '@adobe/aem-boilerplate:', a.l = (e, t, i, o) => { if (n[e])n[e].push(t); else { let s; let l; if (void 0 !== i) for (let c = document.getElementsByTagName('script'), u = 0; u < c.length; u++) { const d = c[u]; if (d.getAttribute('src') == e || d.getAttribute('data-webpack') == r + i) { s = d; break; } }s || (l = !0, (s = document.createElement('script')).charset = 'utf-8', s.timeout = 120, a.nc && s.setAttribute('nonce', a.nc), s.setAttribute('data-webpack', r + i), s.src = e), n[e] = [t]; const p = (t, r) => { s.onerror = s.onload = null, clearTimeout(f); const i = n[e]; if (delete n[e], s.parentNode && s.parentNode.removeChild(s), i && i.forEach(((e) => e(r))), t) return t(r); }; var f = setTimeout(p.bind(null, void 0, { type: 'timeout', target: s }), 12e4); s.onerror = p.bind(null, s.onerror), s.onload = p.bind(null, s.onload), l && document.head.appendChild(s); } }, a.r = (e) => { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }); }, a.p = '/build/', (() => { const e = { 792: 0 }; a.f.j = (t, n) => { let r = a.o(e, t) ? e[t] : void 0; if (r !== 0) if (r)n.push(r[2]); else { const i = new Promise(((n, i) => r = e[t] = [n, i])); n.push(r[2] = i); const o = a.p + a.u(t); const s = new Error(); a.l(o, ((n) => { if (a.o(e, t) && ((r = e[t]) !== 0 && (e[t] = void 0), r)) { const i = n && (n.type === 'load' ? 'missing' : n.type); const o = n && n.target && n.target.src; s.message = `Loading chunk ${t} failed.\n(${i}: ${o})`, s.name = 'ChunkLoadError', s.type = i, s.request = o, r[1](s); } }), `chunk-${t}`, t); } }; const t = (t, n) => { let r; let i; const [o, s, l] = n; let c = 0; if (o.some(((t) => e[t] !== 0))) { for (r in s)a.o(s, r) && (a.m[r] = s[r]); l && l(a); } for (t && t(n); c < o.length; c++)i = o[c], a.o(e, i) && e[i] && e[i][0](), e[i] = 0; }; const n = self.webpackChunk_adobe_aem_boilerplate = self.webpackChunk_adobe_aem_boilerplate || []; n.forEach(t.bind(null, 0)), n.push = t.bind(null, n.push.bind(n)); })(), a(927), a(215), a(658);
})();
