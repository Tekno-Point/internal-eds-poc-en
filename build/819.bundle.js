(self.webpackChunk_adobe_aem_boilerplate = self.webpackChunk_adobe_aem_boilerplate || []).push([[819], {
  819: (e, t, a) => {
    function r(e, t) { for (let a = 0; a < t.length; a++) { const r = t[a]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(e, u(r.key), r); } } function i(e, t) { const a = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(((t) => Object.getOwnPropertyDescriptor(e, t).enumerable))), a.push.apply(a, r); } return a; } function s(e) { for (let t = 1; t < arguments.length; t++) { var a = arguments[t] != null ? arguments[t] : {}; t % 2 ? i(Object(a), !0).forEach(((t) => { c(e, t, a[t]); })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(a)) : i(Object(a)).forEach(((t) => { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(a, t)); })); } return e; } function n(e, t) { return (function (e) { if (Array.isArray(e)) return e; }(e)) || (function (e, t) { let a = e == null ? null : typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']; if (a != null) { let r; let i; let s; let n; const o = []; let l = !0; let d = !1; try { if (s = (a = a.call(e)).next, t === 0) { if (Object(a) !== a) return; l = !1; } else for (;!(l = (r = s.call(a)).done) && (o.push(r.value), o.length !== t); l = !0); } catch (e) { d = !0, i = e; } finally { try { if (!l && a.return != null && (n = a.return(), Object(n) !== n)) return; } finally { if (d) throw i; } } return o; } }(e, t)) || l(e, t) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function o(e) { return (function (e) { if (Array.isArray(e)) return d(e); }(e)) || (function (e) { if (typeof Symbol !== 'undefined' && e[Symbol.iterator] != null || e['@@iterator'] != null) return Array.from(e); }(e)) || l(e) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function l(e, t) { if (e) { if (typeof e === 'string') return d(e, t); let a = {}.toString.call(e).slice(8, -1); return a === 'Object' && e.constructor && (a = e.constructor.name), a === 'Map' || a === 'Set' ? Array.from(e) : a === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a) ? d(e, t) : void 0; } } function d(e, t) { (t == null || t > e.length) && (t = e.length); for (var a = 0, r = Array(t); a < t; a++)r[a] = e[a]; return r; } function c(e, t, a) {
      return (t = u(t)) in e ? Object.defineProperty(e, t, {
        value: a, enumerable: !0, configurable: !0, writable: !0,
      }) : e[t] = a, e;
    } function u(e) { const t = (function (e) { if (p(e) != 'object' || !e) return e; const t = e[Symbol.toPrimitive]; if (void 0 !== t) { const a = t.call(e, 'string'); if (p(a) != 'object') return a; throw new TypeError('@@toPrimitive must return a primitive value.'); } return String(e); }(e)); return p(t) == 'symbol' ? t : `${t}`; } function p(e) { return p = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }, p(e); }a.r(t), a.d(t, { default: () => m }); const f = (function () {
      function e(e) { return e !== null && p(e) == 'object' && 'constructor' in e && e.constructor === Object; } function t(a, r) { void 0 === a && (a = {}), void 0 === r && (r = {}), Object.keys(r).forEach(((i) => { void 0 === a[i] ? a[i] = r[i] : e(r[i]) && e(a[i]) && Object.keys(r[i]).length > 0 && t(a[i], r[i]); })); } const a = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: { blur() {}, nodeName: '' },
        querySelector() { return null; },
        querySelectorAll() { return []; },
        getElementById() { return null; },
        createEvent() { return { initEvent() {} }; },
        createElement() {
          return {
            children: [], childNodes: [], style: {}, setAttribute() {}, getElementsByTagName() { return []; },
          };
        },
        createElementNS() { return {}; },
        importNode() { return null; },
        location: {
          hash: '', host: '', hostname: '', href: '', origin: '', pathname: '', protocol: '', search: '',
        },
      }; function i() { const e = typeof document !== 'undefined' ? document : {}; return t(e, a), e; } let l; let d; let u; const f = {
        document: a,
        navigator: { userAgent: '' },
        location: {
          hash: '', host: '', hostname: '', href: '', origin: '', pathname: '', protocol: '', search: '',
        },
        history: {
          replaceState() {}, pushState() {}, go() {}, back() {},
        },
        CustomEvent() { return this; },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle() { return { getPropertyValue() { return ''; } }; },
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia() { return {}; },
        requestAnimationFrame(e) { return typeof setTimeout === 'undefined' ? (e(), null) : setTimeout(e, 0); },
        cancelAnimationFrame(e) { typeof setTimeout !== 'undefined' && clearTimeout(e); },
      }; function m() { const e = typeof window !== 'undefined' ? window : {}; return t(e, f), e; } function v(e) { return void 0 === e && (e = ''), e.trim().split(' ').filter(((e) => !!e.trim())); } function h(e, t) { return void 0 === t && (t = 0), setTimeout(e, t); } function g() { return Date.now(); } function w(e, t) { void 0 === t && (t = 'x'); let a; let r; let i; const s = m(); const n = (function (e) { let t; const a = m(); return a.getComputedStyle && (t = a.getComputedStyle(e, null)), !t && e.currentStyle && (t = e.currentStyle), t || (t = e.style), t; }(e)); return s.WebKitCSSMatrix ? ((r = n.transform || n.webkitTransform).split(',').length > 6 && (r = r.split(', ').map(((e) => e.replace(',', '.'))).join(', ')), i = new s.WebKitCSSMatrix(r === 'none' ? '' : r)) : a = (i = n.MozTransform || n.OTransform || n.MsTransform || n.msTransform || n.transform || n.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,')).toString().split(','), t === 'x' && (r = s.WebKitCSSMatrix ? i.m41 : a.length === 16 ? parseFloat(a[12]) : parseFloat(a[4])), t === 'y' && (r = s.WebKitCSSMatrix ? i.m42 : a.length === 16 ? parseFloat(a[13]) : parseFloat(a[5])), r || 0; } function b(e) { return p(e) == 'object' && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === 'Object'; } function y() { for (var e, t = Object(arguments.length <= 0 ? void 0 : arguments[0]), a = ['__proto__', 'constructor', 'prototype'], r = 1; r < arguments.length; r += 1) { const i = r < 0 || arguments.length <= r ? void 0 : arguments[r]; if (i != null && (e = i, !(typeof window !== 'undefined' && void 0 !== window.HTMLElement ? e instanceof HTMLElement : e && (e.nodeType === 1 || e.nodeType === 11)))) for (let s = Object.keys(Object(i)).filter(((e) => a.indexOf(e) < 0)), n = 0, o = s.length; n < o; n += 1) { const l = s[n]; const d = Object.getOwnPropertyDescriptor(i, l); void 0 !== d && d.enumerable && (b(t[l]) && b(i[l]) ? i[l].__swiper__ ? t[l] = i[l] : y(t[l], i[l]) : !b(t[l]) && b(i[l]) ? (t[l] = {}, i[l].__swiper__ ? t[l] = i[l] : y(t[l], i[l])) : t[l] = i[l]); } } return t; } function E(e, t, a) { e.style.setProperty(t, a); } function x(e) { let t; const a = e.swiper; const r = e.targetPosition; const i = e.side; const s = m(); const n = -a.translate; let o = null; const l = a.params.speed; a.wrapperEl.style.scrollSnapType = 'none', s.cancelAnimationFrame(a.cssModeFrameID); const d = r > n ? 'next' : 'prev'; const u = function (e, t) { return d === 'next' && e >= t || d === 'prev' && e <= t; }; const p = function () { t = (new Date()).getTime(), o === null && (o = t); const e = Math.max(Math.min((t - o) / l, 1), 0); const d = 0.5 - Math.cos(e * Math.PI) / 2; let f = n + d * (r - n); if (u(f, r) && (f = r), a.wrapperEl.scrollTo(c({}, i, f)), u(f, r)) return a.wrapperEl.style.overflow = 'hidden', a.wrapperEl.style.scrollSnapType = '', setTimeout((() => { a.wrapperEl.style.overflow = '', a.wrapperEl.scrollTo(c({}, i, f)); })), void s.cancelAnimationFrame(a.cssModeFrameID); a.cssModeFrameID = s.requestAnimationFrame(p); }; p(); } function S(e) { return e.querySelector('.swiper-slide-transform') || e.shadowRoot && e.shadowRoot.querySelector('.swiper-slide-transform') || e; } function T(e, t) { void 0 === t && (t = ''); const a = o(e.children); return e instanceof HTMLSlotElement && a.push.apply(a, o(e.assignedElements())), t ? a.filter(((e) => e.matches(t))) : a; } function M(e) { try { return void console.warn(e); } catch (e) {} } function C(e, t) { let a; void 0 === t && (t = []); const r = document.createElement(e); return (a = r.classList).add.apply(a, o(Array.isArray(t) ? t : v(t))), r; } function P(e) { const t = m(); const a = i(); const r = e.getBoundingClientRect(); const s = a.body; const n = e.clientTop || s.clientTop || 0; const o = e.clientLeft || s.clientLeft || 0; const l = e === t ? t.scrollY : e.scrollTop; const d = e === t ? t.scrollX : e.scrollLeft; return { top: r.top + l - n, left: r.left + d - o }; } function L(e, t) { return m().getComputedStyle(e, null).getPropertyValue(t); } function k(e) { let t; let a = e; if (a) { for (t = 0; (a = a.previousSibling) !== null;)a.nodeType === 1 && (t += 1); return t; } } function I(e, t) { for (var a = [], r = e.parentElement; r;)t ? r.matches(t) && a.push(r) : a.push(r), r = r.parentElement; return a; } function A(e, t) { t && e.addEventListener('transitionend', (function a(r) { r.target === e && (t.call(e, r), e.removeEventListener('transitionend', a)); })); } function z(e, t, a) { const r = m(); return a ? e[t === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(r.getComputedStyle(e, null).getPropertyValue(t === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(r.getComputedStyle(e, null).getPropertyValue(t === 'width' ? 'margin-left' : 'margin-bottom')) : e.offsetWidth; } function O(e) { return (Array.isArray(e) ? e : [e]).filter(((e) => !!e)); } function D(e) { return function (t) { return Math.abs(t) > 0 && e.browser && e.browser.need3dFix && Math.abs(t) % 90 == 0 ? t + 0.001 : t; }; } function G() { return l || (l = (function () { const e = m(); const t = i(); return { smoothScroll: t.documentElement && t.documentElement.style && 'scrollBehavior' in t.documentElement.style, touch: !!('ontouchstart' in e || e.DocumentTouch && t instanceof e.DocumentTouch) }; }())), l; } function H(e) { return void 0 === e && (e = {}), d || (d = (function (e) { const t = (void 0 === e ? {} : e).userAgent; const a = G(); const r = m(); const i = r.navigator.platform; const s = t || r.navigator.userAgent; const n = { ios: !1, android: !1 }; const o = r.screen.width; const l = r.screen.height; const d = s.match(/(Android);?[\s\/]+([\d.]+)?/); let c = s.match(/(iPad).*OS\s([\d_]+)/); const u = s.match(/(iPod)(.*OS\s([\d_]+))?/); const p = !c && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/); const f = i === 'Win32'; let v = i === 'MacIntel'; return !c && v && a.touch && ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'].indexOf(''.concat(o, 'x').concat(l)) >= 0 && ((c = s.match(/(Version)\/([\d.]+)/)) || (c = [0, 1, '13_0_0']), v = !1), d && !f && (n.os = 'android', n.android = !0), (c || p || u) && (n.os = 'ios', n.ios = !0), n; }(e))), d; } function B() {
        return u || (u = (function () {
          const e = m(); const t = H(); let a = !1; function r() { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf('safari') >= 0 && t.indexOf('chrome') < 0 && t.indexOf('android') < 0; } if (r()) { const i = String(e.navigator.userAgent); if (i.includes('Version/')) { const s = i.split('Version/')[1].split(' ')[0].split('.').map(((e) => Number(e))); const o = n(s, 2); const l = o[0]; const d = o[1]; a = l < 16 || l === 16 && d < 2; } } const c = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent); const u = r(); return {
            isSafari: a || u, needPerspectiveFix: a, need3dFix: u || c && t.ios, isWebView: c,
          };
        }())), u;
      } const N = {
        on(e, t, a) { const r = this; if (!r.eventsListeners || r.destroyed) return r; if (typeof t !== 'function') return r; const i = a ? 'unshift' : 'push'; return e.split(' ').forEach(((e) => { r.eventsListeners[e] || (r.eventsListeners[e] = []), r.eventsListeners[e][i](t); })), r; }, once(e, t, a) { const r = this; if (!r.eventsListeners || r.destroyed) return r; if (typeof t !== 'function') return r; function i() { r.off(e, i), i.__emitterProxy && delete i.__emitterProxy; for (var a = arguments.length, s = new Array(a), n = 0; n < a; n++)s[n] = arguments[n]; t.apply(r, s); } return i.__emitterProxy = t, r.on(e, i, a); }, onAny(e, t) { const a = this; if (!a.eventsListeners || a.destroyed) return a; if (typeof e !== 'function') return a; const r = t ? 'unshift' : 'push'; return a.eventsAnyListeners.indexOf(e) < 0 && a.eventsAnyListeners[r](e), a; }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const a = t.eventsAnyListeners.indexOf(e); return a >= 0 && t.eventsAnyListeners.splice(a, 1), t; }, off(e, t) { const a = this; return !a.eventsListeners || a.destroyed ? a : a.eventsListeners ? (e.split(' ').forEach(((e) => { void 0 === t ? a.eventsListeners[e] = [] : a.eventsListeners[e] && a.eventsListeners[e].forEach(((r, i) => { (r === t || r.__emitterProxy && r.__emitterProxy === t) && a.eventsListeners[e].splice(i, 1); })); })), a) : a; }, emit() { let e; let t; let a; const r = this; if (!r.eventsListeners || r.destroyed) return r; if (!r.eventsListeners) return r; for (var i = arguments.length, s = new Array(i), n = 0; n < i; n++)s[n] = arguments[n]; return typeof s[0] === 'string' || Array.isArray(s[0]) ? (e = s[0], t = s.slice(1, s.length), a = r) : (e = s[0].events, t = s[0].data, a = s[0].context || r), t.unshift(a), (Array.isArray(e) ? e : e.split(' ')).forEach(((e) => { r.eventsAnyListeners && r.eventsAnyListeners.length && r.eventsAnyListeners.forEach(((r) => { r.apply(a, [e].concat(o(t))); })), r.eventsListeners && r.eventsListeners[e] && r.eventsListeners[e].forEach(((e) => { e.apply(a, t); })); })), r; },
      }; const X = function (e, t, a) { t && !e.classList.contains(a) ? e.classList.add(a) : !t && e.classList.contains(a) && e.classList.remove(a); }; const Y = function (e, t, a) { t && !e.classList.contains(a) ? e.classList.add(a) : !t && e.classList.contains(a) && e.classList.remove(a); }; const R = function (e, t) { if (e && !e.destroyed && e.params) { const a = t.closest(e.isElement ? 'swiper-slide' : '.'.concat(e.params.slideClass)); if (a) { let r = a.querySelector('.'.concat(e.params.lazyPreloaderClass)); !r && e.isElement && (a.shadowRoot ? r = a.shadowRoot.querySelector('.'.concat(e.params.lazyPreloaderClass)) : requestAnimationFrame((() => { a.shadowRoot && (r = a.shadowRoot.querySelector('.'.concat(e.params.lazyPreloaderClass))) && r.remove(); }))), r && r.remove(); } } }; const _ = function (e, t) { if (e.slides[t]) { const a = e.slides[t].querySelector('[loading="lazy"]'); a && a.removeAttribute('loading'); } }; const F = function (e) { if (e && !e.destroyed && e.params) { let t = e.params.lazyPreloadPrevNext; const a = e.slides.length; if (a && t && !(t < 0)) { t = Math.min(t, a); const r = e.params.slidesPerView === 'auto' ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView); const i = e.activeIndex; if (e.params.grid && e.params.grid.rows > 1) { const s = i; const n = [s - t]; return n.push.apply(n, o(Array.from({ length: t }).map(((e, t) => s + r + t)))), void e.slides.forEach(((t, a) => { n.includes(t.column) && _(e, a); })); } const l = i + r - 1; if (e.params.rewind || e.params.loop) for (let d = i - t; d <= l + t; d += 1) { const c = (d % a + a) % a; (c < i || c > l) && _(e, c); } else for (let u = Math.max(i - t, 0); u <= Math.min(l + t, a - 1); u += 1)u !== i && (u > l || u < i) && _(e, u); } } }; const V = {
        updateSize() { let e; let t; const a = this; const r = a.el; e = void 0 !== a.params.width && a.params.width !== null ? a.params.width : r.clientWidth, t = void 0 !== a.params.height && a.params.height !== null ? a.params.height : r.clientHeight, e === 0 && a.isHorizontal() || t === 0 && a.isVertical() || (e = e - parseInt(L(r, 'padding-left') || 0, 10) - parseInt(L(r, 'padding-right') || 0, 10), t = t - parseInt(L(r, 'padding-top') || 0, 10) - parseInt(L(r, 'padding-bottom') || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(a, { width: e, height: t, size: a.isHorizontal() ? e : t })); },
        updateSlides() {
          const e = this; function t(t, a) { return parseFloat(t.getPropertyValue(e.getDirectionLabel(a)) || 0); } const a = e.params; const r = e.wrapperEl; const i = e.slidesEl; const s = e.size; const n = e.rtlTranslate; const o = e.wrongRTL; const l = e.virtual && a.virtual.enabled; const d = l ? e.virtual.slides.length : e.slides.length; const c = T(i, '.'.concat(e.params.slideClass, ', swiper-slide')); const u = l ? e.virtual.slides.length : c.length; let p = []; const f = []; const m = []; let v = a.slidesOffsetBefore; typeof v === 'function' && (v = a.slidesOffsetBefore.call(e)); let h = a.slidesOffsetAfter; typeof h === 'function' && (h = a.slidesOffsetAfter.call(e)); const g = e.snapGrid.length; const w = e.slidesGrid.length; let b = a.spaceBetween; let y = -v; let x = 0; let S = 0; if (void 0 !== s) {
            typeof b === 'string' && b.indexOf('%') >= 0 ? b = parseFloat(b.replace('%', '')) / 100 * s : typeof b === 'string' && (b = parseFloat(b)), e.virtualSize = -b, c.forEach(((e) => { n ? e.style.marginLeft = '' : e.style.marginRight = '', e.style.marginBottom = '', e.style.marginTop = ''; })), a.centeredSlides && a.cssMode && (E(r, '--swiper-centered-offset-before', ''), E(r, '--swiper-centered-offset-after', '')); let M; const C = a.grid && a.grid.rows > 1 && e.grid; C ? e.grid.initSlides(c) : e.grid && e.grid.unsetSlides(); for (let P = a.slidesPerView === 'auto' && a.breakpoints && Object.keys(a.breakpoints).filter(((e) => void 0 !== a.breakpoints[e].slidesPerView)).length > 0, k = 0; k < u; k += 1) { let I = void 0; if (M = 0, c[k] && (I = c[k]), C && e.grid.updateSlide(k, I, c), !c[k] || L(I, 'display') !== 'none') { if (a.slidesPerView === 'auto') { P && (c[k].style[e.getDirectionLabel('width')] = ''); const A = getComputedStyle(I); const O = I.style.transform; const D = I.style.webkitTransform; if (O && (I.style.transform = 'none'), D && (I.style.webkitTransform = 'none'), a.roundLengths)M = e.isHorizontal() ? z(I, 'width', !0) : z(I, 'height', !0); else { const G = t(A, 'width'); const H = t(A, 'padding-left'); const B = t(A, 'padding-right'); const N = t(A, 'margin-left'); const X = t(A, 'margin-right'); const Y = A.getPropertyValue('box-sizing'); if (Y && Y === 'border-box')M = G + N + X; else { const R = I; const _ = R.clientWidth; M = G + H + B + N + X + (R.offsetWidth - _); } }O && (I.style.transform = O), D && (I.style.webkitTransform = D), a.roundLengths && (M = Math.floor(M)); } else M = (s - (a.slidesPerView - 1) * b) / a.slidesPerView, a.roundLengths && (M = Math.floor(M)), c[k] && (c[k].style[e.getDirectionLabel('width')] = ''.concat(M, 'px')); c[k] && (c[k].swiperSlideSize = M), m.push(M), a.centeredSlides ? (y = y + M / 2 + x / 2 + b, x === 0 && k !== 0 && (y = y - s / 2 - b), k === 0 && (y = y - s / 2 - b), Math.abs(y) < 0.001 && (y = 0), a.roundLengths && (y = Math.floor(y)), S % a.slidesPerGroup == 0 && p.push(y), f.push(y)) : (a.roundLengths && (y = Math.floor(y)), (S - Math.min(e.params.slidesPerGroupSkip, S)) % e.params.slidesPerGroup == 0 && p.push(y), f.push(y), y = y + M + b), e.virtualSize += M + b, x = M, S += 1; } } if (e.virtualSize = Math.max(e.virtualSize, s) + h, n && o && (a.effect === 'slide' || a.effect === 'coverflow') && (r.style.width = ''.concat(e.virtualSize + b, 'px')), a.setWrapperSize && (r.style[e.getDirectionLabel('width')] = ''.concat(e.virtualSize + b, 'px')), C && e.grid.updateWrapperSize(M, p), !a.centeredSlides) { for (var F = [], V = 0; V < p.length; V += 1) { let j = p[V]; a.roundLengths && (j = Math.floor(j)), p[V] <= e.virtualSize - s && F.push(j); }p = F, Math.floor(e.virtualSize - s) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - s); } if (l && a.loop) { const q = m[0] + b; if (a.slidesPerGroup > 1) for (let W = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / a.slidesPerGroup), U = q * a.slidesPerGroup, K = 0; K < W; K += 1)p.push(p[p.length - 1] + U); for (let Z = 0; Z < e.virtual.slidesBefore + e.virtual.slidesAfter; Z += 1)a.slidesPerGroup === 1 && p.push(p[p.length - 1] + q), f.push(f[f.length - 1] + q), e.virtualSize += q; } if (p.length === 0 && (p = [0]), b !== 0) { const $ = e.isHorizontal() && n ? 'marginLeft' : e.getDirectionLabel('marginRight'); c.filter(((e, t) => !(a.cssMode && !a.loop) || t !== c.length - 1)).forEach(((e) => { e.style[$] = ''.concat(b, 'px'); })); } if (a.centeredSlides && a.centeredSlidesBounds) { let Q = 0; m.forEach(((e) => { Q += e + (b || 0); })); const J = (Q -= b) > s ? Q - s : 0; p = p.map(((e) => (e <= 0 ? -v : e > J ? J + h : e))); } if (a.centerInsufficientSlides) { let ee = 0; m.forEach(((e) => { ee += e + (b || 0); })), ee -= b; const te = (a.slidesOffsetBefore || 0) + (a.slidesOffsetAfter || 0); if (ee + te < s) { const ae = (s - ee - te) / 2; p.forEach(((e, t) => { p[t] = e - ae; })), f.forEach(((e, t) => { f[t] = e + ae; })); } } if (Object.assign(e, {
              slides: c, snapGrid: p, slidesGrid: f, slidesSizesGrid: m,
            }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) { E(r, '--swiper-centered-offset-before', `${-p[0]}px`), E(r, '--swiper-centered-offset-after', `${e.size / 2 - m[m.length - 1] / 2}px`); const re = -e.snapGrid[0]; const ie = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map(((e) => e + re)), e.slidesGrid = e.slidesGrid.map(((e) => e + ie)); } if (u !== d && e.emit('slidesLengthChange'), p.length !== g && (e.params.watchOverflow && e.checkOverflow(), e.emit('snapGridLengthChange')), f.length !== w && e.emit('slidesGridLengthChange'), a.watchSlidesProgress && e.updateSlidesOffset(), e.emit('slidesUpdated'), !(l || a.cssMode || a.effect !== 'slide' && a.effect !== 'fade')) { const se = ''.concat(a.containerModifierClass, 'backface-hidden'); const ne = e.el.classList.contains(se); u <= a.maxBackfaceHiddenSlides ? ne || e.el.classList.add(se) : ne && e.el.classList.remove(se); }
          }
        },
        updateAutoHeight(e) { let t; const a = this; const r = []; const i = a.virtual && a.params.virtual.enabled; let s = 0; typeof e === 'number' ? a.setTransition(e) : !0 === e && a.setTransition(a.params.speed); const n = function (e) { return i ? a.slides[a.getSlideIndexByData(e)] : a.slides[e]; }; if (a.params.slidesPerView !== 'auto' && a.params.slidesPerView > 1) if (a.params.centeredSlides)(a.visibleSlides || []).forEach(((e) => { r.push(e); })); else for (t = 0; t < Math.ceil(a.params.slidesPerView); t += 1) { const o = a.activeIndex + t; if (o > a.slides.length && !i) break; r.push(n(o)); } else r.push(n(a.activeIndex)); for (t = 0; t < r.length; t += 1) if (void 0 !== r[t]) { const l = r[t].offsetHeight; s = l > s ? l : s; }(s || s === 0) && (a.wrapperEl.style.height = ''.concat(s, 'px')); },
        updateSlidesOffset() { for (let e = this, t = e.slides, a = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0, r = 0; r < t.length; r += 1)t[r].swiperSlideOffset = (e.isHorizontal() ? t[r].offsetLeft : t[r].offsetTop) - a - e.cssOverflowAdjustment(); },
        updateSlidesProgress(e) { void 0 === e && (e = this && this.translate || 0); const t = this; const a = t.params; const r = t.slides; const i = t.rtlTranslate; const s = t.snapGrid; if (r.length !== 0) { void 0 === r[0].swiperSlideOffset && t.updateSlidesOffset(); let n = -e; i && (n = e), t.visibleSlidesIndexes = [], t.visibleSlides = []; let o = a.spaceBetween; typeof o === 'string' && o.indexOf('%') >= 0 ? o = parseFloat(o.replace('%', '')) / 100 * t.size : typeof o === 'string' && (o = parseFloat(o)); for (let l = 0; l < r.length; l += 1) { const d = r[l]; let c = d.swiperSlideOffset; a.cssMode && a.centeredSlides && (c -= r[0].swiperSlideOffset); const u = (n + (a.centeredSlides ? t.minTranslate() : 0) - c) / (d.swiperSlideSize + o); const p = (n - s[0] + (a.centeredSlides ? t.minTranslate() : 0) - c) / (d.swiperSlideSize + o); const f = -(n - c); const m = f + t.slidesSizesGrid[l]; const v = f >= 0 && f <= t.size - t.slidesSizesGrid[l]; const h = f >= 0 && f < t.size - 1 || m > 1 && m <= t.size || f <= 0 && m >= t.size; h && (t.visibleSlides.push(d), t.visibleSlidesIndexes.push(l)), X(d, h, a.slideVisibleClass), X(d, v, a.slideFullyVisibleClass), d.progress = i ? -u : u, d.originalProgress = i ? -p : p; } } },
        updateProgress(e) {
          const t = this; if (void 0 === e) { const a = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * a || 0; } const r = t.params; const i = t.maxTranslate() - t.minTranslate(); let s = t.progress; let n = t.isBeginning; let o = t.isEnd; let l = t.progressLoop; const d = n; const c = o; if (i === 0)s = 0, n = !0, o = !0; else { s = (e - t.minTranslate()) / i; const u = Math.abs(e - t.minTranslate()) < 1; const p = Math.abs(e - t.maxTranslate()) < 1; n = u || s <= 0, o = p || s >= 1, u && (s = 0), p && (s = 1); } if (r.loop) { const f = t.getSlideIndexByData(0); const m = t.getSlideIndexByData(t.slides.length - 1); const v = t.slidesGrid[f]; const h = t.slidesGrid[m]; const g = t.slidesGrid[t.slidesGrid.length - 1]; const w = Math.abs(e); (l = w >= v ? (w - v) / g : (w + g - h) / g) > 1 && (l -= 1); }Object.assign(t, {
            progress: s, progressLoop: l, isBeginning: n, isEnd: o,
          }), (r.watchSlidesProgress || r.centeredSlides && r.autoHeight) && t.updateSlidesProgress(e), n && !d && t.emit('reachBeginning toEdge'), o && !c && t.emit('reachEnd toEdge'), (d && !n || c && !o) && t.emit('fromEdge'), t.emit('progress', s);
        },
        updateSlidesClasses() { let e; let t; let a; const r = this; const i = r.slides; const s = r.params; const n = r.slidesEl; const o = r.activeIndex; const l = r.virtual && s.virtual.enabled; const d = r.grid && s.grid && s.grid.rows > 1; const c = function (e) { return T(n, '.'.concat(s.slideClass).concat(e, ', swiper-slide').concat(e))[0]; }; if (l) if (s.loop) { let u = o - r.virtual.slidesBefore; u < 0 && (u = r.virtual.slides.length + u), u >= r.virtual.slides.length && (u -= r.virtual.slides.length), e = c('[data-swiper-slide-index="'.concat(u, '"]')); } else e = c('[data-swiper-slide-index="'.concat(o, '"]')); else d ? (e = i.filter(((e) => e.column === o))[0], a = i.filter(((e) => e.column === o + 1))[0], t = i.filter(((e) => e.column === o - 1))[0]) : e = i[o]; e && (d || (a = (function (e, t) { for (var a = []; e.nextElementSibling;) { const r = e.nextElementSibling; t ? r.matches(t) && a.push(r) : a.push(r), e = r; } return a; }(e, '.'.concat(s.slideClass, ', swiper-slide')))[0], s.loop && !a && (a = i[0]), t = (function (e, t) { for (var a = []; e.previousElementSibling;) { const r = e.previousElementSibling; t ? r.matches(t) && a.push(r) : a.push(r), e = r; } return a; }(e, '.'.concat(s.slideClass, ', swiper-slide')))[0], s.loop && !t === 0 && (t = i[i.length - 1]))), i.forEach(((r) => { Y(r, r === e, s.slideActiveClass), Y(r, r === a, s.slideNextClass), Y(r, r === t, s.slidePrevClass); })), r.emitSlidesClasses(); },
        updateActiveIndex(e) {
          let t; const a = this; const r = a.rtlTranslate ? a.translate : -a.translate; const i = a.snapGrid; const s = a.params; const n = a.activeIndex; const o = a.realIndex; const l = a.snapIndex; let d = e; const c = function (e) { let t = e - a.virtual.slidesBefore; return t < 0 && (t = a.virtual.slides.length + t), t >= a.virtual.slides.length && (t -= a.virtual.slides.length), t; }; if (void 0 === d && (d = (function (e) { for (var t, a = e.slidesGrid, r = e.params, i = e.rtlTranslate ? e.translate : -e.translate, s = 0; s < a.length; s += 1) void 0 !== a[s + 1] ? i >= a[s] && i < a[s + 1] - (a[s + 1] - a[s]) / 2 ? t = s : i >= a[s] && i < a[s + 1] && (t = s + 1) : i >= a[s] && (t = s); return r.normalizeSlideIndex && (t < 0 || void 0 === t) && (t = 0), t; }(a))), i.indexOf(r) >= 0)t = i.indexOf(r); else { const u = Math.min(s.slidesPerGroupSkip, d); t = u + Math.floor((d - u) / s.slidesPerGroup); } if (t >= i.length && (t = i.length - 1), d !== n || a.params.loop) {
            if (d === n && a.params.loop && a.virtual && a.params.virtual.enabled)a.realIndex = c(d); else {
              let p; const f = a.grid && s.grid && s.grid.rows > 1; if (a.virtual && s.virtual.enabled && s.loop)p = c(d); else if (f) { const m = a.slides.filter(((e) => e.column === d))[0]; let v = parseInt(m.getAttribute('data-swiper-slide-index'), 10); Number.isNaN(v) && (v = Math.max(a.slides.indexOf(m), 0)), p = Math.floor(v / s.grid.rows); } else if (a.slides[d]) { const h = a.slides[d].getAttribute('data-swiper-slide-index'); p = h ? parseInt(h, 10) : d; } else p = d; Object.assign(a, {
                previousSnapIndex: l, snapIndex: t, previousRealIndex: o, realIndex: p, previousIndex: n, activeIndex: d,
              }), a.initialized && F(a), a.emit('activeIndexChange'), a.emit('snapIndexChange'), (a.initialized || a.params.runCallbacksOnInit) && (o !== p && a.emit('realIndexChange'), a.emit('slideChange'));
            }
          } else t !== l && (a.snapIndex = t, a.emit('snapIndexChange'));
        },
        updateClickedSlide(e, t) { const a = this; const r = a.params; let i = e.closest('.'.concat(r.slideClass, ', swiper-slide')); !i && a.isElement && t && t.length > 1 && t.includes(e) && o(t.slice(t.indexOf(e) + 1, t.length)).forEach(((e) => { !i && e.matches && e.matches('.'.concat(r.slideClass, ', swiper-slide')) && (i = e); })); let s; let n = !1; if (i) for (let l = 0; l < a.slides.length; l += 1) if (a.slides[l] === i) { n = !0, s = l; break; } if (!i || !n) return a.clickedSlide = void 0, void (a.clickedIndex = void 0); a.clickedSlide = i, a.virtual && a.params.virtual.enabled ? a.clickedIndex = parseInt(i.getAttribute('data-swiper-slide-index'), 10) : a.clickedIndex = s, r.slideToClickedSlide && void 0 !== a.clickedIndex && a.clickedIndex !== a.activeIndex && a.slideToClickedSlide(); },
      }; const j = {
        getTranslate(e) { void 0 === e && (e = this.isHorizontal() ? 'x' : 'y'); const t = this.params; const a = this.rtlTranslate; const r = this.translate; const i = this.wrapperEl; if (t.virtualTranslate) return a ? -r : r; if (t.cssMode) return r; let s = w(i, e); return s += this.cssOverflowAdjustment(), a && (s = -s), s || 0; }, setTranslate(e, t) { const a = this; const r = a.rtlTranslate; const i = a.params; const s = a.wrapperEl; const n = a.progress; let o = 0; let l = 0; a.isHorizontal() ? o = r ? -e : e : l = e, i.roundLengths && (o = Math.floor(o), l = Math.floor(l)), a.previousTranslate = a.translate, a.translate = a.isHorizontal() ? o : l, i.cssMode ? s[a.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = a.isHorizontal() ? -o : -l : i.virtualTranslate || (a.isHorizontal() ? o -= a.cssOverflowAdjustment() : l -= a.cssOverflowAdjustment(), s.style.transform = 'translate3d('.concat(o, 'px, ').concat(l, 'px, 0px)')); const d = a.maxTranslate() - a.minTranslate(); (d === 0 ? 0 : (e - a.minTranslate()) / d) !== n && a.updateProgress(e), a.emit('setTranslate', a.translate, t); }, minTranslate() { return -this.snapGrid[0]; }, maxTranslate() { return -this.snapGrid[this.snapGrid.length - 1]; }, translateTo(e, t, a, r, i) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === a && (a = !0), void 0 === r && (r = !0); const s = this; const n = s.params; const o = s.wrapperEl; if (s.animating && n.preventInteractionOnTransition) return !1; let l; const d = s.minTranslate(); const u = s.maxTranslate(); if (l = r && e > d ? d : r && e < u ? u : e, s.updateProgress(l), n.cssMode) { const p = s.isHorizontal(); if (t === 0)o[p ? 'scrollLeft' : 'scrollTop'] = -l; else { if (!s.support.smoothScroll) return x({ swiper: s, targetPosition: -l, side: p ? 'left' : 'top' }), !0; o.scrollTo(c(c({}, p ? 'left' : 'top', -l), 'behavior', 'smooth')); } return !0; } return t === 0 ? (s.setTransition(0), s.setTranslate(l), a && (s.emit('beforeTransitionStart', t, i), s.emit('transitionEnd'))) : (s.setTransition(t), s.setTranslate(l), a && (s.emit('beforeTransitionStart', t, i), s.emit('transitionStart')), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function (e) { s && !s.destroyed && e.target === this && (s.wrapperEl.removeEventListener('transitionend', s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, s.animating = !1, a && s.emit('transitionEnd')); }), s.wrapperEl.addEventListener('transitionend', s.onTranslateToWrapperTransitionEnd))), !0; },
      }; function q(e) { const t = e.swiper; const a = e.runCallbacks; const r = e.direction; const i = e.step; const s = t.activeIndex; const n = t.previousIndex; let o = r; if (o || (o = s > n ? 'next' : s < n ? 'prev' : 'reset'), t.emit('transition'.concat(i)), a && s !== n) { if (o === 'reset') return void t.emit('slideResetTransition'.concat(i)); t.emit('slideChangeTransition'.concat(i)), o === 'next' ? t.emit('slideNextTransition'.concat(i)) : t.emit('slidePrevTransition'.concat(i)); } } const W = {
        slideTo(e, t, a, r, i) { void 0 === e && (e = 0), void 0 === a && (a = !0), typeof e === 'string' && (e = parseInt(e, 10)); const s = this; let n = e; n < 0 && (n = 0); const o = s.params; const l = s.snapGrid; const d = s.slidesGrid; const u = s.previousIndex; const p = s.activeIndex; const f = s.rtlTranslate; const m = s.wrapperEl; if (!s.enabled && !r && !i || s.destroyed || s.animating && o.preventInteractionOnTransition) return !1; void 0 === t && (t = s.params.speed); const v = Math.min(s.params.slidesPerGroupSkip, n); let h = v + Math.floor((n - v) / s.params.slidesPerGroup); h >= l.length && (h = l.length - 1); let g; const w = -l[h]; if (o.normalizeSlideIndex) for (let b = 0; b < d.length; b += 1) { const y = -Math.floor(100 * w); const E = Math.floor(100 * d[b]); const S = Math.floor(100 * d[b + 1]); void 0 !== d[b + 1] ? y >= E && y < S - (S - E) / 2 ? n = b : y >= E && y < S && (n = b + 1) : y >= E && (n = b); } if (s.initialized && n !== p) { if (!s.allowSlideNext && (f ? w > s.translate && w > s.minTranslate() : w < s.translate && w < s.minTranslate())) return !1; if (!s.allowSlidePrev && w > s.translate && w > s.maxTranslate() && (p || 0) !== n) return !1; }n !== (u || 0) && a && s.emit('beforeSlideChangeStart'), s.updateProgress(w), g = n > p ? 'next' : n < p ? 'prev' : 'reset'; const T = s.virtual && s.params.virtual.enabled; if ((!T || !i) && (f && -w === s.translate || !f && w === s.translate)) return s.updateActiveIndex(n), o.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), o.effect !== 'slide' && s.setTranslate(w), g !== 'reset' && (s.transitionStart(a, g), s.transitionEnd(a, g)), !1; if (o.cssMode) { const M = s.isHorizontal(); const C = f ? w : -w; if (t === 0)T && (s.wrapperEl.style.scrollSnapType = 'none', s._immediateVirtual = !0), T && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => { m[M ? 'scrollLeft' : 'scrollTop'] = C; }))) : m[M ? 'scrollLeft' : 'scrollTop'] = C, T && requestAnimationFrame((() => { s.wrapperEl.style.scrollSnapType = '', s._immediateVirtual = !1; })); else { if (!s.support.smoothScroll) return x({ swiper: s, targetPosition: C, side: M ? 'left' : 'top' }), !0; m.scrollTo(c(c({}, M ? 'left' : 'top', C), 'behavior', 'smooth')); } return !0; } return s.setTransition(t), s.setTranslate(w), s.updateActiveIndex(n), s.updateSlidesClasses(), s.emit('beforeTransitionStart', t, r), s.transitionStart(a, g), t === 0 ? s.transitionEnd(a, g) : s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function (e) { s && !s.destroyed && e.target === this && (s.wrapperEl.removeEventListener('transitionend', s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(a, g)); }), s.wrapperEl.addEventListener('transitionend', s.onSlideToWrapperTransitionEnd)), !0; },
        slideToLoop(e, t, a, r) {
          void 0 === e && (e = 0), void 0 === a && (a = !0), typeof e === 'string' && (e = parseInt(e, 10)); const i = this; if (!i.destroyed) {
            void 0 === t && (t = i.params.speed); const s = i.grid && i.params.grid && i.params.grid.rows > 1; let n = e; if (i.params.loop) {
              if (i.virtual && i.params.virtual.enabled)n += i.virtual.slidesBefore; else {
                let o; if (s) { const l = n * i.params.grid.rows; o = i.slides.filter(((e) => 1 * e.getAttribute('data-swiper-slide-index') === l))[0].column; } else o = i.getSlideIndexByData(n); const d = s ? Math.ceil(i.slides.length / i.params.grid.rows) : i.slides.length; const c = i.params.centeredSlides; let u = i.params.slidesPerView; u === 'auto' ? u = i.slidesPerViewDynamic() : (u = Math.ceil(parseFloat(i.params.slidesPerView, 10)), c && u % 2 == 0 && (u += 1)); let p = d - o < u; if (c && (p = p || o < Math.ceil(u / 2)), r && c && i.params.slidesPerView !== 'auto' && !s && (p = !1), p) {
                  const f = c ? o < i.activeIndex ? 'prev' : 'next' : o - i.activeIndex - 1 < i.params.slidesPerView ? 'next' : 'prev'; i.loopFix({
                    direction: f, slideTo: !0, activeSlideIndex: f === 'next' ? o + 1 : o - d + 1, slideRealIndex: f === 'next' ? i.realIndex : void 0,
                  });
                } if (s) { const m = n * i.params.grid.rows; n = i.slides.filter(((e) => 1 * e.getAttribute('data-swiper-slide-index') === m))[0].column; } else n = i.getSlideIndexByData(n);
              }
            } return requestAnimationFrame((() => { i.slideTo(n, t, a, r); })), i;
          }
        },
        slideNext(e, t, a) { void 0 === t && (t = !0); const r = this; const i = r.enabled; const s = r.params; const n = r.animating; if (!i || r.destroyed) return r; void 0 === e && (e = r.params.speed); let o = s.slidesPerGroup; s.slidesPerView === 'auto' && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (o = Math.max(r.slidesPerViewDynamic('current', !0), 1)); const l = r.activeIndex < s.slidesPerGroupSkip ? 1 : o; const d = r.virtual && s.virtual.enabled; if (s.loop) { if (n && !d && s.loopPreventsSliding) return !1; if (r.loopFix({ direction: 'next' }), r._clientLeft = r.wrapperEl.clientLeft, r.activeIndex === r.slides.length - 1 && s.cssMode) return requestAnimationFrame((() => { r.slideTo(r.activeIndex + l, e, t, a); })), !0; } return s.rewind && r.isEnd ? r.slideTo(0, e, t, a) : r.slideTo(r.activeIndex + l, e, t, a); },
        slidePrev(e, t, a) { void 0 === t && (t = !0); const r = this; const i = r.params; const s = r.snapGrid; const n = r.slidesGrid; const o = r.rtlTranslate; const l = r.enabled; const d = r.animating; if (!l || r.destroyed) return r; void 0 === e && (e = r.params.speed); const c = r.virtual && i.virtual.enabled; if (i.loop) { if (d && !c && i.loopPreventsSliding) return !1; r.loopFix({ direction: 'prev' }), r._clientLeft = r.wrapperEl.clientLeft; } function u(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e); } let p; const f = u(o ? r.translate : -r.translate); const m = s.map(((e) => u(e))); let v = s[m.indexOf(f) - 1]; void 0 === v && i.cssMode && (s.forEach(((e, t) => { f >= e && (p = t); })), void 0 !== p && (v = s[p > 0 ? p - 1 : p])); let h = 0; if (void 0 !== v && ((h = n.indexOf(v)) < 0 && (h = r.activeIndex - 1), i.slidesPerView === 'auto' && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (h = h - r.slidesPerViewDynamic('previous', !0) + 1, h = Math.max(h, 0))), i.rewind && r.isBeginning) { const g = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1; return r.slideTo(g, e, t, a); } return i.loop && r.activeIndex === 0 && i.cssMode ? (requestAnimationFrame((() => { r.slideTo(h, e, t, a); })), !0) : r.slideTo(h, e, t, a); },
        slideReset(e, t, a) { void 0 === t && (t = !0); const r = this; if (!r.destroyed) return void 0 === e && (e = r.params.speed), r.slideTo(r.activeIndex, e, t, a); },
        slideToClosest(e, t, a, r) { void 0 === t && (t = !0), void 0 === r && (r = 0.5); const i = this; if (!i.destroyed) { void 0 === e && (e = i.params.speed); let s = i.activeIndex; const n = Math.min(i.params.slidesPerGroupSkip, s); const o = n + Math.floor((s - n) / i.params.slidesPerGroup); const l = i.rtlTranslate ? i.translate : -i.translate; if (l >= i.snapGrid[o]) { const d = i.snapGrid[o]; l - d > (i.snapGrid[o + 1] - d) * r && (s += i.params.slidesPerGroup); } else { const c = i.snapGrid[o - 1]; l - c <= (i.snapGrid[o] - c) * r && (s -= i.params.slidesPerGroup); } return s = Math.max(s, 0), s = Math.min(s, i.slidesGrid.length - 1), i.slideTo(s, e, t, a); } },
        slideToClickedSlide() { const e = this; if (!e.destroyed) { let t; const a = e.params; const r = e.slidesEl; const i = a.slidesPerView === 'auto' ? e.slidesPerViewDynamic() : a.slidesPerView; let s = e.clickedIndex; const n = e.isElement ? 'swiper-slide' : '.'.concat(a.slideClass); if (a.loop) { if (e.animating) return; t = parseInt(e.clickedSlide.getAttribute('data-swiper-slide-index'), 10), a.centeredSlides ? s < e.loopedSlides - i / 2 || s > e.slides.length - e.loopedSlides + i / 2 ? (e.loopFix(), s = e.getSlideIndex(T(r, ''.concat(n, '[data-swiper-slide-index="').concat(t, '"]'))[0]), h((() => { e.slideTo(s); }))) : e.slideTo(s) : s > e.slides.length - i ? (e.loopFix(), s = e.getSlideIndex(T(r, ''.concat(n, '[data-swiper-slide-index="').concat(t, '"]'))[0]), h((() => { e.slideTo(s); }))) : e.slideTo(s); } else e.slideTo(s); } },
      }; const U = {
        loopCreate(e) { const t = this; const a = t.params; const r = t.slidesEl; if (!(!a.loop || t.virtual && t.params.virtual.enabled)) { const i = function () { T(r, '.'.concat(a.slideClass, ', swiper-slide')).forEach(((e, t) => { e.setAttribute('data-swiper-slide-index', t); })); }; const s = t.grid && a.grid && a.grid.rows > 1; const n = a.slidesPerGroup * (s ? a.grid.rows : 1); const o = t.slides.length % n != 0; const l = s && t.slides.length % a.grid.rows != 0; const d = function (e) { for (let r = 0; r < e; r += 1) { const i = t.isElement ? C('swiper-slide', [a.slideBlankClass]) : C('div', [a.slideClass, a.slideBlankClass]); t.slidesEl.append(i); } }; o ? (a.loopAddBlankSlides ? (d(n - t.slides.length % n), t.recalcSlides(), t.updateSlides()) : M('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)'), i()) : l ? (a.loopAddBlankSlides ? (d(a.grid.rows - t.slides.length % a.grid.rows), t.recalcSlides(), t.updateSlides()) : M('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)'), i()) : i(), t.loopFix({ slideRealIndex: e, direction: a.centeredSlides ? void 0 : 'next' }); } },
        loopFix(e) {
          const t = void 0 === e ? {} : e; const a = t.slideRealIndex; const r = t.slideTo; const i = void 0 === r || r; const n = t.direction; const o = t.setTranslate; let l = t.activeSlideIndex; const d = t.byController; const c = t.byMousewheel; const u = this; if (u.params.loop) {
            u.emit('beforeLoopFix'); const p = u.slides; const f = u.allowSlidePrev; const m = u.allowSlideNext; const v = u.slidesEl; const h = u.params; const g = h.centeredSlides; if (u.allowSlidePrev = !0, u.allowSlideNext = !0, u.virtual && h.virtual.enabled) return i && (h.centeredSlides || u.snapIndex !== 0 ? h.centeredSlides && u.snapIndex < h.slidesPerView ? u.slideTo(u.virtual.slides.length + u.snapIndex, 0, !1, !0) : u.snapIndex === u.snapGrid.length - 1 && u.slideTo(u.virtual.slidesBefore, 0, !1, !0) : u.slideTo(u.virtual.slides.length, 0, !1, !0)), u.allowSlidePrev = f, u.allowSlideNext = m, void u.emit('loopFix'); let w = h.slidesPerView; w === 'auto' ? w = u.slidesPerViewDynamic() : (w = Math.ceil(parseFloat(h.slidesPerView, 10)), g && w % 2 == 0 && (w += 1)); const b = h.slidesPerGroupAuto ? w : h.slidesPerGroup; let y = b; y % b != 0 && (y += b - y % b), y += h.loopAdditionalSlides, u.loopedSlides = y; const E = u.grid && h.grid && h.grid.rows > 1; p.length < w + y ? M('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters') : E && h.grid.fill === 'row' && M('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`'); const x = []; const S = []; let T = u.activeIndex; void 0 === l ? l = u.getSlideIndex(p.filter(((e) => e.classList.contains(h.slideActiveClass)))[0]) : T = l; const C = n === 'next' || !n; const P = n === 'prev' || !n; let L = 0; let k = 0; const I = E ? Math.ceil(p.length / h.grid.rows) : p.length; const A = (E ? p[l].column : l) + (g && void 0 === o ? -w / 2 + 0.5 : 0); if (A < y) { L = Math.max(y - A, b); for (let z = 0; z < y - A; z += 1) { const O = z - Math.floor(z / I) * I; if (E) for (let D = I - O - 1, G = p.length - 1; G >= 0; G -= 1)p[G].column === D && x.push(G); else x.push(I - O - 1); } } else if (A + w > I - y) { k = Math.max(A - (I - 2 * y), b); for (var H = function () { const e = B - Math.floor(B / I) * I; E ? p.forEach(((t, a) => { t.column === e && S.push(a); })) : S.push(e); }, B = 0; B < k; B += 1)H(); } if (u.__preventObserver__ = !0, requestAnimationFrame((() => { u.__preventObserver__ = !1; })), P && x.forEach(((e) => { p[e].swiperLoopMoveDOM = !0, v.prepend(p[e]), p[e].swiperLoopMoveDOM = !1; })), C && S.forEach(((e) => { p[e].swiperLoopMoveDOM = !0, v.append(p[e]), p[e].swiperLoopMoveDOM = !1; })), u.recalcSlides(), h.slidesPerView === 'auto' ? u.updateSlides() : E && (x.length > 0 && P || S.length > 0 && C) && u.slides.forEach(((e, t) => { u.grid.updateSlide(t, e, u.slides); })), h.watchSlidesProgress && u.updateSlidesOffset(), i) if (x.length > 0 && P) { if (void 0 === a) { const N = u.slidesGrid[T]; const X = u.slidesGrid[T + L] - N; c ? u.setTranslate(u.translate - X) : (u.slideTo(T + Math.ceil(L), 0, !1, !0), o && (u.touchEventsData.startTranslate = u.touchEventsData.startTranslate - X, u.touchEventsData.currentTranslate = u.touchEventsData.currentTranslate - X)); } else if (o) { const Y = E ? x.length / h.grid.rows : x.length; u.slideTo(u.activeIndex + Y, 0, !1, !0), u.touchEventsData.currentTranslate = u.translate; } } else if (S.length > 0 && C) if (void 0 === a) { const R = u.slidesGrid[T]; const _ = u.slidesGrid[T - k] - R; c ? u.setTranslate(u.translate - _) : (u.slideTo(T - k, 0, !1, !0), o && (u.touchEventsData.startTranslate = u.touchEventsData.startTranslate - _, u.touchEventsData.currentTranslate = u.touchEventsData.currentTranslate - _)); } else { const F = E ? S.length / h.grid.rows : S.length; u.slideTo(u.activeIndex - F, 0, !1, !0); } if (u.allowSlidePrev = f, u.allowSlideNext = m, u.controller && u.controller.control && !d) {
              const V = {
                slideRealIndex: a, direction: n, setTranslate: o, activeSlideIndex: l, byController: !0,
              }; Array.isArray(u.controller.control) ? u.controller.control.forEach(((e) => { !e.destroyed && e.params.loop && e.loopFix(s(s({}, V), {}, { slideTo: e.params.slidesPerView === h.slidesPerView && i })); })) : u.controller.control instanceof u.constructor && u.controller.control.params.loop && u.controller.control.loopFix(s(s({}, V), {}, { slideTo: u.controller.control.params.slidesPerView === h.slidesPerView && i }));
            }u.emit('loopFix');
          }
        },
        loopDestroy() { const e = this; const t = e.params; const a = e.slidesEl; if (!(!t.loop || e.virtual && e.params.virtual.enabled)) { e.recalcSlides(); const r = []; e.slides.forEach(((e) => { const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute('data-swiper-slide-index') : e.swiperSlideIndex; r[t] = e; })), e.slides.forEach(((e) => { e.removeAttribute('data-swiper-slide-index'); })), r.forEach(((e) => { a.append(e); })), e.recalcSlides(), e.slideTo(e.realIndex, 0); } },
      }; function K(e, t, a) { const r = m(); const i = e.params; const s = i.edgeSwipeDetection; const n = i.edgeSwipeThreshold; return !s || !(a <= n || a >= r.innerWidth - n) || s === 'prevent' && (t.preventDefault(), !0); } function Z(e) {
        const t = this; const a = i(); let r = e; r.originalEvent && (r = r.originalEvent); const s = t.touchEventsData; if (r.type === 'pointerdown') { if (s.pointerId !== null && s.pointerId !== r.pointerId) return; s.pointerId = r.pointerId; } else r.type === 'touchstart' && r.targetTouches.length === 1 && (s.touchId = r.targetTouches[0].identifier); if (r.type !== 'touchstart') {
          const n = t.params; const l = t.touches; if (t.enabled && (n.simulateTouch || r.pointerType !== 'mouse') && (!t.animating || !n.preventInteractionOnTransition)) {
            !t.animating && n.cssMode && n.loop && t.loopFix(); let d = r.target; if ((n.touchEventsTarget !== 'wrapper' || (function (e, t) { const a = t.contains(e); return !a && t instanceof HTMLSlotElement ? o(t.assignedElements()).includes(e) : a; }(d, t.wrapperEl))) && !('which' in r && r.which === 3 || 'button' in r && r.button > 0 || s.isTouched && s.isMoved)) {
              const c = !!n.noSwipingClass && n.noSwipingClass !== ''; const u = r.composedPath ? r.composedPath() : r.path; c && r.target && r.target.shadowRoot && u && (d = u[0]); const p = n.noSwipingSelector ? n.noSwipingSelector : '.'.concat(n.noSwipingClass); const f = !(!r.target || !r.target.shadowRoot); if (n.noSwiping && (f ? (function (e, t) { return void 0 === t && (t = this), (function t(a) { if (!a || a === i() || a === m()) return null; a.assignedSlot && (a = a.assignedSlot); const r = a.closest(e); return r || a.getRootNode ? r || t(a.getRootNode().host) : null; }(t)); }(p, d)) : d.closest(p)))t.allowClick = !0; else if (!n.swipeHandler || d.closest(n.swipeHandler)) {
                l.currentX = r.pageX, l.currentY = r.pageY; const v = l.currentX; const h = l.currentY; if (K(t, r, v)) {
                  Object.assign(s, {
                    isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0,
                  }), l.startX = v, l.startY = h, s.touchStartTime = g(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, n.threshold > 0 && (s.allowThresholdMove = !1); let w = !0; d.matches(s.focusableElements) && (w = !1, d.nodeName === 'SELECT' && (s.isTouched = !1)), a.activeElement && a.activeElement.matches(s.focusableElements) && a.activeElement !== d && a.activeElement.blur(); const b = w && t.allowTouchMove && n.touchStartPreventDefault; !n.touchStartForcePreventDefault && !b || d.isContentEditable || r.preventDefault(), n.freeMode && n.freeMode.enabled && t.freeMode && t.animating && !n.cssMode && t.freeMode.onTouchStart(), t.emit('touchStart', r);
                }
              }
            }
          }
        } else K(t, r, r.targetTouches[0].pageX);
      } function $(e) {
        const t = i(); const a = this; const r = a.touchEventsData; const s = a.params; const n = a.touches; const l = a.rtlTranslate; if (a.enabled && (s.simulateTouch || e.pointerType !== 'mouse')) {
          let d; let c = e; if (c.originalEvent && (c = c.originalEvent), c.type === 'pointermove') { if (r.touchId !== null) return; if (c.pointerId !== r.pointerId) return; } if (c.type === 'touchmove') { if (d = o(c.changedTouches).filter(((e) => e.identifier === r.touchId))[0], !d || d.identifier !== r.touchId) return; } else d = c; if (r.isTouched) {
            const u = d.pageX; const p = d.pageY; if (c.preventedByNestedSwiper) return n.startX = u, void (n.startY = p); if (!a.allowTouchMove) {
              return c.target.matches(r.focusableElements) || (a.allowClick = !1), void (r.isTouched && (Object.assign(n, {
                startX: u, startY: p, currentX: u, currentY: p,
              }), r.touchStartTime = g()));
            } if (s.touchReleaseOnEdges && !s.loop) if (a.isVertical()) { if (p < n.startY && a.translate <= a.maxTranslate() || p > n.startY && a.translate >= a.minTranslate()) return r.isTouched = !1, void (r.isMoved = !1); } else if (u < n.startX && a.translate <= a.maxTranslate() || u > n.startX && a.translate >= a.minTranslate()) return; if (t.activeElement && c.target === t.activeElement && c.target.matches(r.focusableElements)) return r.isMoved = !0, void (a.allowClick = !1); r.allowTouchCallbacks && a.emit('touchMove', c), n.previousX = n.currentX, n.previousY = n.currentY, n.currentX = u, n.currentY = p; let f; const m = n.currentX - n.startX; const v = n.currentY - n.startY; if (!(a.params.threshold && Math.sqrt(m ** 2 + v ** 2) < a.params.threshold)) {
              if (void 0 === r.isScrolling && (a.isHorizontal() && n.currentY === n.startY || a.isVertical() && n.currentX === n.startX ? r.isScrolling = !1 : m * m + v * v >= 25 && (f = 180 * Math.atan2(Math.abs(v), Math.abs(m)) / Math.PI, r.isScrolling = a.isHorizontal() ? f > s.touchAngle : 90 - f > s.touchAngle)), r.isScrolling && a.emit('touchMoveOpposite', c), void 0 === r.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (r.startMoving = !0)), r.isScrolling || c.type === 'touchmove' && r.preventTouchMoveFromPointerMove)r.isTouched = !1; else if (r.startMoving) {
                a.allowClick = !1, !s.cssMode && c.cancelable && c.preventDefault(), s.touchMoveStopPropagation && !s.nested && c.stopPropagation(); let h = a.isHorizontal() ? m : v; let w = a.isHorizontal() ? n.currentX - n.previousX : n.currentY - n.previousY; s.oneWayMovement && (h = Math.abs(h) * (l ? 1 : -1), w = Math.abs(w) * (l ? 1 : -1)), n.diff = h, h *= s.touchRatio, l && (h = -h, w = -w); const b = a.touchesDirection; a.swipeDirection = h > 0 ? 'prev' : 'next', a.touchesDirection = w > 0 ? 'prev' : 'next'; const y = a.params.loop && !s.cssMode; const E = a.touchesDirection === 'next' && a.allowSlideNext || a.touchesDirection === 'prev' && a.allowSlidePrev; if (!r.isMoved) { if (y && E && a.loopFix({ direction: a.swipeDirection }), r.startTranslate = a.getTranslate(), a.setTransition(0), a.animating) { const x = new window.CustomEvent('transitionend', { bubbles: !0, cancelable: !0, detail: { bySwiperTouchMove: !0 } }); a.wrapperEl.dispatchEvent(x); }r.allowMomentumBounce = !1, !s.grabCursor || !0 !== a.allowSlideNext && !0 !== a.allowSlidePrev || a.setGrabCursor(!0), a.emit('sliderFirstMove', c); } if ((new Date()).getTime(), r.isMoved && r.allowThresholdMove && b !== a.touchesDirection && y && E && Math.abs(h) >= 1) {
                  return Object.assign(n, {
                    startX: u, startY: p, currentX: u, currentY: p, startTranslate: r.currentTranslate,
                  }), r.loopSwapReset = !0, void (r.startTranslate = r.currentTranslate);
                } a.emit('sliderMove', c), r.isMoved = !0, r.currentTranslate = h + r.startTranslate; let S = !0; let T = s.resistanceRatio; if (s.touchReleaseOnEdges && (T = 0), h > 0 ? (y && E && r.allowThresholdMove && r.currentTranslate > (s.centeredSlides ? a.minTranslate() - a.slidesSizesGrid[a.activeIndex + 1] - (s.slidesPerView !== 'auto' && a.slides.length - s.slidesPerView >= 2 ? a.slidesSizesGrid[a.activeIndex + 1] + a.params.spaceBetween : 0) - a.params.spaceBetween : a.minTranslate()) && a.loopFix({ direction: 'prev', setTranslate: !0, activeSlideIndex: 0 }), r.currentTranslate > a.minTranslate() && (S = !1, s.resistance && (r.currentTranslate = a.minTranslate() - 1 + (-a.minTranslate() + r.startTranslate + h) ** T))) : h < 0 && (y && E && r.allowThresholdMove && r.currentTranslate < (s.centeredSlides ? a.maxTranslate() + a.slidesSizesGrid[a.slidesSizesGrid.length - 1] + a.params.spaceBetween + (s.slidesPerView !== 'auto' && a.slides.length - s.slidesPerView >= 2 ? a.slidesSizesGrid[a.slidesSizesGrid.length - 1] + a.params.spaceBetween : 0) : a.maxTranslate()) && a.loopFix({ direction: 'next', setTranslate: !0, activeSlideIndex: a.slides.length - (s.slidesPerView === 'auto' ? a.slidesPerViewDynamic() : Math.ceil(parseFloat(s.slidesPerView, 10))) }), r.currentTranslate < a.maxTranslate() && (S = !1, s.resistance && (r.currentTranslate = a.maxTranslate() + 1 - (a.maxTranslate() - r.startTranslate - h) ** T))), S && (c.preventedByNestedSwiper = !0), !a.allowSlideNext && a.swipeDirection === 'next' && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !a.allowSlidePrev && a.swipeDirection === 'prev' && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), a.allowSlidePrev || a.allowSlideNext || (r.currentTranslate = r.startTranslate), s.threshold > 0) { if (!(Math.abs(h) > s.threshold || r.allowThresholdMove)) return void (r.currentTranslate = r.startTranslate); if (!r.allowThresholdMove) return r.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, r.currentTranslate = r.startTranslate, void (n.diff = a.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY); }s.followFinger && !s.cssMode && ((s.freeMode && s.freeMode.enabled && a.freeMode || s.watchSlidesProgress) && (a.updateActiveIndex(), a.updateSlidesClasses()), s.freeMode && s.freeMode.enabled && a.freeMode && a.freeMode.onTouchMove(), a.updateProgress(r.currentTranslate), a.setTranslate(r.currentTranslate));
              }
            }
          } else r.startMoving && r.isScrolling && a.emit('touchMoveOpposite', c);
        }
      } function Q(e) { let t; const a = this; const r = a.touchEventsData; let i = e; if (i.originalEvent && (i = i.originalEvent), i.type === 'touchend' || i.type === 'touchcancel') { if (t = o(i.changedTouches).filter(((e) => e.identifier === r.touchId))[0], !t || t.identifier !== r.touchId) return; } else { if (r.touchId !== null) return; if (i.pointerId !== r.pointerId) return; t = i; } if (!['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(i.type) || ['pointercancel', 'contextmenu'].includes(i.type) && (a.browser.isSafari || a.browser.isWebView)) { r.pointerId = null, r.touchId = null; const s = a.params; const n = a.touches; const l = a.rtlTranslate; const d = a.slidesGrid; if (a.enabled && (s.simulateTouch || i.pointerType !== 'mouse')) { if (r.allowTouchCallbacks && a.emit('touchEnd', i), r.allowTouchCallbacks = !1, !r.isTouched) return r.isMoved && s.grabCursor && a.setGrabCursor(!1), r.isMoved = !1, void (r.startMoving = !1); s.grabCursor && r.isMoved && r.isTouched && (!0 === a.allowSlideNext || !0 === a.allowSlidePrev) && a.setGrabCursor(!1); let c; const u = g(); const p = u - r.touchStartTime; if (a.allowClick) { const f = i.path || i.composedPath && i.composedPath(); a.updateClickedSlide(f && f[0] || i.target, f), a.emit('tap click', i), p < 300 && u - r.lastClickTime < 300 && a.emit('doubleTap doubleClick', i); } if (r.lastClickTime = g(), h((() => { a.destroyed || (a.allowClick = !0); })), !r.isTouched || !r.isMoved || !a.swipeDirection || n.diff === 0 && !r.loopSwapReset || r.currentTranslate === r.startTranslate && !r.loopSwapReset) return r.isTouched = !1, r.isMoved = !1, void (r.startMoving = !1); if (r.isTouched = !1, r.isMoved = !1, r.startMoving = !1, c = s.followFinger ? l ? a.translate : -a.translate : -r.currentTranslate, !s.cssMode) if (s.freeMode && s.freeMode.enabled)a.freeMode.onTouchEnd({ currentPos: c }); else { for (var m = c >= -a.maxTranslate() && !a.params.loop, v = 0, w = a.slidesSizesGrid[0], b = 0; b < d.length; b += b < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) { const y = b < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; void 0 !== d[b + y] ? (m || c >= d[b] && c < d[b + y]) && (v = b, w = d[b + y] - d[b]) : (m || c >= d[b]) && (v = b, w = d[d.length - 1] - d[d.length - 2]); } let E = null; let x = null; s.rewind && (a.isBeginning ? x = s.virtual && s.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1 : a.isEnd && (E = 0)); const S = (c - d[v]) / w; const T = v < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; if (p > s.longSwipesMs) { if (!s.longSwipes) return void a.slideTo(a.activeIndex); a.swipeDirection === 'next' && (S >= s.longSwipesRatio ? a.slideTo(s.rewind && a.isEnd ? E : v + T) : a.slideTo(v)), a.swipeDirection === 'prev' && (S > 1 - s.longSwipesRatio ? a.slideTo(v + T) : x !== null && S < 0 && Math.abs(S) > s.longSwipesRatio ? a.slideTo(x) : a.slideTo(v)); } else { if (!s.shortSwipes) return void a.slideTo(a.activeIndex); !a.navigation || i.target !== a.navigation.nextEl && i.target !== a.navigation.prevEl ? (a.swipeDirection === 'next' && a.slideTo(E !== null ? E : v + T), a.swipeDirection === 'prev' && a.slideTo(x !== null ? x : v)) : i.target === a.navigation.nextEl ? a.slideTo(v + T) : a.slideTo(v); } } } } } function J() { const e = this; const t = e.params; const a = e.el; if (!a || a.offsetWidth !== 0) { t.breakpoints && e.setBreakpoint(); const r = e.allowSlideNext; const i = e.allowSlidePrev; const s = e.snapGrid; const n = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); const o = n && t.loop; !(t.slidesPerView === 'auto' || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || o ? e.params.loop && !n ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume(); }), 500)), e.allowSlidePrev = i, e.allowSlideNext = r, e.params.watchOverflow && s !== e.snapGrid && e.checkOverflow(); } } function ee(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))); } function te() { const e = this; const t = e.wrapperEl; const a = e.rtlTranslate; if (e.enabled) { e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, e.translate === 0 && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); (r === 0 ? 0 : (e.translate - e.minTranslate()) / r) !== e.progress && e.updateProgress(a ? -e.translate : e.translate), e.emit('setTranslate', e.translate, !1); } } function ae(e) { const t = this; R(t, e.target), t.params.cssMode || t.params.slidesPerView !== 'auto' && !t.params.autoHeight || t.update(); } function re() { const e = this; e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = 'auto')); } const ie = function (e, t) { const a = i(); const r = e.params; const s = e.el; const n = e.wrapperEl; const o = e.device; const l = !!r.nested; const d = t === 'on' ? 'addEventListener' : 'removeEventListener'; const c = t; s && typeof s !== 'string' && (a[d]('touchstart', e.onDocumentTouchStart, { passive: !1, capture: l }), s[d]('touchstart', e.onTouchStart, { passive: !1 }), s[d]('pointerdown', e.onTouchStart, { passive: !1 }), a[d]('touchmove', e.onTouchMove, { passive: !1, capture: l }), a[d]('pointermove', e.onTouchMove, { passive: !1, capture: l }), a[d]('touchend', e.onTouchEnd, { passive: !0 }), a[d]('pointerup', e.onTouchEnd, { passive: !0 }), a[d]('pointercancel', e.onTouchEnd, { passive: !0 }), a[d]('touchcancel', e.onTouchEnd, { passive: !0 }), a[d]('pointerout', e.onTouchEnd, { passive: !0 }), a[d]('pointerleave', e.onTouchEnd, { passive: !0 }), a[d]('contextmenu', e.onTouchEnd, { passive: !0 }), (r.preventClicks || r.preventClicksPropagation) && s[d]('click', e.onClick, !0), r.cssMode && n[d]('scroll', e.onScroll), r.updateOnWindowResize ? e[c](o.ios || o.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', J, !0) : e[c]('observerUpdate', J, !0), s[d]('load', e.onLoad, { capture: !0 })); }; const se = function (e, t) { return e.grid && t.grid && t.grid.rows > 1; }; const ne = {
        init: !0, direction: 'horizontal', oneWayMovement: !1, swiperElementNodeName: 'SWIPER-CONTAINER', touchEventsTarget: 'wrapper', initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: 'swiper', enabled: !0, focusableElements: 'input, select, option, textarea, button, video, label', width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: 'slide', breakpoints: void 0, breakpointsBase: 'window', spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: 0.5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: 0.85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: 'swiper-no-swiping', noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: 'swiper-', slideClass: 'swiper-slide', slideBlankClass: 'swiper-slide-blank', slideActiveClass: 'swiper-slide-active', slideVisibleClass: 'swiper-slide-visible', slideFullyVisibleClass: 'swiper-slide-fully-visible', slideNextClass: 'swiper-slide-next', slidePrevClass: 'swiper-slide-prev', wrapperClass: 'swiper-wrapper', lazyPreloaderClass: 'swiper-lazy-preloader', lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1,
      }; function oe(e, t) { return function (a) { void 0 === a && (a = {}); const r = Object.keys(a)[0]; const i = a[r]; p(i) == 'object' && i !== null ? (!0 === e[r] && (e[r] = { enabled: !0 }), r === 'navigation' && e[r] && e[r].enabled && !e[r].prevEl && !e[r].nextEl && (e[r].auto = !0), ['pagination', 'scrollbar'].indexOf(r) >= 0 && e[r] && e[r].enabled && !e[r].el && (e[r].auto = !0), r in e && 'enabled' in i ? (p(e[r]) != 'object' || 'enabled' in e[r] || (e[r].enabled = !0), e[r] || (e[r] = { enabled: !1 }), y(t, a)) : y(t, a)) : y(t, a); }; } const le = {
        eventsEmitter: N,
        update: V,
        translate: j,
        transition: {
          setTransition(e, t) { const a = this; a.params.cssMode || (a.wrapperEl.style.transitionDuration = ''.concat(e, 'ms'), a.wrapperEl.style.transitionDelay = e === 0 ? '0ms' : ''), a.emit('setTransition', e, t); },
          transitionStart(e, t) {
            void 0 === e && (e = !0); const a = this; const r = a.params; r.cssMode || (r.autoHeight && a.updateAutoHeight(), q({
              swiper: a, runCallbacks: e, direction: t, step: 'Start',
            }));
          },
          transitionEnd(e, t) {
            void 0 === e && (e = !0); const a = this; const r = a.params; a.animating = !1, r.cssMode || (a.setTransition(0), q({
              swiper: a, runCallbacks: e, direction: t, step: 'End',
            }));
          },
        },
        slide: W,
        loop: U,
        grabCursor: { setGrabCursor(e) { const t = this; if (!(!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)) { const a = t.params.touchEventsTarget === 'container' ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), a.style.cursor = 'move', a.style.cursor = e ? 'grabbing' : 'grab', t.isElement && requestAnimationFrame((() => { t.__preventObserver__ = !1; })); } }, unsetGrabCursor() { const e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e[e.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '', e.isElement && requestAnimationFrame((() => { e.__preventObserver__ = !1; }))); } },
        events: { attachEvents() { const e = this; const t = e.params; e.onTouchStart = Z.bind(e), e.onTouchMove = $.bind(e), e.onTouchEnd = Q.bind(e), e.onDocumentTouchStart = re.bind(e), t.cssMode && (e.onScroll = te.bind(e)), e.onClick = ee.bind(e), e.onLoad = ae.bind(e), ie(e, 'on'); }, detachEvents() { ie(this, 'off'); } },
        breakpoints: { setBreakpoint() { const e = this; const t = e.realIndex; const a = e.initialized; const r = e.params; const i = e.el; const s = r.breakpoints; if (s && (!s || Object.keys(s).length !== 0)) { const n = e.getBreakpoint(s, e.params.breakpointsBase, e.el); if (n && e.currentBreakpoint !== n) { const o = (n in s ? s[n] : void 0) || e.originalParams; const l = se(e, r); const d = se(e, o); const c = e.params.grabCursor; const u = o.grabCursor; const p = r.enabled; l && !d ? (i.classList.remove(''.concat(r.containerModifierClass, 'grid'), ''.concat(r.containerModifierClass, 'grid-column')), e.emitContainerClasses()) : !l && d && (i.classList.add(''.concat(r.containerModifierClass, 'grid')), (o.grid.fill && o.grid.fill === 'column' || !o.grid.fill && r.grid.fill === 'column') && i.classList.add(''.concat(r.containerModifierClass, 'grid-column')), e.emitContainerClasses()), c && !u ? e.unsetGrabCursor() : !c && u && e.setGrabCursor(), ['navigation', 'pagination', 'scrollbar'].forEach(((t) => { if (void 0 !== o[t]) { const a = r[t] && r[t].enabled; const i = o[t] && o[t].enabled; a && !i && e[t].disable(), !a && i && e[t].enable(); } })); const f = o.direction && o.direction !== r.direction; const m = r.loop && (o.slidesPerView !== r.slidesPerView || f); const v = r.loop; f && a && e.changeDirection(), y(e.params, o); const h = e.params.enabled; const g = e.params.loop; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), p && !h ? e.disable() : !p && h && e.enable(), e.currentBreakpoint = n, e.emit('_beforeBreakpoint', o), a && (m ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !v && g ? (e.loopCreate(t), e.updateSlides()) : v && !g && e.loopDestroy()), e.emit('breakpoint', o); } } }, getBreakpoint(e, t, a) { if (void 0 === t && (t = 'window'), e && (t !== 'container' || a)) { let r = !1; const i = m(); const s = t === 'window' ? i.innerHeight : a.clientHeight; const n = Object.keys(e).map(((e) => { if (typeof e === 'string' && e.indexOf('@') === 0) { const t = parseFloat(e.substr(1)); return { value: s * t, point: e }; } return { value: e, point: e }; })); n.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let o = 0; o < n.length; o += 1) { const l = n[o]; const d = l.point; const c = l.value; t === 'window' ? i.matchMedia('(min-width: '.concat(c, 'px)')).matches && (r = d) : c <= a.clientWidth && (r = d); } return r || 'max'; } } },
        checkOverflow: { checkOverflow() { const e = this; const t = e.isLocked; const a = e.params; const r = a.slidesOffsetBefore; if (r) { const i = e.slides.length - 1; const s = e.slidesGrid[i] + e.slidesSizesGrid[i] + 2 * r; e.isLocked = e.size > s; } else e.isLocked = e.snapGrid.length === 1; !0 === a.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === a.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? 'lock' : 'unlock'); } },
        classes: { addClasses() { let e; const t = this; const a = t.classNames; const r = t.params; const i = t.rtl; const s = t.el; const n = t.device; const l = (function (e, t) { const a = []; return e.forEach(((e) => { p(e) == 'object' ? Object.keys(e).forEach(((r) => { e[r] && a.push(t + r); })) : typeof e === 'string' && a.push(t + e); })), a; }(['initialized', r.direction, { 'free-mode': t.params.freeMode && r.freeMode.enabled }, { autoheight: r.autoHeight }, { rtl: i }, { grid: r.grid && r.grid.rows > 1 }, { 'grid-column': r.grid && r.grid.rows > 1 && r.grid.fill === 'column' }, { android: n.android }, { ios: n.ios }, { 'css-mode': r.cssMode }, { centered: r.cssMode && r.centeredSlides }, { 'watch-progress': r.watchSlidesProgress }], r.containerModifierClass)); a.push.apply(a, o(l)), (e = s.classList).add.apply(e, o(a)), t.emitContainerClasses(); }, removeClasses() { let e; const t = this.el; const a = this.classNames; t && typeof t !== 'string' && ((e = t.classList).remove.apply(e, o(a)), this.emitContainerClasses()); } },
      }; const de = {}; const ce = (function () {
        function e() {
          let t; let a; let r; let s; !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, e)); for (var l = arguments.length, d = new Array(l), c = 0; c < l; c++)d[c] = arguments[c]; d.length === 1 && d[0].constructor && Object.prototype.toString.call(d[0]).slice(8, -1) === 'Object' ? s = d[0] : (r = (t = n(d, 2))[0], s = t[1]), s || (s = {}), s = y({}, s), r && !s.el && (s.el = r); const u = i(); if (s.el && typeof s.el === 'string' && u.querySelectorAll(s.el).length > 1) { const p = []; return u.querySelectorAll(s.el).forEach(((t) => { const a = y({}, s, { el: t }); p.push(new e(a)); })), p; } const f = this; f.__swiper__ = !0, f.support = G(), f.device = H({ userAgent: s.userAgent }), f.browser = B(), f.eventsListeners = {}, f.eventsAnyListeners = [], f.modules = o(f.__modules__), s.modules && Array.isArray(s.modules) && (a = f.modules).push.apply(a, o(s.modules)); const m = {}; f.modules.forEach(((e) => {
            e({
              params: s, swiper: f, extendParams: oe(s, m), on: f.on.bind(f), once: f.once.bind(f), off: f.off.bind(f), emit: f.emit.bind(f),
            });
          })); const v = y({}, ne, m); return f.params = y({}, v, de, s), f.originalParams = y({}, f.params), f.passedParams = y({}, s), f.params && f.params.on && Object.keys(f.params.on).forEach(((e) => { f.on(e, f.params.on[e]); })), f.params && f.params.onAny && f.onAny(f.params.onAny), Object.assign(f, {
            enabled: f.params.enabled,
            el: r,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() { return f.params.direction === 'horizontal'; },
            isVertical() { return f.params.direction === 'vertical'; },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23; },
            allowSlideNext: f.params.allowSlideNext,
            allowSlidePrev: f.params.allowSlidePrev,
            touchEventsData: {
              isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: f.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null,
            },
            allowClick: !0,
            allowTouchMove: f.params.allowTouchMove,
            touches: {
              startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0,
            },
            imagesToLoad: [],
            imagesLoaded: 0,
          }), f.emit('_swiper'), f.params.init && f.init(), f;
        } return (function (e, t, a) { return t && r(e.prototype, t), a && r(e, a), Object.defineProperty(e, 'prototype', { writable: !1 }), e; }(e, [{
          key: 'getDirectionLabel',
          value(e) {
            return this.isHorizontal() ? e : {
              width: 'height', 'margin-top': 'margin-left', 'margin-bottom ': 'margin-right', 'margin-left': 'margin-top', 'margin-right': 'margin-bottom', 'padding-left': 'padding-top', 'padding-right': 'padding-bottom', marginRight: 'marginBottom',
            }[e];
          },
        }, { key: 'getSlideIndex', value(e) { const t = this.slidesEl; const a = this.params; const r = k(T(t, '.'.concat(a.slideClass, ', swiper-slide'))[0]); return k(e) - r; } }, { key: 'getSlideIndexByData', value(e) { return this.getSlideIndex(this.slides.filter(((t) => 1 * t.getAttribute('data-swiper-slide-index') === e))[0]); } }, { key: 'recalcSlides', value() { const e = this.slidesEl; const t = this.params; this.slides = T(e, '.'.concat(t.slideClass, ', swiper-slide')); } }, { key: 'enable', value() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit('enable')); } }, { key: 'disable', value() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit('disable')); } }, { key: 'setProgress', value(e, t) { const a = this; e = Math.min(Math.max(e, 0), 1); const r = a.minTranslate(); const i = (a.maxTranslate() - r) * e + r; a.translateTo(i, void 0 === t ? 0 : t), a.updateActiveIndex(), a.updateSlidesClasses(); } }, { key: 'emitContainerClasses', value() { const e = this; if (e.params._emitClasses && e.el) { const t = e.el.className.split(' ').filter(((t) => t.indexOf('swiper') === 0 || t.indexOf(e.params.containerModifierClass) === 0)); e.emit('_containerClasses', t.join(' ')); } } }, { key: 'getSlideClasses', value(e) { const t = this; return t.destroyed ? '' : e.className.split(' ').filter(((e) => e.indexOf('swiper-slide') === 0 || e.indexOf(t.params.slideClass) === 0)).join(' '); } }, { key: 'emitSlidesClasses', value() { const e = this; if (e.params._emitClasses && e.el) { const t = []; e.slides.forEach(((a) => { const r = e.getSlideClasses(a); t.push({ slideEl: a, classNames: r }), e.emit('_slideClass', a, r); })), e.emit('_slideClasses', t); } } }, { key: 'slidesPerViewDynamic', value(e, t) { void 0 === e && (e = 'current'), void 0 === t && (t = !1); const a = this.params; const r = this.slides; const i = this.slidesGrid; const s = this.slidesSizesGrid; const n = this.size; const o = this.activeIndex; let l = 1; if (typeof a.slidesPerView === 'number') return a.slidesPerView; if (a.centeredSlides) { for (var d, c = r[o] ? Math.ceil(r[o].swiperSlideSize) : 0, u = o + 1; u < r.length; u += 1)r[u] && !d && (l += 1, (c += Math.ceil(r[u].swiperSlideSize)) > n && (d = !0)); for (let p = o - 1; p >= 0; p -= 1)r[p] && !d && (l += 1, (c += r[p].swiperSlideSize) > n && (d = !0)); } else if (e === 'current') for (let f = o + 1; f < r.length; f += 1)(t ? i[f] + s[f] - i[o] < n : i[f] - i[o] < n) && (l += 1); else for (let m = o - 1; m >= 0; m -= 1)i[o] - i[m] < n && (l += 1); return l; } }, { key: 'update', value() { const e = this; if (e && !e.destroyed) { let t; const a = e.snapGrid; const r = e.params; if (r.breakpoints && e.setBreakpoint(), o(e.el.querySelectorAll('[loading="lazy"]')).forEach(((t) => { t.complete && R(e, t); })), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), r.freeMode && r.freeMode.enabled && !r.cssMode)s(), r.autoHeight && e.updateAutoHeight(); else { if ((r.slidesPerView === 'auto' || r.slidesPerView > 1) && e.isEnd && !r.centeredSlides) { const i = e.virtual && r.virtual.enabled ? e.virtual.slides : e.slides; t = e.slideTo(i.length - 1, 0, !1, !0); } else t = e.slideTo(e.activeIndex, 0, !1, !0); t || s(); }r.watchOverflow && a !== e.snapGrid && e.checkOverflow(), e.emit('update'); } function s() { const t = e.rtlTranslate ? -1 * e.translate : e.translate; const a = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(a), e.updateActiveIndex(), e.updateSlidesClasses(); } } }, { key: 'changeDirection', value(e, t) { void 0 === t && (t = !0); const a = this; const r = a.params.direction; return e || (e = r === 'horizontal' ? 'vertical' : 'horizontal'), e === r || e !== 'horizontal' && e !== 'vertical' || (a.el.classList.remove(''.concat(a.params.containerModifierClass).concat(r)), a.el.classList.add(''.concat(a.params.containerModifierClass).concat(e)), a.emitContainerClasses(), a.params.direction = e, a.slides.forEach(((t) => { e === 'vertical' ? t.style.width = '' : t.style.height = ''; })), a.emit('changeDirection'), t && a.update()), a; } }, { key: 'changeLanguageDirection', value(e) { const t = this; t.rtl && e === 'rtl' || !t.rtl && e === 'ltr' || (t.rtl = e === 'rtl', t.rtlTranslate = t.params.direction === 'horizontal' && t.rtl, t.rtl ? (t.el.classList.add(''.concat(t.params.containerModifierClass, 'rtl')), t.el.dir = 'rtl') : (t.el.classList.remove(''.concat(t.params.containerModifierClass, 'rtl')), t.el.dir = 'ltr'), t.update()); } }, {
          key: 'mount',
          value(e) {
            const t = this; if (t.mounted) return !0; let a = e || t.params.el; if (typeof a === 'string' && (a = document.querySelector(a)), !a) return !1; a.swiper = t, a.parentNode && a.parentNode.host && a.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0); const r = function () { return '.'.concat((t.params.wrapperClass || '').trim().split(' ').join('.')); }; let i = a && a.shadowRoot && a.shadowRoot.querySelector ? a.shadowRoot.querySelector(r()) : T(a, r())[0]; return !i && t.params.createElements && (i = C('div', t.params.wrapperClass), a.append(i), T(a, '.'.concat(t.params.slideClass)).forEach(((e) => { i.append(e); }))), Object.assign(t, {
              el: a, wrapperEl: i, slidesEl: t.isElement && !a.parentNode.host.slideSlots ? a.parentNode.host : i, hostEl: t.isElement ? a.parentNode.host : a, mounted: !0, rtl: a.dir.toLowerCase() === 'rtl' || L(a, 'direction') === 'rtl', rtlTranslate: t.params.direction === 'horizontal' && (a.dir.toLowerCase() === 'rtl' || L(a, 'direction') === 'rtl'), wrongRTL: L(i, 'display') === '-webkit-box',
            }), !0;
          },
        }, { key: 'init', value(e) { const t = this; if (t.initialized) return t; if (!1 === t.mount(e)) return t; t.emit('beforeInit'), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(); const a = o(t.el.querySelectorAll('[loading="lazy"]')); return t.isElement && a.push.apply(a, o(t.hostEl.querySelectorAll('[loading="lazy"]'))), a.forEach(((e) => { e.complete ? R(t, e) : e.addEventListener('load', ((e) => { R(t, e.target); })); })), F(t), t.initialized = !0, F(t), t.emit('init'), t.emit('afterInit'), t; } }, { key: 'destroy', value(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const a = this; const r = a.params; const i = a.el; const s = a.wrapperEl; const n = a.slides; return void 0 === a.params || a.destroyed || (a.emit('beforeDestroy'), a.initialized = !1, a.detachEvents(), r.loop && a.loopDestroy(), t && (a.removeClasses(), i && typeof i !== 'string' && i.removeAttribute('style'), s && s.removeAttribute('style'), n && n.length && n.forEach(((e) => { e.classList.remove(r.slideVisibleClass, r.slideFullyVisibleClass, r.slideActiveClass, r.slideNextClass, r.slidePrevClass), e.removeAttribute('style'), e.removeAttribute('data-swiper-slide-index'); }))), a.emit('destroy'), Object.keys(a.eventsListeners).forEach(((e) => { a.off(e); })), !1 !== e && (a.el && typeof a.el !== 'string' && (a.el.swiper = null), (function (e) { const t = e; Object.keys(t).forEach(((e) => { try { t[e] = null; } catch (e) {} try { delete t[e]; } catch (e) {} })); }(a))), a.destroyed = !0), null; } }], [{ key: 'extendDefaults', value(e) { y(de, e); } }, { key: 'extendedDefaults', get() { return de; } }, { key: 'defaults', get() { return ne; } }, { key: 'installModule', value(t) { e.prototype.__modules__ || (e.prototype.__modules__ = []); const a = e.prototype.__modules__; typeof t === 'function' && a.indexOf(t) < 0 && a.push(t); } }, { key: 'use', value(t) { return Array.isArray(t) ? (t.forEach(((t) => e.installModule(t))), e) : (e.installModule(t), e); } }]));
      }()); function ue(e, t, a, r) { return e.params.createElements && Object.keys(r).forEach(((i) => { if (!a[i] && !0 === a.auto) { let s = T(e.el, '.'.concat(r[i]))[0]; s || ((s = C('div', r[i])).className = r[i], e.el.append(s)), a[i] = s, t[i] = s; } })), a; } function pe(e) { return void 0 === e && (e = ''), '.'.concat(e.trim().replace(/([\.:!+\/])/g, '\\$1').replace(/ /g, '.')); } function fe(e) { const t = this; const a = t.params; const r = t.slidesEl; a.loop && t.loopDestroy(); const i = function (e) { if (typeof e === 'string') { const t = document.createElement('div'); t.innerHTML = e, r.append(t.children[0]), t.innerHTML = ''; } else r.append(e); }; if (p(e) == 'object' && 'length' in e) for (let s = 0; s < e.length; s += 1)e[s] && i(e[s]); else i(e); t.recalcSlides(), a.loop && t.loopCreate(), a.observer && !t.isElement || t.update(); } function me(e) { const t = this; const a = t.params; const r = t.activeIndex; const i = t.slidesEl; a.loop && t.loopDestroy(); let s = r + 1; const n = function (e) { if (typeof e === 'string') { const t = document.createElement('div'); t.innerHTML = e, i.prepend(t.children[0]), t.innerHTML = ''; } else i.prepend(e); }; if (p(e) == 'object' && 'length' in e) { for (let o = 0; o < e.length; o += 1)e[o] && n(e[o]); s = r + e.length; } else n(e); t.recalcSlides(), a.loop && t.loopCreate(), a.observer && !t.isElement || t.update(), t.slideTo(s, 0, !1); } function ve(e, t) { const a = this; const r = a.params; const i = a.activeIndex; const s = a.slidesEl; let n = i; r.loop && (n -= a.loopedSlides, a.loopDestroy(), a.recalcSlides()); const o = a.slides.length; if (e <= 0)a.prependSlide(t); else if (e >= o)a.appendSlide(t); else { for (var l = n > e ? n + 1 : n, d = [], c = o - 1; c >= e; c -= 1) { const u = a.slides[c]; u.remove(), d.unshift(u); } if (p(t) == 'object' && 'length' in t) { for (let f = 0; f < t.length; f += 1)t[f] && s.append(t[f]); l = n > e ? n + t.length : n; } else s.append(t); for (let m = 0; m < d.length; m += 1)s.append(d[m]); a.recalcSlides(), r.loop && a.loopCreate(), r.observer && !a.isElement || a.update(), r.loop ? a.slideTo(l + a.loopedSlides, 0, !1) : a.slideTo(l, 0, !1); } } function he(e) { const t = this; const a = t.params; let r = t.activeIndex; a.loop && (r -= t.loopedSlides, t.loopDestroy()); let i; let s = r; if (p(e) == 'object' && 'length' in e) { for (let n = 0; n < e.length; n += 1)i = e[n], t.slides[i] && t.slides[i].remove(), i < s && (s -= 1); s = Math.max(s, 0); } else i = e, t.slides[i] && t.slides[i].remove(), i < s && (s -= 1), s = Math.max(s, 0); t.recalcSlides(), a.loop && t.loopCreate(), a.observer && !t.isElement || t.update(), a.loop ? t.slideTo(s + t.loopedSlides, 0, !1) : t.slideTo(s, 0, !1); } function ge() { for (var e = [], t = 0; t < this.slides.length; t += 1)e.push(t); this.removeSlide(e); } function we(e) { let t; const a = e.effect; const r = e.swiper; const i = e.on; const s = e.setTranslate; const n = e.setTransition; const o = e.overwriteParams; const l = e.perspective; const d = e.recreateShadows; const c = e.getEffectParams; i('beforeInit', (() => { if (r.params.effect === a) { r.classNames.push(''.concat(r.params.containerModifierClass).concat(a)), l && l() && r.classNames.push(''.concat(r.params.containerModifierClass, '3d')); const e = o ? o() : {}; Object.assign(r.params, e), Object.assign(r.originalParams, e); } })), i('setTranslate', (() => { r.params.effect === a && s(); })), i('setTransition', ((e, t) => { r.params.effect === a && n(t); })), i('transitionEnd', (() => { if (r.params.effect === a && d) { if (!c || !c().slideShadows) return; r.slides.forEach(((e) => { e.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(((e) => e.remove())); })), d(); } })), i('virtualUpdate', (() => { r.params.effect === a && (r.slides.length || (t = !0), requestAnimationFrame((() => { t && r.slides && r.slides.length && (s(), t = !1); }))); })); } function be(e, t) { const a = S(t); return a !== t && (a.style.backfaceVisibility = 'hidden', a.style['-webkit-backface-visibility'] = 'hidden'), a; } function ye(e) { const t = e.swiper; const a = e.duration; const r = e.transformElements; const i = e.allSlides; const s = t.activeIndex; if (t.params.virtualTranslate && a !== 0) { let n; let o = !1; n = i ? r : r.filter(((e) => { const a = e.classList.contains('swiper-slide-transform') ? (function (e) { return e.parentElement ? e.parentElement : t.slides.filter(((t) => t.shadowRoot && t.shadowRoot === e.parentNode))[0]; }(e)) : e; return t.getSlideIndex(a) === s; })), n.forEach(((e) => { A(e, (() => { if (!o && t && !t.destroyed) { o = !0, t.animating = !1; const e = new window.CustomEvent('transitionend', { bubbles: !0, cancelable: !0 }); t.wrapperEl.dispatchEvent(e); } })); })); } } function Ee(e, t, a) { const r = 'swiper-slide-shadow'.concat(a ? '-'.concat(a) : '').concat(e ? ' swiper-slide-shadow-'.concat(e) : ''); const i = S(t); let s = i.querySelector('.'.concat(r.split(' ').join('.'))); return s || (s = C('div', r.split(' ')), i.append(s)), s; }Object.keys(le).forEach(((e) => { Object.keys(le[e]).forEach(((t) => { ce.prototype[t] = le[e][t]; })); })), ce.use([function (e) { const t = e.swiper; const a = e.on; const r = e.emit; const i = m(); let s = null; let n = null; const o = function () { t && !t.destroyed && t.initialized && (r('beforeResize'), r('resize')); }; const l = function () { t && !t.destroyed && t.initialized && r('orientationchange'); }; a('init', (() => { t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (s = new ResizeObserver(((e) => { n = i.requestAnimationFrame((() => { const a = t.width; const r = t.height; let i = a; let s = r; e.forEach(((e) => { const a = e.contentBoxSize; const r = e.contentRect; const n = e.target; n && n !== t.el || (i = r ? r.width : (a[0] || a).inlineSize, s = r ? r.height : (a[0] || a).blockSize); })), i === a && s === r || o(); })); })), s.observe(t.el)) : (i.addEventListener('resize', o), i.addEventListener('orientationchange', l)); })), a('destroy', (() => { n && i.cancelAnimationFrame(n), s && s.unobserve && t.el && (s.unobserve(t.el), s = null), i.removeEventListener('resize', o), i.removeEventListener('orientationchange', l); })); }, function (e) { const t = e.swiper; const a = e.extendParams; const r = e.on; const i = e.emit; const s = []; const n = m(); const o = function (e, a) { void 0 === a && (a = {}); const r = new (n.MutationObserver || n.WebkitMutationObserver)(((e) => { if (!t.__preventObserver__) if (e.length !== 1) { const a = function () { i('observerUpdate', e[0]); }; n.requestAnimationFrame ? n.requestAnimationFrame(a) : n.setTimeout(a, 0); } else i('observerUpdate', e[0]); })); r.observe(e, { attributes: void 0 === a.attributes || a.attributes, childList: t.isElement || (void 0 === a.childList || a).childList, characterData: void 0 === a.characterData || a.characterData }), s.push(r); }; a({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), r('init', (() => { if (t.params.observer) { if (t.params.observeParents) for (let e = I(t.hostEl), a = 0; a < e.length; a += 1)o(e[a]); o(t.hostEl, { childList: t.params.observeSlideChildren }), o(t.wrapperEl, { attributes: !1 }); } })), r('destroy', (() => { s.forEach(((e) => { e.disconnect(); })), s.splice(0, s.length); })); }]); const xe = [function (e) {
        let t; const a = e.swiper; const r = e.extendParams; const s = e.on; const n = e.emit; r({
          virtual: {
            enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0,
          },
        }); const l = i(); a.virtual = {
          cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [],
        }; const d = l.createElement('div'); function c(e, t) { let r; const i = a.params.virtual; return i.cache && a.virtual.cache[t] ? a.virtual.cache[t] : (i.renderSlide ? typeof (r = i.renderSlide.call(a, e, t)) === 'string' && (d.innerHTML = r, r = d.children[0]) : r = a.isElement ? C('swiper-slide') : C('div', a.params.slideClass), r.setAttribute('data-swiper-slide-index', t), i.renderSlide || (r.innerHTML = e), i.cache && (a.virtual.cache[t] = r), r); } function u(e, t) {
          const r = a.params; const i = r.slidesPerView; const s = r.slidesPerGroup; const o = r.centeredSlides; const l = r.loop; const d = r.initialSlide; if (!(t && !l && d > 0)) {
            const u = a.params.virtual; const p = u.addSlidesBefore; const f = u.addSlidesAfter; const m = a.virtual; const v = m.from; const h = m.to; const g = m.slides; const w = m.slidesGrid; const b = m.offset; a.params.cssMode || a.updateActiveIndex(); let y; let E; let x; const S = a.activeIndex || 0; y = a.rtlTranslate ? 'right' : a.isHorizontal() ? 'left' : 'top', o ? (E = Math.floor(i / 2) + s + f, x = Math.floor(i / 2) + s + p) : (E = i + (s - 1) + f, x = (l ? i : s) + p); let M = S - x; let C = S + E; l || (M = Math.max(M, 0), C = Math.min(C, g.length - 1)); let P = (a.slidesGrid[M] || 0) - (a.slidesGrid[0] || 0); if (l && S >= x ? (M -= x, o || (P += a.slidesGrid[0])) : l && S < x && (M = -x, o && (P += a.slidesGrid[0])), Object.assign(a.virtual, {
              from: M, to: C, offset: P, slidesGrid: a.slidesGrid, slidesBefore: x, slidesAfter: E,
            }), v === M && h === C && !e) return a.slidesGrid !== w && P !== b && a.slides.forEach(((e) => { e.style[y] = `${P - Math.abs(a.cssOverflowAdjustment())}px`; })), a.updateProgress(), void n('virtualUpdate'); if (a.params.virtual.renderExternal) {
              return a.params.virtual.renderExternal.call(a, {
                offset: P, from: M, to: C, slides: (function () { for (var e = [], t = M; t <= C; t += 1)e.push(g[t]); return e; }()),
              }), void (a.params.virtual.renderExternalUpdate ? X() : n('virtualUpdate'));
            } const L = []; const k = []; const I = function (e) { let t = e; return e < 0 ? t = g.length + e : t >= g.length && (t -= g.length), t; }; if (e)a.slides.filter(((e) => e.matches('.'.concat(a.params.slideClass, ', swiper-slide')))).forEach(((e) => { e.remove(); })); else for (var A = function () { if (z < M || z > C) { const e = I(z); a.slides.filter(((t) => t.matches('.'.concat(a.params.slideClass, '[data-swiper-slide-index="').concat(e, '"], swiper-slide[data-swiper-slide-index="').concat(e, '"]')))).forEach(((e) => { e.remove(); })); } }, z = v; z <= h; z += 1)A(); for (let O = l ? -g.length : 0, D = l ? 2 * g.length : g.length, G = O; G < D; G += 1) if (G >= M && G <= C) { const H = I(G); void 0 === h || e ? k.push(H) : (G > h && k.push(H), G < v && L.push(H)); } if (k.forEach(((e) => { a.slidesEl.append(c(g[e], e)); })), l) for (let B = L.length - 1; B >= 0; B -= 1) { const N = L[B]; a.slidesEl.prepend(c(g[N], N)); } else L.sort(((e, t) => t - e)), L.forEach(((e) => { a.slidesEl.prepend(c(g[e], e)); })); T(a.slidesEl, '.swiper-slide, swiper-slide').forEach(((e) => { e.style[y] = `${P - Math.abs(a.cssOverflowAdjustment())}px`; })), X();
          } function X() { a.updateSlides(), a.updateProgress(), a.updateSlidesClasses(), n('virtualUpdate'); }
        }s('beforeInit', (() => { if (a.params.virtual.enabled) { let e; if (void 0 === a.passedParams.virtual.slides) { const t = o(a.slidesEl.children).filter(((e) => e.matches('.'.concat(a.params.slideClass, ', swiper-slide')))); t && t.length && (a.virtual.slides = o(t), e = !0, t.forEach(((e, t) => { e.setAttribute('data-swiper-slide-index', t), a.virtual.cache[t] = e, e.remove(); }))); }e || (a.virtual.slides = a.params.virtual.slides), a.classNames.push(''.concat(a.params.containerModifierClass, 'virtual')), a.params.watchSlidesProgress = !0, a.originalParams.watchSlidesProgress = !0, u(!1, !0); } })), s('setTranslate', (() => { a.params.virtual.enabled && (a.params.cssMode && !a._immediateVirtual ? (clearTimeout(t), t = setTimeout((() => { u(); }), 100)) : u()); })), s('init update resize', (() => { a.params.virtual.enabled && a.params.cssMode && E(a.wrapperEl, '--swiper-virtual-size', ''.concat(a.virtualSize, 'px')); })), Object.assign(a.virtual, {
          appendSlide(e) { if (p(e) == 'object' && 'length' in e) for (let t = 0; t < e.length; t += 1)e[t] && a.virtual.slides.push(e[t]); else a.virtual.slides.push(e); u(!0); }, prependSlide(e) { const t = a.activeIndex; let r = t + 1; let i = 1; if (Array.isArray(e)) { for (let s = 0; s < e.length; s += 1)e[s] && a.virtual.slides.unshift(e[s]); r = t + e.length, i = e.length; } else a.virtual.slides.unshift(e); if (a.params.virtual.cache) { const n = a.virtual.cache; const o = {}; Object.keys(n).forEach(((e) => { const t = n[e]; const a = t.getAttribute('data-swiper-slide-index'); a && t.setAttribute('data-swiper-slide-index', parseInt(a, 10) + i), o[parseInt(e, 10) + i] = t; })), a.virtual.cache = o; }u(!0), a.slideTo(r, 0); }, removeSlide(e) { if (e != null) { let t = a.activeIndex; if (Array.isArray(e)) for (let r = e.length - 1; r >= 0; r -= 1)a.params.virtual.cache && (delete a.virtual.cache[e[r]], Object.keys(a.virtual.cache).forEach(((t) => { t > e && (a.virtual.cache[t - 1] = a.virtual.cache[t], a.virtual.cache[t - 1].setAttribute('data-swiper-slide-index', t - 1), delete a.virtual.cache[t]); }))), a.virtual.slides.splice(e[r], 1), e[r] < t && (t -= 1), t = Math.max(t, 0); else a.params.virtual.cache && (delete a.virtual.cache[e], Object.keys(a.virtual.cache).forEach(((t) => { t > e && (a.virtual.cache[t - 1] = a.virtual.cache[t], a.virtual.cache[t - 1].setAttribute('data-swiper-slide-index', t - 1), delete a.virtual.cache[t]); }))), a.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0); u(!0), a.slideTo(t, 0); } }, removeAllSlides() { a.virtual.slides = [], a.params.virtual.cache && (a.virtual.cache = {}), u(!0), a.slideTo(0, 0); }, update: u,
        });
      }, function (e) { const t = e.swiper; const a = e.extendParams; const r = e.on; const s = e.emit; const n = i(); const o = m(); function l(e) { if (t.enabled) { const a = t.rtlTranslate; let r = e; r.originalEvent && (r = r.originalEvent); const i = r.keyCode || r.charCode; const l = t.params.keyboard.pageUpDown; const d = l && i === 33; const c = l && i === 34; const u = i === 37; const p = i === 39; const f = i === 38; const m = i === 40; if (!t.allowSlideNext && (t.isHorizontal() && p || t.isVertical() && m || c)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && u || t.isVertical() && f || d)) return !1; if (!(r.shiftKey || r.altKey || r.ctrlKey || r.metaKey || n.activeElement && n.activeElement.nodeName && (n.activeElement.nodeName.toLowerCase() === 'input' || n.activeElement.nodeName.toLowerCase() === 'textarea'))) { if (t.params.keyboard.onlyInViewport && (d || c || u || p || f || m)) { let v = !1; if (I(t.el, '.'.concat(t.params.slideClass, ', swiper-slide')).length > 0 && I(t.el, '.'.concat(t.params.slideActiveClass)).length === 0) return; const h = t.el; const g = h.clientWidth; const w = h.clientHeight; const b = o.innerWidth; const y = o.innerHeight; const E = P(h); a && (E.left -= h.scrollLeft); for (let x = [[E.left, E.top], [E.left + g, E.top], [E.left, E.top + w], [E.left + g, E.top + w]], S = 0; S < x.length; S += 1) { const T = x[S]; if (T[0] >= 0 && T[0] <= b && T[1] >= 0 && T[1] <= y) { if (T[0] === 0 && T[1] === 0) continue; v = !0; } } if (!v) return; }t.isHorizontal() ? ((d || c || u || p) && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), ((c || p) && !a || (d || u) && a) && t.slideNext(), ((d || u) && !a || (c || p) && a) && t.slidePrev()) : ((d || c || f || m) && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), (c || m) && t.slideNext(), (d || f) && t.slidePrev()), s('keyPress', i); } } } function d() { t.keyboard.enabled || (n.addEventListener('keydown', l), t.keyboard.enabled = !0); } function c() { t.keyboard.enabled && (n.removeEventListener('keydown', l), t.keyboard.enabled = !1); }t.keyboard = { enabled: !1 }, a({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), r('init', (() => { t.params.keyboard.enabled && d(); })), r('destroy', (() => { t.keyboard.enabled && c(); })), Object.assign(t.keyboard, { enable: d, disable: c }); }, function (e) {
        let t; const a = e.swiper; const r = e.extendParams; const i = e.on; const s = e.emit; const n = m(); r({
          mousewheel: {
            enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: 'container', thresholdDelta: null, thresholdTime: null, noMousewheelClass: 'swiper-no-mousewheel',
          },
        }), a.mousewheel = { enabled: !1 }; let o; let l = g(); const d = []; function c() { a.enabled && (a.mouseEntered = !0); } function u() { a.enabled && (a.mouseEntered = !1); } function p(e) { return !(a.params.mousewheel.thresholdDelta && e.delta < a.params.mousewheel.thresholdDelta || a.params.mousewheel.thresholdTime && g() - l < a.params.mousewheel.thresholdTime || !(e.delta >= 6 && g() - l < 60) && (e.direction < 0 ? a.isEnd && !a.params.loop || a.animating || (a.slideNext(), s('scroll', e.raw)) : a.isBeginning && !a.params.loop || a.animating || (a.slidePrev(), s('scroll', e.raw)), l = (new n.Date()).getTime(), 1)); } function f(e) {
          let r = e; if (a.enabled && !e.target.closest('.'.concat(a.params.mousewheel.noMousewheelClass))) {
            const i = a.params.mousewheel; a.params.cssMode && r.preventDefault(); let n = a.el; a.params.mousewheel.eventsTarget !== 'container' && (n = document.querySelector(a.params.mousewheel.eventsTarget)); const l = n && n.contains(r.target); if (!a.mouseEntered && !l && !i.releaseOnEdges) return !0; r.originalEvent && (r = r.originalEvent); let c = 0; const u = a.rtlTranslate ? -1 : 1; const f = (function (e) {
              let t = 0; let a = 0; let r = 0; let i = 0; return 'detail' in e && (a = e.detail), 'wheelDelta' in e && (a = -e.wheelDelta / 120), 'wheelDeltaY' in e && (a = -e.wheelDeltaY / 120), 'wheelDeltaX' in e && (t = -e.wheelDeltaX / 120), 'axis' in e && e.axis === e.HORIZONTAL_AXIS && (t = a, a = 0), r = 10 * t, i = 10 * a, 'deltaY' in e && (i = e.deltaY), 'deltaX' in e && (r = e.deltaX), e.shiftKey && !r && (r = i, i = 0), (r || i) && e.deltaMode && (e.deltaMode === 1 ? (r *= 40, i *= 40) : (r *= 800, i *= 800)), r && !t && (t = r < 1 ? -1 : 1), i && !a && (a = i < 1 ? -1 : 1), {
                spinX: t, spinY: a, pixelX: r, pixelY: i,
              };
            }(r)); if (i.forceToAxis) if (a.isHorizontal()) { if (!(Math.abs(f.pixelX) > Math.abs(f.pixelY))) return !0; c = -f.pixelX * u; } else { if (!(Math.abs(f.pixelY) > Math.abs(f.pixelX))) return !0; c = -f.pixelY; } else c = Math.abs(f.pixelX) > Math.abs(f.pixelY) ? -f.pixelX * u : -f.pixelY; if (c === 0) return !0; i.invert && (c = -c); let m = a.getTranslate() + c * i.sensitivity; if (m >= a.minTranslate() && (m = a.minTranslate()), m <= a.maxTranslate() && (m = a.maxTranslate()), (!!a.params.loop || !(m === a.minTranslate() || m === a.maxTranslate())) && a.params.nested && r.stopPropagation(), a.params.freeMode && a.params.freeMode.enabled) { const v = { time: g(), delta: Math.abs(c), direction: Math.sign(c) }; const w = o && v.time < o.time + 500 && v.delta <= o.delta && v.direction === o.direction; if (!w) { o = void 0; let b = a.getTranslate() + c * i.sensitivity; const y = a.isBeginning; const E = a.isEnd; if (b >= a.minTranslate() && (b = a.minTranslate()), b <= a.maxTranslate() && (b = a.maxTranslate()), a.setTransition(0), a.setTranslate(b), a.updateProgress(), a.updateActiveIndex(), a.updateSlidesClasses(), (!y && a.isBeginning || !E && a.isEnd) && a.updateSlidesClasses(), a.params.loop && a.loopFix({ direction: v.direction < 0 ? 'next' : 'prev', byMousewheel: !0 }), a.params.freeMode.sticky) { clearTimeout(t), t = void 0, d.length >= 15 && d.shift(); const x = d.length ? d[d.length - 1] : void 0; const S = d[0]; if (d.push(v), x && (v.delta > x.delta || v.direction !== x.direction))d.splice(0); else if (d.length >= 15 && v.time - S.time < 500 && S.delta - v.delta >= 1 && v.delta <= 6) { const T = c > 0 ? 0.8 : 0.2; o = v, d.splice(0), t = h((() => { !a.destroyed && a.params && a.slideToClosest(a.params.speed, !0, void 0, T); }), 0); }t || (t = h((() => { !a.destroyed && a.params && (o = v, d.splice(0), a.slideToClosest(a.params.speed, !0, void 0, 0.5)); }), 500)); } if (w || s('scroll', r), a.params.autoplay && a.params.autoplayDisableOnInteraction && a.autoplay.stop(), i.releaseOnEdges && (b === a.minTranslate() || b === a.maxTranslate())) return !0; } } else {
              const M = {
                time: g(), delta: Math.abs(c), direction: Math.sign(c), raw: e,
              }; d.length >= 2 && d.shift(); const C = d.length ? d[d.length - 1] : void 0; if (d.push(M), C ? (M.direction !== C.direction || M.delta > C.delta || M.time > C.time + 150) && p(M) : p(M), (function (e) { const t = a.params.mousewheel; if (e.direction < 0) { if (a.isEnd && !a.params.loop && t.releaseOnEdges) return !0; } else if (a.isBeginning && !a.params.loop && t.releaseOnEdges) return !0; return !1; }(M))) return !0;
            } return r.preventDefault ? r.preventDefault() : r.returnValue = !1, !1;
          }
        } function v(e) { let t = a.el; a.params.mousewheel.eventsTarget !== 'container' && (t = document.querySelector(a.params.mousewheel.eventsTarget)), t[e]('mouseenter', c), t[e]('mouseleave', u), t[e]('wheel', f); } function w() { return a.params.cssMode ? (a.wrapperEl.removeEventListener('wheel', f), !0) : !a.mousewheel.enabled && (v('addEventListener'), a.mousewheel.enabled = !0, !0); } function b() { return a.params.cssMode ? (a.wrapperEl.addEventListener(event, f), !0) : !!a.mousewheel.enabled && (v('removeEventListener'), a.mousewheel.enabled = !1, !0); }i('init', (() => { !a.params.mousewheel.enabled && a.params.cssMode && b(), a.params.mousewheel.enabled && w(); })), i('destroy', (() => { a.params.cssMode && w(), a.mousewheel.enabled && b(); })), Object.assign(a.mousewheel, { enable: w, disable: b });
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; const i = e.emit; function s(e) { let a; return e && typeof e === 'string' && t.isElement && (a = t.el.querySelector(e)) ? a : (e && (typeof e === 'string' && (a = o(document.querySelectorAll(e))), t.params.uniqueNavElements && typeof e === 'string' && a && a.length > 1 && t.el.querySelectorAll(e).length === 1 ? a = t.el.querySelector(e) : a && a.length === 1 && (a = a[0])), e && !a ? e : a); } function n(e, a) { const r = t.params.navigation; (e = O(e)).forEach(((e) => { let i; e && ((i = e.classList)[a ? 'add' : 'remove'].apply(i, o(r.disabledClass.split(' '))), e.tagName === 'BUTTON' && (e.disabled = a), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? 'add' : 'remove'](r.lockClass)); })); } function l() { const e = t.navigation; const a = e.nextEl; const r = e.prevEl; if (t.params.loop) return n(r, !1), void n(a, !1); n(r, t.isBeginning && !t.params.rewind), n(a, t.isEnd && !t.params.rewind); } function d(e) { e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), i('navigationPrev')); } function c(e) { e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), i('navigationNext')); } function u() { const e = t.params.navigation; if (t.params.navigation = ue(t, t.originalParams.navigation, t.params.navigation, { nextEl: 'swiper-button-next', prevEl: 'swiper-button-prev' }), e.nextEl || e.prevEl) { let a = s(e.nextEl); let r = s(e.prevEl); Object.assign(t.navigation, { nextEl: a, prevEl: r }), a = O(a), r = O(r); const i = function (a, r) { let i; a && a.addEventListener('click', r === 'next' ? c : d), !t.enabled && a && (i = a.classList).add.apply(i, o(e.lockClass.split(' '))); }; a.forEach(((e) => i(e, 'next'))), r.forEach(((e) => i(e, 'prev'))); } } function p() { const e = t.navigation; let a = e.nextEl; let r = e.prevEl; a = O(a), r = O(r); const i = function (e, a) { let r; e.removeEventListener('click', a === 'next' ? c : d), (r = e.classList).remove.apply(r, o(t.params.navigation.disabledClass.split(' '))); }; a.forEach(((e) => i(e, 'next'))), r.forEach(((e) => i(e, 'prev'))); }a({
          navigation: {
            nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: 'swiper-button-disabled', hiddenClass: 'swiper-button-hidden', lockClass: 'swiper-button-lock', navigationDisabledClass: 'swiper-navigation-disabled',
          },
        }), t.navigation = { nextEl: null, prevEl: null }, r('init', (() => { !1 === t.params.navigation.enabled ? f() : (u(), l()); })), r('toEdge fromEdge lock unlock', (() => { l(); })), r('destroy', (() => { p(); })), r('enable disable', (() => { const e = t.navigation; let a = e.nextEl; let r = e.prevEl; a = O(a), r = O(r), t.enabled ? l() : [].concat(o(a), o(r)).filter(((e) => !!e)).forEach(((e) => e.classList.add(t.params.navigation.lockClass))); })), r('click', ((e, a) => { const r = t.navigation; let s = r.nextEl; let n = r.prevEl; s = O(s), n = O(n); const l = a.target; let d = n.includes(l) || s.includes(l); if (t.isElement && !d) { const c = a.path || a.composedPath && a.composedPath(); c && (d = c.find(((e) => s.includes(e) || n.includes(e)))); } if (t.params.navigation.hideOnClick && !d) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === l || t.pagination.el.contains(l))) return; let u; s.length ? u = s[0].classList.contains(t.params.navigation.hiddenClass) : n.length && (u = n[0].classList.contains(t.params.navigation.hiddenClass)), i(!0 === u ? 'navigationShow' : 'navigationHide'), [].concat(o(s), o(n)).filter(((e) => !!e)).forEach(((e) => e.classList.toggle(t.params.navigation.hiddenClass))); } })); var f = function () { let e; (e = t.el.classList).add.apply(e, o(t.params.navigation.navigationDisabledClass.split(' '))), p(); }; Object.assign(t.navigation, {
          enable() { let e; (e = t.el.classList).remove.apply(e, o(t.params.navigation.navigationDisabledClass.split(' '))), u(), l(); }, disable: f, update: l, init: u, destroy: p,
        });
      }, function (e) {
        let t; const a = e.swiper; const r = e.extendParams; const i = e.on; const s = e.emit; const n = 'swiper-pagination'; r({
          pagination: {
            el: null, bulletElement: 'span', clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: 'bullets', dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent(e) { return e; }, formatFractionTotal(e) { return e; }, bulletClass: ''.concat(n, '-bullet'), bulletActiveClass: ''.concat(n, '-bullet-active'), modifierClass: ''.concat(n, '-'), currentClass: ''.concat(n, '-current'), totalClass: ''.concat(n, '-total'), hiddenClass: ''.concat(n, '-hidden'), progressbarFillClass: ''.concat(n, '-progressbar-fill'), progressbarOppositeClass: ''.concat(n, '-progressbar-opposite'), clickableClass: ''.concat(n, '-clickable'), lockClass: ''.concat(n, '-lock'), horizontalClass: ''.concat(n, '-horizontal'), verticalClass: ''.concat(n, '-vertical'), paginationDisabledClass: ''.concat(n, '-disabled'),
          },
        }), a.pagination = { el: null, bullets: [] }; let l = 0; function d() { return !a.params.pagination.el || !a.pagination.el || Array.isArray(a.pagination.el) && a.pagination.el.length === 0; } function c(e, t) { const r = a.params.pagination.bulletActiveClass; e && (e = e[`${t === 'prev' ? 'previous' : 'next'}ElementSibling`]) && (e.classList.add(''.concat(r, '-').concat(t)), (e = e[`${t === 'prev' ? 'previous' : 'next'}ElementSibling`]) && e.classList.add(''.concat(r, '-').concat(t, '-').concat(t))); } function u(e) { const t = e.target.closest(pe(a.params.pagination.bulletClass)); if (t) { e.preventDefault(); let r; let i; let s; const n = k(t) * a.params.slidesPerGroup; if (a.params.loop) { if (a.realIndex === n) return; const o = (r = a.realIndex, i = n, (i %= s = a.slides.length) == 1 + (r %= s) ? 'next' : i === r - 1 ? 'previous' : void 0); o === 'next' ? a.slideNext() : o === 'previous' ? a.slidePrev() : a.slideToLoop(n); } else a.slideTo(n); } } function p() { const e = a.rtl; const r = a.params.pagination; if (!d()) { let i; let n; let u = a.pagination.el; u = O(u); const p = a.virtual && a.params.virtual.enabled ? a.virtual.slides.length : a.slides.length; const f = a.params.loop ? Math.ceil(p / a.params.slidesPerGroup) : a.snapGrid.length; if (a.params.loop ? (n = a.previousRealIndex || 0, i = a.params.slidesPerGroup > 1 ? Math.floor(a.realIndex / a.params.slidesPerGroup) : a.realIndex) : void 0 !== a.snapIndex ? (i = a.snapIndex, n = a.previousSnapIndex) : (n = a.previousIndex || 0, i = a.activeIndex || 0), r.type === 'bullets' && a.pagination.bullets && a.pagination.bullets.length > 0) { let m; let v; let h; const g = a.pagination.bullets; if (r.dynamicBullets && (t = z(g[0], a.isHorizontal() ? 'width' : 'height', !0), u.forEach(((e) => { e.style[a.isHorizontal() ? 'width' : 'height'] = `${t * (r.dynamicMainBullets + 4)}px`; })), r.dynamicMainBullets > 1 && void 0 !== n && ((l += i - (n || 0)) > r.dynamicMainBullets - 1 ? l = r.dynamicMainBullets - 1 : l < 0 && (l = 0)), m = Math.max(i - l, 0), h = ((v = m + (Math.min(g.length, r.dynamicMainBullets) - 1)) + m) / 2), g.forEach(((e) => { let t; const a = o(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(((e) => ''.concat(r.bulletActiveClass).concat(e)))).map(((e) => (typeof e === 'string' && e.includes(' ') ? e.split(' ') : e))).flat(); (t = e.classList).remove.apply(t, o(a)); })), u.length > 1)g.forEach(((e) => { let t; let s; const n = k(e); n === i ? (t = e.classList).add.apply(t, o(r.bulletActiveClass.split(' '))) : a.isElement && e.setAttribute('part', 'bullet'), r.dynamicBullets && (n >= m && n <= v && (s = e.classList).add.apply(s, o(''.concat(r.bulletActiveClass, '-main').split(' '))), n === m && c(e, 'prev'), n === v && c(e, 'next')); })); else { let w; const b = g[i]; if (b && (w = b.classList).add.apply(w, o(r.bulletActiveClass.split(' '))), a.isElement && g.forEach(((e, t) => { e.setAttribute('part', t === i ? 'bullet-active' : 'bullet'); })), r.dynamicBullets) { for (var y = g[m], E = g[v], x = m; x <= v; x += 1) { var S; g[x] && (S = g[x].classList).add.apply(S, o(''.concat(r.bulletActiveClass, '-main').split(' '))); }c(y, 'prev'), c(E, 'next'); } } if (r.dynamicBullets) { const T = Math.min(g.length, r.dynamicMainBullets + 4); const M = (t * T - t) / 2 - h * t; const C = e ? 'right' : 'left'; g.forEach(((e) => { e.style[a.isHorizontal() ? C : 'top'] = ''.concat(M, 'px'); })); } }u.forEach(((e, t) => { if (r.type === 'fraction' && (e.querySelectorAll(pe(r.currentClass)).forEach(((e) => { e.textContent = r.formatFractionCurrent(i + 1); })), e.querySelectorAll(pe(r.totalClass)).forEach(((e) => { e.textContent = r.formatFractionTotal(f); }))), r.type === 'progressbar') { let n; n = r.progressbarOpposite ? a.isHorizontal() ? 'vertical' : 'horizontal' : a.isHorizontal() ? 'horizontal' : 'vertical'; const o = (i + 1) / f; let l = 1; let d = 1; n === 'horizontal' ? l = o : d = o, e.querySelectorAll(pe(r.progressbarFillClass)).forEach(((e) => { e.style.transform = 'translate3d(0,0,0) scaleX('.concat(l, ') scaleY(').concat(d, ')'), e.style.transitionDuration = ''.concat(a.params.speed, 'ms'); })); }r.type === 'custom' && r.renderCustom ? (e.innerHTML = r.renderCustom(a, i + 1, f), t === 0 && s('paginationRender', e)) : (t === 0 && s('paginationRender', e), s('paginationUpdate', e)), a.params.watchOverflow && a.enabled && e.classList[a.isLocked ? 'add' : 'remove'](r.lockClass); })); } } function f() { const e = a.params.pagination; if (!d()) { const t = a.virtual && a.params.virtual.enabled ? a.virtual.slides.length : a.grid && a.params.grid.rows > 1 ? a.slides.length / Math.ceil(a.params.grid.rows) : a.slides.length; let r = a.pagination.el; r = O(r); let i = ''; if (e.type === 'bullets') { let n = a.params.loop ? Math.ceil(t / a.params.slidesPerGroup) : a.snapGrid.length; a.params.freeMode && a.params.freeMode.enabled && n > t && (n = t); for (let l = 0; l < n; l += 1)e.renderBullet ? i += e.renderBullet.call(a, l, e.bulletClass) : i += '<'.concat(e.bulletElement, ' ').concat(a.isElement ? 'part="bullet"' : '', ' class="').concat(e.bulletClass, '"></').concat(e.bulletElement, '>'); }e.type === 'fraction' && (i = e.renderFraction ? e.renderFraction.call(a, e.currentClass, e.totalClass) : '<span class="'.concat(e.currentClass, '"></span> / <span class="').concat(e.totalClass, '"></span>')), e.type === 'progressbar' && (i = e.renderProgressbar ? e.renderProgressbar.call(a, e.progressbarFillClass) : '<span class="'.concat(e.progressbarFillClass, '"></span>')), a.pagination.bullets = [], r.forEach(((t) => { let r; e.type !== 'custom' && (t.innerHTML = i || ''), e.type === 'bullets' && (r = a.pagination.bullets).push.apply(r, o(t.querySelectorAll(pe(e.bulletClass)))); })), e.type !== 'custom' && s('paginationRender', r[0]); } } function m() { a.params.pagination = ue(a, a.originalParams.pagination, a.params.pagination, { el: 'swiper-pagination' }); let e; const t = a.params.pagination; t.el && (typeof t.el === 'string' && a.isElement && (e = a.el.querySelector(t.el)), e || typeof t.el !== 'string' || (e = o(document.querySelectorAll(t.el))), e || (e = t.el), e && e.length !== 0 && (a.params.uniqueNavElements && typeof t.el === 'string' && Array.isArray(e) && e.length > 1 && (e = o(a.el.querySelectorAll(t.el))).length > 1 && (e = e.filter(((e) => I(e, '.swiper')[0] === a.el))[0]), Array.isArray(e) && e.length === 1 && (e = e[0]), Object.assign(a.pagination, { el: e }), (e = O(e)).forEach(((e) => { let r; t.type === 'bullets' && t.clickable && (r = e.classList).add.apply(r, o((t.clickableClass || '').split(' '))), e.classList.add(t.modifierClass + t.type), e.classList.add(a.isHorizontal() ? t.horizontalClass : t.verticalClass), t.type === 'bullets' && t.dynamicBullets && (e.classList.add(''.concat(t.modifierClass).concat(t.type, '-dynamic')), l = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), t.type === 'progressbar' && t.progressbarOpposite && e.classList.add(t.progressbarOppositeClass), t.clickable && e.addEventListener('click', u), a.enabled || e.classList.add(t.lockClass); })))); } function v() { const e = a.params.pagination; if (!d()) { let t = a.pagination.el; t && (t = O(t)).forEach(((t) => { let r; t.classList.remove(e.hiddenClass), t.classList.remove(e.modifierClass + e.type), t.classList.remove(a.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && ((r = t.classList).remove.apply(r, o((e.clickableClass || '').split(' '))), t.removeEventListener('click', u)); })), a.pagination.bullets && a.pagination.bullets.forEach(((t) => { let a; return (a = t.classList).remove.apply(a, o(e.bulletActiveClass.split(' '))); })); } }i('changeDirection', (() => { if (a.pagination && a.pagination.el) { const e = a.params.pagination; let t = a.pagination.el; (t = O(t)).forEach(((t) => { t.classList.remove(e.horizontalClass, e.verticalClass), t.classList.add(a.isHorizontal() ? e.horizontalClass : e.verticalClass); })); } })), i('init', (() => { !1 === a.params.pagination.enabled ? h() : (m(), f(), p()); })), i('activeIndexChange', (() => { void 0 === a.snapIndex && p(); })), i('snapIndexChange', (() => { p(); })), i('snapGridLengthChange', (() => { f(), p(); })), i('destroy', (() => { v(); })), i('enable disable', (() => { let e = a.pagination.el; e && (e = O(e)).forEach(((e) => e.classList[a.enabled ? 'remove' : 'add'](a.params.pagination.lockClass))); })), i('lock unlock', (() => { p(); })), i('click', ((e, t) => { const r = t.target; const i = O(a.pagination.el); if (a.params.pagination.el && a.params.pagination.hideOnClick && i && i.length > 0 && !r.classList.contains(a.params.pagination.bulletClass)) { if (a.navigation && (a.navigation.nextEl && r === a.navigation.nextEl || a.navigation.prevEl && r === a.navigation.prevEl)) return; const n = i[0].classList.contains(a.params.pagination.hiddenClass); s(!0 === n ? 'paginationShow' : 'paginationHide'), i.forEach(((e) => e.classList.toggle(a.params.pagination.hiddenClass))); } })); var h = function () { a.el.classList.add(a.params.pagination.paginationDisabledClass); let e = a.pagination.el; e && (e = O(e)).forEach(((e) => e.classList.add(a.params.pagination.paginationDisabledClass))), v(); }; Object.assign(a.pagination, {
          enable() { a.el.classList.remove(a.params.pagination.paginationDisabledClass); let e = a.pagination.el; e && (e = O(e)).forEach(((e) => e.classList.remove(a.params.pagination.paginationDisabledClass))), m(), f(), p(); }, disable: h, render: f, update: p, init: m, destroy: v,
        });
      }, function (e) {
        let t; let a; let r; let s; const n = e.swiper; const l = e.extendParams; const d = e.on; const c = e.emit; const u = i(); let p = !1; let f = null; let m = null; function g() { if (n.params.scrollbar.el && n.scrollbar.el) { const e = n.scrollbar; const t = n.rtlTranslate; const i = e.dragEl; const s = e.el; const o = n.params.scrollbar; const l = n.params.loop ? n.progressLoop : n.progress; let d = a; let c = (r - a) * l; t ? (c = -c) > 0 ? (d = a - c, c = 0) : -c + a > r && (d = r + c) : c < 0 ? (d = a + c, c = 0) : c + a > r && (d = r - c), n.isHorizontal() ? (i.style.transform = 'translate3d('.concat(c, 'px, 0, 0)'), i.style.width = ''.concat(d, 'px')) : (i.style.transform = 'translate3d(0px, '.concat(c, 'px, 0)'), i.style.height = ''.concat(d, 'px')), o.hide && (clearTimeout(f), s.style.opacity = 1, f = setTimeout((() => { s.style.opacity = 0, s.style.transitionDuration = '400ms'; }), 1e3)); } } function w() { if (n.params.scrollbar.el && n.scrollbar.el) { const e = n.scrollbar; const t = e.dragEl; const i = e.el; t.style.width = '', t.style.height = '', r = n.isHorizontal() ? i.offsetWidth : i.offsetHeight, s = n.size / (n.virtualSize + n.params.slidesOffsetBefore - (n.params.centeredSlides ? n.snapGrid[0] : 0)), a = n.params.scrollbar.dragSize === 'auto' ? r * s : parseInt(n.params.scrollbar.dragSize, 10), n.isHorizontal() ? t.style.width = ''.concat(a, 'px') : t.style.height = ''.concat(a, 'px'), i.style.display = s >= 1 ? 'none' : '', n.params.scrollbar.hide && (i.style.opacity = 0), n.params.watchOverflow && n.enabled && e.el.classList[n.isLocked ? 'add' : 'remove'](n.params.scrollbar.lockClass); } } function b(e) { return n.isHorizontal() ? e.clientX : e.clientY; } function y(e) { let i; const s = n.scrollbar; const o = n.rtlTranslate; const l = s.el; i = (b(e) - P(l)[n.isHorizontal() ? 'left' : 'top'] - (t !== null ? t : a / 2)) / (r - a), i = Math.max(Math.min(i, 1), 0), o && (i = 1 - i); const d = n.minTranslate() + (n.maxTranslate() - n.minTranslate()) * i; n.updateProgress(d), n.setTranslate(d), n.updateActiveIndex(), n.updateSlidesClasses(); } function E(e) { const a = n.params.scrollbar; const r = n.scrollbar; const i = n.wrapperEl; const s = r.el; const o = r.dragEl; p = !0, t = e.target === o ? b(e) - e.target.getBoundingClientRect()[n.isHorizontal() ? 'left' : 'top'] : null, e.preventDefault(), e.stopPropagation(), i.style.transitionDuration = '100ms', o.style.transitionDuration = '100ms', y(e), clearTimeout(m), s.style.transitionDuration = '0ms', a.hide && (s.style.opacity = 1), n.params.cssMode && (n.wrapperEl.style['scroll-snap-type'] = 'none'), c('scrollbarDragStart', e); } function x(e) { const t = n.scrollbar; const a = n.wrapperEl; const r = t.el; const i = t.dragEl; p && (e.preventDefault && e.cancelable ? e.preventDefault() : e.returnValue = !1, y(e), a.style.transitionDuration = '0ms', r.style.transitionDuration = '0ms', i.style.transitionDuration = '0ms', c('scrollbarDragMove', e)); } function S(e) { const t = n.params.scrollbar; const a = n.scrollbar; const r = n.wrapperEl; const i = a.el; p && (p = !1, n.params.cssMode && (n.wrapperEl.style['scroll-snap-type'] = '', r.style.transitionDuration = ''), t.hide && (clearTimeout(m), m = h((() => { i.style.opacity = 0, i.style.transitionDuration = '400ms'; }), 1e3)), c('scrollbarDragEnd', e), t.snapOnRelease && n.slideToClosest()); } function T(e) { const t = n.scrollbar; const a = n.params; const r = t.el; if (r) { const i = r; const s = !!a.passiveListeners && { passive: !1, capture: !1 }; const o = !!a.passiveListeners && { passive: !0, capture: !1 }; if (i) { const l = e === 'on' ? 'addEventListener' : 'removeEventListener'; i[l]('pointerdown', E, s), u[l]('pointermove', x, s), u[l]('pointerup', S, o); } } } function M() { let e; const t = n.scrollbar; const a = n.el; n.params.scrollbar = ue(n, n.originalParams.scrollbar, n.params.scrollbar, { el: 'swiper-scrollbar' }); const r = n.params.scrollbar; if (r.el) { let i; let s; if (typeof r.el === 'string' && n.isElement && (i = n.el.querySelector(r.el)), i || typeof r.el !== 'string')i || (i = r.el); else if (!(i = u.querySelectorAll(r.el)).length) return; n.params.uniqueNavElements && typeof r.el === 'string' && i.length > 1 && a.querySelectorAll(r.el).length === 1 && (i = a.querySelector(r.el)), i.length > 0 && (i = i[0]), i.classList.add(n.isHorizontal() ? r.horizontalClass : r.verticalClass), i && ((s = i.querySelector(pe(n.params.scrollbar.dragClass))) || (s = C('div', n.params.scrollbar.dragClass), i.append(s))), Object.assign(t, { el: i, dragEl: s }), r.draggable && n.params.scrollbar.el && n.scrollbar.el && T('on'), i && (e = i.classList)[n.enabled ? 'remove' : 'add'].apply(e, o(v(n.params.scrollbar.lockClass))); } } function L() { let e; const t = n.params.scrollbar; const a = n.scrollbar.el; a && (e = a.classList).remove.apply(e, o(v(n.isHorizontal() ? t.horizontalClass : t.verticalClass))), n.params.scrollbar.el && n.scrollbar.el && T('off'); }l({
          scrollbar: {
            el: null, dragSize: 'auto', hide: !1, draggable: !1, snapOnRelease: !0, lockClass: 'swiper-scrollbar-lock', dragClass: 'swiper-scrollbar-drag', scrollbarDisabledClass: 'swiper-scrollbar-disabled', horizontalClass: 'swiper-scrollbar-horizontal', verticalClass: 'swiper-scrollbar-vertical',
          },
        }), n.scrollbar = { el: null, dragEl: null }, d('changeDirection', (() => { if (n.scrollbar && n.scrollbar.el) { const e = n.params.scrollbar; let t = n.scrollbar.el; (t = O(t)).forEach(((t) => { t.classList.remove(e.horizontalClass, e.verticalClass), t.classList.add(n.isHorizontal() ? e.horizontalClass : e.verticalClass); })); } })), d('init', (() => { !1 === n.params.scrollbar.enabled ? k() : (M(), w(), g()); })), d('update resize observerUpdate lock unlock changeDirection', (() => { w(); })), d('setTranslate', (() => { g(); })), d('setTransition', ((e, t) => { !(function (e) { n.params.scrollbar.el && n.scrollbar.el && (n.scrollbar.dragEl.style.transitionDuration = ''.concat(e, 'ms')); }(t)); })), d('enable disable', (() => { let e; const t = n.scrollbar.el; t && (e = t.classList)[n.enabled ? 'remove' : 'add'].apply(e, o(v(n.params.scrollbar.lockClass))); })), d('destroy', (() => { L(); })); var k = function () { let e; let t; (e = n.el.classList).add.apply(e, o(v(n.params.scrollbar.scrollbarDisabledClass))), n.scrollbar.el && (t = n.scrollbar.el.classList).add.apply(t, o(v(n.params.scrollbar.scrollbarDisabledClass))), L(); }; Object.assign(n.scrollbar, {
          enable() { let e; let t; (e = n.el.classList).remove.apply(e, o(v(n.params.scrollbar.scrollbarDisabledClass))), n.scrollbar.el && (t = n.scrollbar.el.classList).remove.apply(t, o(v(n.params.scrollbar.scrollbarDisabledClass))), M(), w(), g(); }, disable: k, updateSize: w, setTranslate: g, init: M, destroy: L,
        });
      }, function (e) { const t = e.swiper; const a = e.extendParams; const r = e.on; a({ parallax: { enabled: !1 } }); const i = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]'; const s = function (e, a) { const r = t.rtl ? -1 : 1; const i = e.getAttribute('data-swiper-parallax') || '0'; let s = e.getAttribute('data-swiper-parallax-x'); let n = e.getAttribute('data-swiper-parallax-y'); const o = e.getAttribute('data-swiper-parallax-scale'); const l = e.getAttribute('data-swiper-parallax-opacity'); const d = e.getAttribute('data-swiper-parallax-rotate'); if (s || n ? (s = s || '0', n = n || '0') : t.isHorizontal() ? (s = i, n = '0') : (n = i, s = '0'), s = s.indexOf('%') >= 0 ? `${parseInt(s, 10) * a * r}%` : `${s * a * r}px`, n = n.indexOf('%') >= 0 ? `${parseInt(n, 10) * a}%` : `${n * a}px`, l != null) { const c = l - (l - 1) * (1 - Math.abs(a)); e.style.opacity = c; } let u = 'translate3d('.concat(s, ', ').concat(n, ', 0px)'); o != null && (u += ' scale('.concat(o - (o - 1) * (1 - Math.abs(a)), ')')), d && d != null && (u += ' rotate('.concat(d * a * -1, 'deg)')), e.style.transform = u; }; const n = function () { const e = t.el; const a = t.slides; const r = t.progress; const n = t.snapGrid; const l = (t.isElement, T(e, i)); t.isElement && l.push.apply(l, o(T(t.hostEl, i))), l.forEach(((e) => { s(e, r); })), a.forEach(((e, a) => { let o = e.progress; t.params.slidesPerGroup > 1 && t.params.slidesPerView !== 'auto' && (o += Math.ceil(a / 2) - r * (n.length - 1)), o = Math.min(Math.max(o, -1), 1), e.querySelectorAll(''.concat(i, ', [data-swiper-parallax-rotate]')).forEach(((e) => { s(e, o); })); })); }; r('beforeInit', (() => { t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0); })), r('init', (() => { t.params.parallax.enabled && n(); })), r('setTranslate', (() => { t.params.parallax.enabled && n(); })), r('setTransition', ((e, a) => { t.params.parallax.enabled && (function (e) { void 0 === e && (e = t.params.speed); const a = t.el; const r = t.hostEl; const s = o(a.querySelectorAll(i)); t.isElement && s.push.apply(s, o(r.querySelectorAll(i))), s.forEach(((t) => { let a = parseInt(t.getAttribute('data-swiper-parallax-duration'), 10) || e; e === 0 && (a = 0), t.style.transitionDuration = ''.concat(a, 'ms'); })); }(a)); })); }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; const i = e.emit; const s = m(); a({
          zoom: {
            enabled: !1, limitToOriginalSize: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: 'swiper-zoom-container', zoomedSlideClass: 'swiper-slide-zoomed',
          },
        }), t.zoom = { enabled: !1 }; let l; let d; let c; let u = 1; let p = !1; const f = []; const v = {
          originX: 0, originY: 0, slideEl: void 0, slideWidth: void 0, slideHeight: void 0, imageEl: void 0, imageWrapEl: void 0, maxRatio: 3,
        }; const h = {
          isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {},
        }; const g = {
          x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0,
        }; let b = 1; function y() { if (f.length < 2) return 1; const e = f[0].pageX; const t = f[0].pageY; const a = f[1].pageX; const r = f[1].pageY; return Math.sqrt((a - e) ** 2 + (r - t) ** 2); } function E() { const e = t.params.zoom; const a = v.imageWrapEl.getAttribute('data-swiper-zoom') || e.maxRatio; if (e.limitToOriginalSize && v.imageEl && v.imageEl.naturalWidth) { const r = v.imageEl.naturalWidth / v.imageEl.offsetWidth; return Math.min(r, a); } return a; } function x(e) { const a = t.isElement ? 'swiper-slide' : '.'.concat(t.params.slideClass); return !!e.target.matches(a) || t.slides.filter(((t) => t.contains(e.target))).length > 0; } function S(e) { if (e.pointerType === 'mouse' && f.splice(0, f.length), x(e)) { const a = t.params.zoom; if (l = !1, d = !1, f.push(e), !(f.length < 2)) { if (l = !0, v.scaleStart = y(), !v.slideEl) { v.slideEl = e.target.closest('.'.concat(t.params.slideClass, ', swiper-slide')), v.slideEl || (v.slideEl = t.slides[t.activeIndex]); let r = v.slideEl.querySelector('.'.concat(a.containerClass)); if (r && (r = r.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0]), v.imageEl = r, v.imageWrapEl = r ? I(v.imageEl, '.'.concat(a.containerClass))[0] : void 0, !v.imageWrapEl) return void (v.imageEl = void 0); v.maxRatio = E(); } if (v.imageEl) { const i = (function () { if (f.length < 2) return { x: null, y: null }; const e = v.imageEl.getBoundingClientRect(); return [(f[0].pageX + (f[1].pageX - f[0].pageX) / 2 - e.x - s.scrollX) / u, (f[0].pageY + (f[1].pageY - f[0].pageY) / 2 - e.y - s.scrollY) / u]; }()); const o = n(i, 2); const c = o[0]; const m = o[1]; v.originX = c, v.originY = m, v.imageEl.style.transitionDuration = '0ms'; }p = !0; } } } function M(e) { if (x(e)) { const a = t.params.zoom; const r = t.zoom; const i = f.findIndex(((t) => t.pointerId === e.pointerId)); i >= 0 && (f[i] = e), f.length < 2 || (d = !0, v.scaleMove = y(), v.imageEl && (r.scale = v.scaleMove / v.scaleStart * u, r.scale > v.maxRatio && (r.scale = v.maxRatio - 1 + (r.scale - v.maxRatio + 1) ** 0.5), r.scale < a.minRatio && (r.scale = a.minRatio + 1 - (a.minRatio - r.scale + 1) ** 0.5), v.imageEl.style.transform = 'translate3d(0,0,0) scale('.concat(r.scale, ')'))); } } function C(e) { if (x(e) && (e.pointerType !== 'mouse' || e.type !== 'pointerout')) { const a = t.params.zoom; const r = t.zoom; const i = f.findIndex(((t) => t.pointerId === e.pointerId)); i >= 0 && f.splice(i, 1), l && d && (l = !1, d = !1, v.imageEl && (r.scale = Math.max(Math.min(r.scale, v.maxRatio), a.minRatio), v.imageEl.style.transitionDuration = ''.concat(t.params.speed, 'ms'), v.imageEl.style.transform = 'translate3d(0,0,0) scale('.concat(r.scale, ')'), u = r.scale, p = !1, r.scale > 1 && v.slideEl ? v.slideEl.classList.add(''.concat(a.zoomedSlideClass)) : r.scale <= 1 && v.slideEl && v.slideEl.classList.remove(''.concat(a.zoomedSlideClass)), r.scale === 1 && (v.originX = 0, v.originY = 0, v.slideEl = void 0))); } } function L() { t.touchEventsData.preventTouchMoveFromPointerMove = !1; } function k(e) { if (x(e) && (function (e) { const a = '.'.concat(t.params.zoom.containerClass); return !!e.target.matches(a) || o(t.hostEl.querySelectorAll(a)).filter(((t) => t.contains(e.target))).length > 0; }(e))) { const a = t.zoom; if (v.imageEl && h.isTouched && v.slideEl) { h.isMoved || (h.width = v.imageEl.offsetWidth || v.imageEl.clientWidth, h.height = v.imageEl.offsetHeight || v.imageEl.clientHeight, h.startX = w(v.imageWrapEl, 'x') || 0, h.startY = w(v.imageWrapEl, 'y') || 0, v.slideWidth = v.slideEl.offsetWidth, v.slideHeight = v.slideEl.offsetHeight, v.imageWrapEl.style.transitionDuration = '0ms'); const r = h.width * a.scale; const i = h.height * a.scale; if (h.minX = Math.min(v.slideWidth / 2 - r / 2, 0), h.maxX = -h.minX, h.minY = Math.min(v.slideHeight / 2 - i / 2, 0), h.maxY = -h.minY, h.touchesCurrent.x = f.length > 0 ? f[0].pageX : e.pageX, h.touchesCurrent.y = f.length > 0 ? f[0].pageY : e.pageY, Math.max(Math.abs(h.touchesCurrent.x - h.touchesStart.x), Math.abs(h.touchesCurrent.y - h.touchesStart.y)) > 5 && (t.allowClick = !1), !h.isMoved && !p) { if (t.isHorizontal() && (Math.floor(h.minX) === Math.floor(h.startX) && h.touchesCurrent.x < h.touchesStart.x || Math.floor(h.maxX) === Math.floor(h.startX) && h.touchesCurrent.x > h.touchesStart.x)) return h.isTouched = !1, void L(); if (!t.isHorizontal() && (Math.floor(h.minY) === Math.floor(h.startY) && h.touchesCurrent.y < h.touchesStart.y || Math.floor(h.maxY) === Math.floor(h.startY) && h.touchesCurrent.y > h.touchesStart.y)) return h.isTouched = !1, void L(); }e.cancelable && e.preventDefault(), e.stopPropagation(), clearTimeout(c), t.touchEventsData.preventTouchMoveFromPointerMove = !0, c = setTimeout((() => { L(); })), h.isMoved = !0; const s = (a.scale - u) / (v.maxRatio - t.params.zoom.minRatio); const n = v.originX; const l = v.originY; h.currentX = h.touchesCurrent.x - h.touchesStart.x + h.startX + s * (h.width - 2 * n), h.currentY = h.touchesCurrent.y - h.touchesStart.y + h.startY + s * (h.height - 2 * l), h.currentX < h.minX && (h.currentX = h.minX + 1 - (h.minX - h.currentX + 1) ** 0.8), h.currentX > h.maxX && (h.currentX = h.maxX - 1 + (h.currentX - h.maxX + 1) ** 0.8), h.currentY < h.minY && (h.currentY = h.minY + 1 - (h.minY - h.currentY + 1) ** 0.8), h.currentY > h.maxY && (h.currentY = h.maxY - 1 + (h.currentY - h.maxY + 1) ** 0.8), g.prevPositionX || (g.prevPositionX = h.touchesCurrent.x), g.prevPositionY || (g.prevPositionY = h.touchesCurrent.y), g.prevTime || (g.prevTime = Date.now()), g.x = (h.touchesCurrent.x - g.prevPositionX) / (Date.now() - g.prevTime) / 2, g.y = (h.touchesCurrent.y - g.prevPositionY) / (Date.now() - g.prevTime) / 2, Math.abs(h.touchesCurrent.x - g.prevPositionX) < 2 && (g.x = 0), Math.abs(h.touchesCurrent.y - g.prevPositionY) < 2 && (g.y = 0), g.prevPositionX = h.touchesCurrent.x, g.prevPositionY = h.touchesCurrent.y, g.prevTime = Date.now(), v.imageWrapEl.style.transform = 'translate3d('.concat(h.currentX, 'px, ').concat(h.currentY, 'px,0)'); } } } function A() { const e = t.zoom; v.slideEl && t.activeIndex !== t.slides.indexOf(v.slideEl) && (v.imageEl && (v.imageEl.style.transform = 'translate3d(0,0,0) scale(1)'), v.imageWrapEl && (v.imageWrapEl.style.transform = 'translate3d(0,0,0)'), v.slideEl.classList.remove(''.concat(t.params.zoom.zoomedSlideClass)), e.scale = 1, u = 1, v.slideEl = void 0, v.imageEl = void 0, v.imageWrapEl = void 0, v.originX = 0, v.originY = 0); } function z(e) { const a = t.zoom; const r = t.params.zoom; if (!v.slideEl) { e && e.target && (v.slideEl = e.target.closest('.'.concat(t.params.slideClass, ', swiper-slide'))), v.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? v.slideEl = T(t.slidesEl, '.'.concat(t.params.slideActiveClass))[0] : v.slideEl = t.slides[t.activeIndex]); let i = v.slideEl.querySelector('.'.concat(r.containerClass)); i && (i = i.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0]), v.imageEl = i, v.imageWrapEl = i ? I(v.imageEl, '.'.concat(r.containerClass))[0] : void 0; } if (v.imageEl && v.imageWrapEl) { let n; let o; let l; let d; let c; let p; let f; let m; let g; let w; let b; let y; let x; let S; let M; let C; t.params.cssMode && (t.wrapperEl.style.overflow = 'hidden', t.wrapperEl.style.touchAction = 'none'), v.slideEl.classList.add(''.concat(r.zoomedSlideClass)), void 0 === h.touchesStart.x && e ? (n = e.pageX, o = e.pageY) : (n = h.touchesStart.x, o = h.touchesStart.y); const L = typeof e === 'number' ? e : null; u === 1 && L && (n = void 0, o = void 0, h.touchesStart.x = void 0, h.touchesStart.y = void 0); const k = E(); a.scale = L || k, u = L || k, !e || u === 1 && L ? (c = 0, p = 0) : (M = v.slideEl.offsetWidth, C = v.slideEl.offsetHeight, l = P(v.slideEl).left + s.scrollX + M / 2 - n, d = P(v.slideEl).top + s.scrollY + C / 2 - o, f = v.imageEl.offsetWidth || v.imageEl.clientWidth, m = v.imageEl.offsetHeight || v.imageEl.clientHeight, g = f * a.scale, w = m * a.scale, x = -(b = Math.min(M / 2 - g / 2, 0)), S = -(y = Math.min(C / 2 - w / 2, 0)), (c = l * a.scale) < b && (c = b), c > x && (c = x), (p = d * a.scale) < y && (p = y), p > S && (p = S)), L && a.scale === 1 && (v.originX = 0, v.originY = 0), v.imageWrapEl.style.transitionDuration = '300ms', v.imageWrapEl.style.transform = 'translate3d('.concat(c, 'px, ').concat(p, 'px,0)'), v.imageEl.style.transitionDuration = '300ms', v.imageEl.style.transform = 'translate3d(0,0,0) scale('.concat(a.scale, ')'); } } function O() { const e = t.zoom; const a = t.params.zoom; if (!v.slideEl) { t.params.virtual && t.params.virtual.enabled && t.virtual ? v.slideEl = T(t.slidesEl, '.'.concat(t.params.slideActiveClass))[0] : v.slideEl = t.slides[t.activeIndex]; let r = v.slideEl.querySelector('.'.concat(a.containerClass)); r && (r = r.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0]), v.imageEl = r, v.imageWrapEl = r ? I(v.imageEl, '.'.concat(a.containerClass))[0] : void 0; }v.imageEl && v.imageWrapEl && (t.params.cssMode && (t.wrapperEl.style.overflow = '', t.wrapperEl.style.touchAction = ''), e.scale = 1, u = 1, h.touchesStart.x = void 0, h.touchesStart.y = void 0, v.imageWrapEl.style.transitionDuration = '300ms', v.imageWrapEl.style.transform = 'translate3d(0,0,0)', v.imageEl.style.transitionDuration = '300ms', v.imageEl.style.transform = 'translate3d(0,0,0) scale(1)', v.slideEl.classList.remove(''.concat(a.zoomedSlideClass)), v.slideEl = void 0, v.originX = 0, v.originY = 0); } function D(e) { const a = t.zoom; a.scale && a.scale !== 1 ? O() : z(e); } function G() { return { passiveListener: !!t.params.passiveListeners && { passive: !0, capture: !1 }, activeListenerWithCapture: !t.params.passiveListeners || { passive: !1, capture: !0 } }; } function H() { const e = t.zoom; if (!e.enabled) { e.enabled = !0; const a = G(); const r = a.passiveListener; const i = a.activeListenerWithCapture; t.wrapperEl.addEventListener('pointerdown', S, r), t.wrapperEl.addEventListener('pointermove', M, i), ['pointerup', 'pointercancel', 'pointerout'].forEach(((e) => { t.wrapperEl.addEventListener(e, C, r); })), t.wrapperEl.addEventListener('pointermove', k, i); } } function B() { const e = t.zoom; if (e.enabled) { e.enabled = !1; const a = G(); const r = a.passiveListener; const i = a.activeListenerWithCapture; t.wrapperEl.removeEventListener('pointerdown', S, r), t.wrapperEl.removeEventListener('pointermove', M, i), ['pointerup', 'pointercancel', 'pointerout'].forEach(((e) => { t.wrapperEl.removeEventListener(e, C, r); })), t.wrapperEl.removeEventListener('pointermove', k, i); } }Object.defineProperty(t.zoom, 'scale', { get() { return b; }, set(e) { if (b !== e) { const t = v.imageEl; const a = v.slideEl; i('zoomChange', e, t, a); }b = e; } }), r('init', (() => { t.params.zoom.enabled && H(); })), r('destroy', (() => { B(); })), r('touchStart', ((e, a) => { t.zoom.enabled && (function (e) { const a = t.device; if (v.imageEl && !h.isTouched) { a.android && e.cancelable && e.preventDefault(), h.isTouched = !0; const r = f.length > 0 ? f[0] : e; h.touchesStart.x = r.pageX, h.touchesStart.y = r.pageY; } }(a)); })), r('touchEnd', ((e, a) => { t.zoom.enabled && (function () { const e = t.zoom; if (v.imageEl) { if (!h.isTouched || !h.isMoved) return h.isTouched = !1, void (h.isMoved = !1); h.isTouched = !1, h.isMoved = !1; let a = 300; let r = 300; const i = g.x * a; const s = h.currentX + i; const n = g.y * r; const o = h.currentY + n; g.x !== 0 && (a = Math.abs((s - h.currentX) / g.x)), g.y !== 0 && (r = Math.abs((o - h.currentY) / g.y)); const l = Math.max(a, r); h.currentX = s, h.currentY = o; const d = h.width * e.scale; const c = h.height * e.scale; h.minX = Math.min(v.slideWidth / 2 - d / 2, 0), h.maxX = -h.minX, h.minY = Math.min(v.slideHeight / 2 - c / 2, 0), h.maxY = -h.minY, h.currentX = Math.max(Math.min(h.currentX, h.maxX), h.minX), h.currentY = Math.max(Math.min(h.currentY, h.maxY), h.minY), v.imageWrapEl.style.transitionDuration = ''.concat(l, 'ms'), v.imageWrapEl.style.transform = 'translate3d('.concat(h.currentX, 'px, ').concat(h.currentY, 'px,0)'); } }()); })), r('doubleTap', ((e, a) => { !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && D(a); })), r('transitionEnd', (() => { t.zoom.enabled && t.params.zoom.enabled && A(); })), r('slideChange', (() => { t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && A(); })), Object.assign(t.zoom, {
          enable: H, disable: B, in: z, out: O, toggle: D,
        });
      }, function (e) { const t = e.swiper; const a = e.extendParams; const r = e.on; function i(e, t) { let a; let r; const i = (function () { let e; let t; let a; return function (r, i) { for (t = -1, e = r.length; e - t > 1;)r[a = e + t >> 1] <= i ? t = a : e = a; return e; }; }()); return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (r = i(this.x, e), a = r - 1, (e - this.x[a]) * (this.y[r] - this.y[a]) / (this.x[r] - this.x[a]) + this.y[a]) : 0; }, this; } function s() { t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline); }a({ controller: { control: void 0, inverse: !1, by: 'slide' } }), t.controller = { control: void 0 }, r('beforeInit', (() => { typeof window !== 'undefined' && (typeof t.params.controller.control === 'string' || t.params.controller.control instanceof HTMLElement) ? (typeof t.params.controller.control === 'string' ? o(document.querySelectorAll(t.params.controller.control)) : [t.params.controller.control]).forEach(((e) => { if (t.controller.control || (t.controller.control = []), e && e.swiper)t.controller.control.push(e.swiper); else if (e) { const a = ''.concat(t.params.eventsPrefix, 'init'); const r = function (i) { t.controller.control.push(i.detail[0]), t.update(), e.removeEventListener(a, r); }; e.addEventListener(a, r); } })) : t.controller.control = t.params.controller.control; })), r('update', (() => { s(); })), r('resize', (() => { s(); })), r('observerUpdate', (() => { s(); })), r('setTranslate', ((e, a, r) => { t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(a, r); })), r('setTransition', ((e, a, r) => { t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(a, r); })), Object.assign(t.controller, { setTranslate(e, a) { let r; let s; const n = t.controller.control; const o = t.constructor; function l(e) { if (!e.destroyed) { const a = t.rtlTranslate ? -t.translate : t.translate; t.params.controller.by === 'slide' && ((function (e) { t.controller.spline = t.params.loop ? new i(t.slidesGrid, e.slidesGrid) : new i(t.snapGrid, e.snapGrid); }(e)), s = -t.controller.spline.interpolate(-a)), s && t.params.controller.by !== 'container' || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), !Number.isNaN(r) && Number.isFinite(r) || (r = 1), s = (a - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (s = e.maxTranslate() - s), e.updateProgress(s), e.setTranslate(s, t), e.updateActiveIndex(), e.updateSlidesClasses(); } } if (Array.isArray(n)) for (let d = 0; d < n.length; d += 1)n[d] !== a && n[d] instanceof o && l(n[d]); else n instanceof o && a !== n && l(n); }, setTransition(e, a) { let r; const i = t.constructor; const s = t.controller.control; function n(a) { a.destroyed || (a.setTransition(e, t), e !== 0 && (a.transitionStart(), a.params.autoHeight && h((() => { a.updateAutoHeight(); })), A(a.wrapperEl, (() => { s && a.transitionEnd(); })))); } if (Array.isArray(s)) for (r = 0; r < s.length; r += 1)s[r] !== a && s[r] instanceof i && n(s[r]); else s instanceof i && a !== s && n(s); } }); }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; a({
          a11y: {
            enabled: !0, notificationClass: 'swiper-notification', prevSlideMessage: 'Previous slide', nextSlideMessage: 'Next slide', firstSlideMessage: 'This is the first slide', lastSlideMessage: 'This is the last slide', paginationBulletMessage: 'Go to slide {{index}}', slideLabelMessage: '{{index}} / {{slidesLength}}', containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: 'group', id: null, scrollOnFocus: !0,
          },
        }), t.a11y = { clicked: !1 }; let s; let n; let o = null; let l = (new Date()).getTime(); function d(e) { const t = o; t.length !== 0 && (t.innerHTML = '', t.innerHTML = e); } function c(e) { (e = O(e)).forEach(((e) => { e.setAttribute('tabIndex', '0'); })); } function u(e) { (e = O(e)).forEach(((e) => { e.setAttribute('tabIndex', '-1'); })); } function p(e, t) { (e = O(e)).forEach(((e) => { e.setAttribute('role', t); })); } function f(e, t) { (e = O(e)).forEach(((e) => { e.setAttribute('aria-roledescription', t); })); } function m(e, t) { (e = O(e)).forEach(((e) => { e.setAttribute('aria-label', t); })); } function v(e) { (e = O(e)).forEach(((e) => { e.setAttribute('aria-disabled', !0); })); } function h(e) { (e = O(e)).forEach(((e) => { e.setAttribute('aria-disabled', !1); })); } function g(e) { if (e.keyCode === 13 || e.keyCode === 32) { const a = t.params.a11y; const r = e.target; if (!t.pagination || !t.pagination.el || r !== t.pagination.el && !t.pagination.el.contains(e.target) || e.target.matches(pe(t.params.pagination.bulletClass))) { if (t.navigation && t.navigation.prevEl && t.navigation.nextEl) { const i = O(t.navigation.prevEl); O(t.navigation.nextEl).includes(r) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? d(a.lastSlideMessage) : d(a.nextSlideMessage)), i.includes(r) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? d(a.firstSlideMessage) : d(a.prevSlideMessage)); }t.pagination && r.matches(pe(t.params.pagination.bulletClass)) && r.click(); } } } function w() { return t.pagination && t.pagination.bullets && t.pagination.bullets.length; } function b() { return w() && t.params.pagination.clickable; } const y = function (e, t, a) { c(e), e.tagName !== 'BUTTON' && (p(e, 'button'), e.addEventListener('keydown', g)), m(e, a), (function (e, t) { (e = O(e)).forEach(((e) => { e.setAttribute('aria-controls', t); })); }(e, t)); }; const E = function (e) { n && n !== e.target && !n.contains(e.target) && (s = !0), t.a11y.clicked = !0; }; const x = function () { s = !1, requestAnimationFrame((() => { requestAnimationFrame((() => { t.destroyed || (t.a11y.clicked = !1); })); })); }; const S = function (e) { l = (new Date()).getTime(); }; const T = function (e) { if (!t.a11y.clicked && t.params.a11y.scrollOnFocus && !((new Date()).getTime() - l < 100)) { const a = e.target.closest('.'.concat(t.params.slideClass, ', swiper-slide')); if (a && t.slides.includes(a)) { n = a; const r = t.slides.indexOf(a) === t.activeIndex; const i = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(a); r || i || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, requestAnimationFrame((() => { s || (t.params.loop ? t.slideToLoop(parseInt(a.getAttribute('data-swiper-slide-index')), 0) : t.slideTo(t.slides.indexOf(a), 0), s = !1); }))); } } }; const M = function () { const e = t.params.a11y; e.itemRoleDescriptionMessage && f(t.slides, e.itemRoleDescriptionMessage), e.slideRole && p(t.slides, e.slideRole); const a = t.slides.length; e.slideLabelMessage && t.slides.forEach(((r, i) => { const s = t.params.loop ? parseInt(r.getAttribute('data-swiper-slide-index'), 10) : i; m(r, e.slideLabelMessage.replace(/\{\{index\}\}/, s + 1).replace(/\{\{slidesLength\}\}/, a)); })); }; r('beforeInit', (() => { (o = C('span', t.params.a11y.notificationClass)).setAttribute('aria-live', 'assertive'), o.setAttribute('aria-atomic', 'true'); })), r('afterInit', (() => { t.params.a11y.enabled && (function () { const e = t.params.a11y; t.el.append(o); const a = t.el; e.containerRoleDescriptionMessage && f(a, e.containerRoleDescriptionMessage), e.containerMessage && m(a, e.containerMessage); let r; let s; const n = t.wrapperEl; const l = e.id || n.getAttribute('id') || 'swiper-wrapper-'.concat((void 0 === (r = 16) && (r = 16), 'x'.repeat(r).replace(/x/g, (() => Math.round(16 * Math.random()).toString(16))))); const d = t.params.autoplay && t.params.autoplay.enabled ? 'off' : 'polite'; s = l, O(n).forEach(((e) => { e.setAttribute('id', s); })), (function (e, t) { (e = O(e)).forEach(((e) => { e.setAttribute('aria-live', t); })); }(n, d)), M(); const c = t.navigation ? t.navigation : {}; let u = c.nextEl; let p = c.prevEl; u = O(u), p = O(p), u && u.forEach(((t) => y(t, l, e.nextSlideMessage))), p && p.forEach(((t) => y(t, l, e.prevSlideMessage))), b() && O(t.pagination.el).forEach(((e) => { e.addEventListener('keydown', g); })), i().addEventListener('visibilitychange', S), t.el.addEventListener('focus', T, !0), t.el.addEventListener('focus', T, !0), t.el.addEventListener('pointerdown', E, !0), t.el.addEventListener('pointerup', x, !0); }()); })), r('slidesLengthChange snapGridLengthChange slidesGridLengthChange', (() => { t.params.a11y.enabled && M(); })), r('fromEdge toEdge afterInit lock unlock', (() => { t.params.a11y.enabled && (function () { if (!t.params.loop && !t.params.rewind && t.navigation) { const e = t.navigation; const a = e.nextEl; const r = e.prevEl; r && (t.isBeginning ? (v(r), u(r)) : (h(r), c(r))), a && (t.isEnd ? (v(a), u(a)) : (h(a), c(a))); } }()); })), r('paginationUpdate', (() => { t.params.a11y.enabled && (function () { const e = t.params.a11y; w() && t.pagination.bullets.forEach(((a) => { t.params.pagination.clickable && (c(a), t.params.pagination.renderBullet || (p(a, 'button'), m(a, e.paginationBulletMessage.replace(/\{\{index\}\}/, k(a) + 1)))), a.matches(pe(t.params.pagination.bulletActiveClass)) ? a.setAttribute('aria-current', 'true') : a.removeAttribute('aria-current'); })); }()); })), r('destroy', (() => { t.params.a11y.enabled && (function () { o && o.remove(); const e = t.navigation ? t.navigation : {}; let a = e.nextEl; let r = e.prevEl; a = O(a), r = O(r), a && a.forEach(((e) => e.removeEventListener('keydown', g))), r && r.forEach(((e) => e.removeEventListener('keydown', g))), b() && O(t.pagination.el).forEach(((e) => { e.removeEventListener('keydown', g); })), i().removeEventListener('visibilitychange', S), t.el && typeof t.el !== 'string' && (t.el.removeEventListener('focus', T, !0), t.el.removeEventListener('pointerdown', E, !0), t.el.removeEventListener('pointerup', x, !0)); }()); }));
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; a({
          history: {
            enabled: !1, root: '', replaceState: !1, key: 'slides', keepQuery: !1,
          },
        }); let i = !1; let s = {}; const n = function (e) {
          return e.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-')
            .replace(/^-+/, '')
            .replace(/-+$/, '');
        }; const o = function (e) { const t = m(); const a = (e ? new URL(e) : t.location).pathname.slice(1).split('/').filter(((e) => e !== '')); const r = a.length; return { key: a[r - 2], value: a[r - 1] }; }; const l = function (e, a) { const r = m(); if (i && t.params.history.enabled) { let s; s = t.params.url ? new URL(t.params.url) : r.location; const o = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector('[data-swiper-slide-index="'.concat(a, '"]')) : t.slides[a]; let l = n(o.getAttribute('data-history')); if (t.params.history.root.length > 0) { let d = t.params.history.root; d[d.length - 1] === '/' && (d = d.slice(0, d.length - 1)), l = ''.concat(d, '/').concat(e ? ''.concat(e, '/') : '').concat(l); } else s.pathname.includes(e) || (l = ''.concat(e ? ''.concat(e, '/') : '').concat(l)); t.params.history.keepQuery && (l += s.search); const c = r.history.state; c && c.value === l || (t.params.history.replaceState ? r.history.replaceState({ value: l }, null, l) : r.history.pushState({ value: l }, null, l)); } }; const d = function (e, a, r) { if (a) for (let i = 0, s = t.slides.length; i < s; i += 1) { const o = t.slides[i]; if (n(o.getAttribute('data-history')) === a) { const l = t.getSlideIndex(o); t.slideTo(l, e, r); } } else t.slideTo(0, e, r); }; const c = function () { s = o(t.params.url), d(t.params.speed, s.value, !1); }; r('init', (() => { t.params.history.enabled && (function () { const e = m(); if (t.params.history) { if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0); i = !0, (s = o(t.params.url)).key || s.value ? (d(0, s.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener('popstate', c)) : t.params.history.replaceState || e.addEventListener('popstate', c); } }()); })), r('destroy', (() => { t.params.history.enabled && (function () { const e = m(); t.params.history.replaceState || e.removeEventListener('popstate', c); }()); })), r('transitionEnd _freeModeNoMomentumRelease', (() => { i && l(t.params.history.key, t.activeIndex); })), r('slideChange', (() => { i && t.params.cssMode && l(t.params.history.key, t.activeIndex); }));
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.emit; const s = e.on; let n = !1; const o = i(); const l = m(); a({
          hashNavigation: {
            enabled: !1, replaceState: !1, watchState: !1, getSlideIndex(e, a) { if (t.virtual && t.params.virtual.enabled) { const r = t.slides.filter(((e) => e.getAttribute('data-hash') === a))[0]; return r ? parseInt(r.getAttribute('data-swiper-slide-index'), 10) : 0; } return t.getSlideIndex(T(t.slidesEl, '.'.concat(t.params.slideClass, '[data-hash="').concat(a, '"], swiper-slide[data-hash="').concat(a, '"]'))[0]); },
          },
        }); const d = function () { r('hashChange'); const e = o.location.hash.replace('#', ''); const a = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector('[data-swiper-slide-index="'.concat(t.activeIndex, '"]')) : t.slides[t.activeIndex]; if (e !== (a ? a.getAttribute('data-hash') : '')) { const i = t.params.hashNavigation.getSlideIndex(t, e); if (void 0 === i || Number.isNaN(i)) return; t.slideTo(i); } }; const c = function () { if (n && t.params.hashNavigation.enabled) { const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector('[data-swiper-slide-index="'.concat(t.activeIndex, '"]')) : t.slides[t.activeIndex]; const a = e ? e.getAttribute('data-hash') || e.getAttribute('data-history') : ''; t.params.hashNavigation.replaceState && l.history && l.history.replaceState ? (l.history.replaceState(null, null, '#'.concat(a) || 0), r('hashSet')) : (o.location.hash = a || '', r('hashSet')); } }; s('init', (() => { t.params.hashNavigation.enabled && (function () { if (!(!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled)) { n = !0; const e = o.location.hash.replace('#', ''); if (e) { const a = t.params.hashNavigation.getSlideIndex(t, e); t.slideTo(a || 0, 0, t.params.runCallbacksOnInit, !0); }t.params.hashNavigation.watchState && l.addEventListener('hashchange', d); } }()); })), s('destroy', (() => { t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && l.removeEventListener('hashchange', d); })), s('transitionEnd _freeModeNoMomentumRelease', (() => { n && c(); })), s('slideChange', (() => { n && t.params.cssMode && c(); }));
      }, function (e) {
        let t; let a; const r = e.swiper; const s = e.extendParams; const n = e.on; const o = e.emit; const l = e.params; r.autoplay = { running: !1, paused: !1, timeLeft: 0 }, s({
          autoplay: {
            enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !1, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1,
          },
        }); let d; let c; let u; let p; let f; let m; let v; let h; let g = l && l.autoplay ? l.autoplay.delay : 3e3; let w = l && l.autoplay ? l.autoplay.delay : 3e3; let b = (new Date()).getTime(); function y(e) { r && !r.destroyed && r.wrapperEl && e.target === r.wrapperEl && (r.wrapperEl.removeEventListener('transitionend', y), h || e.detail && e.detail.bySwiperTouchMove || C()); } const E = function () { if (!r.destroyed && r.autoplay.running) { r.autoplay.paused ? c = !0 : c && (w = d, c = !1); const e = r.autoplay.paused ? d : b + w - (new Date()).getTime(); r.autoplay.timeLeft = e, o('autoplayTimeLeft', e, e / g), a = requestAnimationFrame((() => { E(); })); } }; const x = function (e) { if (!r.destroyed && r.autoplay.running) { cancelAnimationFrame(a), E(); let i = void 0 === e ? r.params.autoplay.delay : e; g = r.params.autoplay.delay, w = r.params.autoplay.delay; const s = (function () { let e; if (e = r.virtual && r.params.virtual.enabled ? r.slides.filter(((e) => e.classList.contains('swiper-slide-active')))[0] : r.slides[r.activeIndex]) return parseInt(e.getAttribute('data-swiper-autoplay'), 10); }()); !Number.isNaN(s) && s > 0 && void 0 === e && (i = s, g = s, w = s), d = i; const n = r.params.speed; const l = function () { r && !r.destroyed && (r.params.autoplay.reverseDirection ? !r.isBeginning || r.params.loop || r.params.rewind ? (r.slidePrev(n, !0, !0), o('autoplay')) : r.params.autoplay.stopOnLastSlide || (r.slideTo(r.slides.length - 1, n, !0, !0), o('autoplay')) : !r.isEnd || r.params.loop || r.params.rewind ? (r.slideNext(n, !0, !0), o('autoplay')) : r.params.autoplay.stopOnLastSlide || (r.slideTo(0, n, !0, !0), o('autoplay')), r.params.cssMode && (b = (new Date()).getTime(), requestAnimationFrame((() => { x(); })))); }; return i > 0 ? (clearTimeout(t), t = setTimeout((() => { l(); }), i)) : requestAnimationFrame((() => { l(); })), i; } }; const S = function () { b = (new Date()).getTime(), r.autoplay.running = !0, x(), o('autoplayStart'); }; const T = function () { r.autoplay.running = !1, clearTimeout(t), cancelAnimationFrame(a), o('autoplayStop'); }; const M = function (e, a) { if (!r.destroyed && r.autoplay.running) { clearTimeout(t), e || (v = !0); const i = function () { o('autoplayPause'), r.params.autoplay.waitForTransition ? r.wrapperEl.addEventListener('transitionend', y) : C(); }; if (r.autoplay.paused = !0, a) return m && (d = r.params.autoplay.delay), m = !1, void i(); const s = d || r.params.autoplay.delay; d = s - ((new Date()).getTime() - b), r.isEnd && d < 0 && !r.params.loop || (d < 0 && (d = 0), i()); } }; var C = function () { r.isEnd && d < 0 && !r.params.loop || r.destroyed || !r.autoplay.running || (b = (new Date()).getTime(), v ? (v = !1, x(d)) : x(), r.autoplay.paused = !1, o('autoplayResume')); }; const P = function () { if (!r.destroyed && r.autoplay.running) { const e = i(); e.visibilityState === 'hidden' && (v = !0, M(!0)), e.visibilityState === 'visible' && C(); } }; const L = function (e) { e.pointerType === 'mouse' && (v = !0, h = !0, r.animating || r.autoplay.paused || M(!0)); }; const k = function (e) { e.pointerType === 'mouse' && (h = !1, r.autoplay.paused && C()); }; n('init', (() => { r.params.autoplay.enabled && (r.params.autoplay.pauseOnMouseEnter && (r.el.addEventListener('pointerenter', L), r.el.addEventListener('pointerleave', k)), i().addEventListener('visibilitychange', P), S()); })), n('destroy', (() => { r.el && typeof r.el !== 'string' && (r.el.removeEventListener('pointerenter', L), r.el.removeEventListener('pointerleave', k)), i().removeEventListener('visibilitychange', P), r.autoplay.running && T(); })), n('_freeModeStaticRelease', (() => { (p || v) && C(); })), n('_freeModeNoMomentumRelease', (() => { r.params.autoplay.disableOnInteraction ? T() : M(!0, !0); })), n('beforeTransitionStart', ((e, t, a) => { !r.destroyed && r.autoplay.running && (a || !r.params.autoplay.disableOnInteraction ? M(!0, !0) : T()); })), n('sliderFirstMove', (() => { !r.destroyed && r.autoplay.running && (r.params.autoplay.disableOnInteraction ? T() : (u = !0, p = !1, v = !1, f = setTimeout((() => { v = !0, p = !0, M(!0); }), 200))); })), n('touchEnd', (() => { if (!r.destroyed && r.autoplay.running && u) { if (clearTimeout(f), clearTimeout(t), r.params.autoplay.disableOnInteraction) return p = !1, void (u = !1); p && r.params.cssMode && C(), p = !1, u = !1; } })), n('slideChange', (() => { !r.destroyed && r.autoplay.running && (m = !0); })), Object.assign(r.autoplay, {
          start: S, stop: T, pause: M, resume: C,
        });
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; a({
          thumbs: {
            swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: 'swiper-slide-thumb-active', thumbsContainerClass: 'swiper-thumbs',
          },
        }); let s = !1; let n = !1; function o() { const e = t.thumbs.swiper; if (e && !e.destroyed) { let a; const r = e.clickedIndex; const i = e.clickedSlide; i && i.classList.contains(t.params.thumbs.slideThumbActiveClass) || r != null && (a = e.params.loop ? parseInt(e.clickedSlide.getAttribute('data-swiper-slide-index'), 10) : r, t.params.loop ? t.slideToLoop(a) : t.slideTo(a)); } } function l() { const e = t.params.thumbs; if (s) return !1; s = !0; const a = t.constructor; if (e.swiper instanceof a)t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(t.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper.update(); else if (b(e.swiper)) { const r = { ...e.swiper }; Object.assign(r, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper = new a(r), n = !0; } return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on('tap', o), !0; } function d(e) { const a = t.thumbs.swiper; if (a && !a.destroyed) { const r = a.params.slidesPerView === 'auto' ? a.slidesPerViewDynamic() : a.params.slidesPerView; let i = 1; const s = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (i = 1), i = Math.floor(i), a.slides.forEach(((e) => e.classList.remove(s))), a.params.loop || a.params.virtual && a.params.virtual.enabled) for (let n = 0; n < i; n += 1)T(a.slidesEl, '[data-swiper-slide-index="'.concat(t.realIndex + n, '"]')).forEach(((e) => { e.classList.add(s); })); else for (let o = 0; o < i; o += 1)a.slides[t.realIndex + o] && a.slides[t.realIndex + o].classList.add(s); const l = t.params.thumbs.autoScrollOffset; const d = l && !a.params.loop; if (t.realIndex !== a.realIndex || d) { let c; let u; const p = a.activeIndex; if (a.params.loop) { const f = a.slides.filter(((e) => e.getAttribute('data-swiper-slide-index') === ''.concat(t.realIndex)))[0]; c = a.slides.indexOf(f), u = t.activeIndex > t.previousIndex ? 'next' : 'prev'; } else u = (c = t.realIndex) > t.previousIndex ? 'next' : 'prev'; d && (c += u === 'next' ? l : -1 * l), a.visibleSlidesIndexes && a.visibleSlidesIndexes.indexOf(c) < 0 && (a.params.centeredSlides ? c = c > p ? c - Math.floor(r / 2) + 1 : c + Math.floor(r / 2) - 1 : c > p && a.params.slidesPerGroup, a.slideTo(c, e ? 0 : void 0)); } } }t.thumbs = { swiper: null }, r('beforeInit', (() => { const e = t.params.thumbs; if (e && e.swiper) if (typeof e.swiper === 'string' || e.swiper instanceof HTMLElement) { const a = i(); const r = function () { t.destroyed || (function () { const r = typeof e.swiper === 'string' ? a.querySelector(e.swiper) : e.swiper; if (r && r.swiper)e.swiper = r.swiper, l(), d(!0); else if (r) { const i = ''.concat(t.params.eventsPrefix, 'init'); const s = function (a) { e.swiper = a.detail[0], r.removeEventListener(i, s), l(), d(!0), e.swiper.update(), t.update(); }; r.addEventListener(i, s); } return r; }()) || requestAnimationFrame(r); }; requestAnimationFrame(r); } else l(), d(!0); })), r('slideChange update resize observerUpdate', (() => { d(); })), r('setTransition', ((e, a) => { const r = t.thumbs.swiper; r && !r.destroyed && r.setTransition(a); })), r('beforeDestroy', (() => { const e = t.thumbs.swiper; e && !e.destroyed && n && e.destroy(); })), Object.assign(t.thumbs, { init: l, update: d });
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.emit; const i = e.once; a({
          freeMode: {
            enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: 0.02,
          },
        }), Object.assign(t, { freeMode: { onTouchStart() { if (!t.params.cssMode) { const e = t.getTranslate(); t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({ currentPos: t.rtl ? t.translate : -t.translate }); } }, onTouchMove() { if (!t.params.cssMode) { const e = t.touchEventsData; const a = t.touches; e.velocities.length === 0 && e.velocities.push({ position: a[t.isHorizontal() ? 'startX' : 'startY'], time: e.touchStartTime }), e.velocities.push({ position: a[t.isHorizontal() ? 'currentX' : 'currentY'], time: g() }); } }, onTouchEnd(e) { const a = e.currentPos; if (!t.params.cssMode) { const s = t.params; const n = t.wrapperEl; const o = t.rtlTranslate; const l = t.snapGrid; const d = t.touchEventsData; const c = g() - d.touchStartTime; if (a < -t.minTranslate())t.slideTo(t.activeIndex); else if (a > -t.maxTranslate())t.slides.length < l.length ? t.slideTo(l.length - 1) : t.slideTo(t.slides.length - 1); else { if (s.freeMode.momentum) { if (d.velocities.length > 1) { const u = d.velocities.pop(); const p = d.velocities.pop(); const f = u.position - p.position; const m = u.time - p.time; t.velocity = f / m, t.velocity /= 2, Math.abs(t.velocity) < s.freeMode.minimumVelocity && (t.velocity = 0), (m > 150 || g() - u.time > 300) && (t.velocity = 0); } else t.velocity = 0; t.velocity *= s.freeMode.momentumVelocityRatio, d.velocities.length = 0; let v = 1e3 * s.freeMode.momentumRatio; const h = t.velocity * v; let w = t.translate + h; o && (w = -w); let b; let y; let E = !1; const x = 20 * Math.abs(t.velocity) * s.freeMode.momentumBounceRatio; if (w < t.maxTranslate())s.freeMode.momentumBounce ? (w + t.maxTranslate() < -x && (w = t.maxTranslate() - x), b = t.maxTranslate(), E = !0, d.allowMomentumBounce = !0) : w = t.maxTranslate(), s.loop && s.centeredSlides && (y = !0); else if (w > t.minTranslate())s.freeMode.momentumBounce ? (w - t.minTranslate() > x && (w = t.minTranslate() + x), b = t.minTranslate(), E = !0, d.allowMomentumBounce = !0) : w = t.minTranslate(), s.loop && s.centeredSlides && (y = !0); else if (s.freeMode.sticky) { for (var S, T = 0; T < l.length; T += 1) if (l[T] > -w) { S = T; break; }w = -(w = Math.abs(l[S] - w) < Math.abs(l[S - 1] - w) || t.swipeDirection === 'next' ? l[S] : l[S - 1]); } if (y && i('transitionEnd', (() => { t.loopFix(); })), t.velocity !== 0) { if (v = o ? Math.abs((-w - t.translate) / t.velocity) : Math.abs((w - t.translate) / t.velocity), s.freeMode.sticky) { const M = Math.abs((o ? -w : w) - t.translate); const C = t.slidesSizesGrid[t.activeIndex]; v = M < C ? s.speed : M < 2 * C ? 1.5 * s.speed : 2.5 * s.speed; } } else if (s.freeMode.sticky) return void t.slideToClosest(); s.freeMode.momentumBounce && E ? (t.updateProgress(b), t.setTransition(v), t.setTranslate(w), t.transitionStart(!0, t.swipeDirection), t.animating = !0, A(n, (() => { t && !t.destroyed && d.allowMomentumBounce && (r('momentumBounce'), t.setTransition(s.speed), setTimeout((() => { t.setTranslate(b), A(n, (() => { t && !t.destroyed && t.transitionEnd(); })); }), 0)); }))) : t.velocity ? (r('_freeModeNoMomentumRelease'), t.updateProgress(w), t.setTransition(v), t.setTranslate(w), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, A(n, (() => { t && !t.destroyed && t.transitionEnd(); })))) : t.updateProgress(w), t.updateActiveIndex(), t.updateSlidesClasses(); } else { if (s.freeMode.sticky) return void t.slideToClosest(); s.freeMode && r('_freeModeNoMomentumRelease'); }(!s.freeMode.momentum || c >= s.longSwipesMs) && (r('_freeModeStaticRelease'), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()); } } } } });
      }, function (e) {
        let t; let a; let r; let i; const s = e.swiper; const n = e.extendParams; const o = e.on; n({ grid: { rows: 1, fill: 'column' } }); const l = function () { let e = s.params.spaceBetween; return typeof e === 'string' && e.indexOf('%') >= 0 ? e = parseFloat(e.replace('%', '')) / 100 * s.size : typeof e === 'string' && (e = parseFloat(e)), e; }; o('init', (() => { i = s.params.grid && s.params.grid.rows > 1; })), o('update', (() => { const e = s.params; const t = s.el; const a = e.grid && e.grid.rows > 1; i && !a ? (t.classList.remove(''.concat(e.containerModifierClass, 'grid'), ''.concat(e.containerModifierClass, 'grid-column')), r = 1, s.emitContainerClasses()) : !i && a && (t.classList.add(''.concat(e.containerModifierClass, 'grid')), e.grid.fill === 'column' && t.classList.add(''.concat(e.containerModifierClass, 'grid-column')), s.emitContainerClasses()), i = a; })), s.grid = {
          initSlides(e) { const i = s.params.slidesPerView; const n = s.params.grid; const o = n.rows; const l = n.fill; const d = s.virtual && s.params.virtual.enabled ? s.virtual.slides.length : e.length; r = Math.floor(d / o), t = Math.floor(d / o) === d / o ? d : Math.ceil(d / o) * o, i !== 'auto' && l === 'row' && (t = Math.max(t, i * o)), a = t / o; }, unsetSlides() { s.slides && s.slides.forEach(((e) => { e.swiperSlideGridSet && (e.style.height = '', e.style[s.getDirectionLabel('margin-top')] = ''); })); }, updateSlide(e, i, n) { let o; let d; let c; const u = s.params.slidesPerGroup; const p = l(); const f = s.params.grid; const m = f.rows; const v = f.fill; const h = s.virtual && s.params.virtual.enabled ? s.virtual.slides.length : n.length; if (v === 'row' && u > 1) { const g = Math.floor(e / (u * m)); const w = e - m * u * g; const b = g === 0 ? u : Math.min(Math.ceil((h - g * m * u) / m), u); o = (d = w - (c = Math.floor(w / b)) * b + g * u) + c * t / m, i.style.order = o; } else v === 'column' ? (c = e - (d = Math.floor(e / m)) * m, (d > r || d === r && c === m - 1) && (c += 1) >= m && (c = 0, d += 1)) : d = e - (c = Math.floor(e / a)) * a; i.row = c, i.column = d, i.style.height = 'calc((100% - '.concat((m - 1) * p, 'px) / ').concat(m, ')'), i.style[s.getDirectionLabel('margin-top')] = c !== 0 ? p && ''.concat(p, 'px') : '', i.swiperSlideGridSet = !0; }, updateWrapperSize(e, a) { const r = s.params; const i = r.centeredSlides; const n = r.roundLengths; const o = l(); const d = s.params.grid.rows; if (s.virtualSize = (e + o) * t, s.virtualSize = Math.ceil(s.virtualSize / d) - o, s.params.cssMode || (s.wrapperEl.style[s.getDirectionLabel('width')] = ''.concat(s.virtualSize + o, 'px')), i) { for (var c = [], u = 0; u < a.length; u += 1) { let p = a[u]; n && (p = Math.floor(p)), a[u] < s.virtualSize + a[0] && c.push(p); }a.splice(0, a.length), a.push.apply(a, c); } },
        };
      }, function (e) {
        const t = e.swiper; Object.assign(t, {
          appendSlide: fe.bind(t), prependSlide: me.bind(t), addSlide: ve.bind(t), removeSlide: he.bind(t), removeAllSlides: ge.bind(t),
        });
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; a({ fadeEffect: { crossFade: !1 } }), we({
          effect: 'fade',
          swiper: t,
          on: r,
          setTranslate() { const e = t.slides; t.params.fadeEffect; for (let a = 0; a < e.length; a += 1) { const r = t.slides[a]; let i = -r.swiperSlideOffset; t.params.virtualTranslate || (i -= t.translate); let s = 0; t.isHorizontal() || (s = i, i = 0); const n = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(r.progress), 0) : 1 + Math.min(Math.max(r.progress, -1), 0); const o = be(0, r); o.style.opacity = n, o.style.transform = 'translate3d('.concat(i, 'px, ').concat(s, 'px, 0px)'); } },
          setTransition(e) {
            const a = t.slides.map(((e) => S(e))); a.forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })), ye({
              swiper: t, duration: e, transformElements: a, allSlides: !0,
            });
          },
          overwriteParams() {
            return {
              slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode,
            };
          },
        });
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; a({
          cubeEffect: {
            slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: 0.94,
          },
        }); const i = function (e, t, a) { let r = a ? e.querySelector('.swiper-slide-shadow-left') : e.querySelector('.swiper-slide-shadow-top'); let i = a ? e.querySelector('.swiper-slide-shadow-right') : e.querySelector('.swiper-slide-shadow-bottom'); r || (r = C('div', (`swiper-slide-shadow-cube swiper-slide-shadow-${a ? 'left' : 'top'}`).split(' ')), e.append(r)), i || (i = C('div', (`swiper-slide-shadow-cube swiper-slide-shadow-${a ? 'right' : 'bottom'}`).split(' ')), e.append(i)), r && (r.style.opacity = Math.max(-t, 0)), i && (i.style.opacity = Math.max(t, 0)); }; we({
          effect: 'cube',
          swiper: t,
          on: r,
          setTranslate() {
            let e; const a = t.el; const r = t.wrapperEl; const s = t.slides; const n = t.width; const o = t.height; const l = t.rtlTranslate; const d = t.size; const c = t.browser; const u = D(t); const p = t.params.cubeEffect; const f = t.isHorizontal(); const m = t.virtual && t.params.virtual.enabled; let v = 0; p.shadow && (f ? ((e = t.wrapperEl.querySelector('.swiper-cube-shadow')) || (e = C('div', 'swiper-cube-shadow'), t.wrapperEl.append(e)), e.style.height = ''.concat(n, 'px')) : (e = a.querySelector('.swiper-cube-shadow')) || (e = C('div', 'swiper-cube-shadow'), a.append(e))); for (let h = 0; h < s.length; h += 1) {
              const g = s[h]; let w = h; m && (w = parseInt(g.getAttribute('data-swiper-slide-index'), 10)); let b = 90 * w; let y = Math.floor(b / 360); l && (b = -b, y = Math.floor(-b / 360)); const E = Math.max(Math.min(g.progress, 1), -1); let x = 0; let S = 0; let T = 0; w % 4 == 0 ? (x = 4 * -y * d, T = 0) : (w - 1) % 4 == 0 ? (x = 0, T = 4 * -y * d) : (w - 2) % 4 == 0 ? (x = d + 4 * y * d, T = d) : (w - 3) % 4 == 0 && (x = -d, T = 3 * d + 4 * d * y), l && (x = -x), f || (S = x, x = 0); const M = 'rotateX('.concat(u(f ? 0 : -b), 'deg) rotateY(').concat(u(f ? b : 0), 'deg) translate3d(').concat(x, 'px, ').concat(S, 'px, ')
                .concat(T, 'px)'); E <= 1 && E > -1 && (v = 90 * w + 90 * E, l && (v = 90 * -w - 90 * E)), g.style.transform = M, p.slideShadows && i(g, E, f);
            } if (r.style.transformOrigin = '50% 50% -'.concat(d / 2, 'px'), r.style['-webkit-transform-origin'] = '50% 50% -'.concat(d / 2, 'px'), p.shadow) if (f)e.style.transform = 'translate3d(0px, '.concat(n / 2 + p.shadowOffset, 'px, ').concat(-n / 2, 'px) rotateX(89.99deg) rotateZ(0deg) scale(').concat(p.shadowScale, ')'); else { const P = Math.abs(v) - 90 * Math.floor(Math.abs(v) / 90); const L = 1.5 - (Math.sin(2 * P * Math.PI / 360) / 2 + Math.cos(2 * P * Math.PI / 360) / 2); const k = p.shadowScale; const I = p.shadowScale / L; const A = p.shadowOffset; e.style.transform = 'scale3d('.concat(k, ', 1, ').concat(I, ') translate3d(0px, ').concat(o / 2 + A, 'px, ').concat(-o / 2 / I, 'px) rotateX(-89.99deg)'); } const z = (c.isSafari || c.isWebView) && c.needPerspectiveFix ? -d / 2 : 0; r.style.transform = 'translate3d(0px,0,'.concat(z, 'px) rotateX(').concat(u(t.isHorizontal() ? 0 : v), 'deg) rotateY(').concat(u(t.isHorizontal() ? -v : 0), 'deg)'), r.style.setProperty('--swiper-cube-translate-z', ''.concat(z, 'px'));
          },
          setTransition(e) { const a = t.el; if (t.slides.forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'), t.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })); })), t.params.cubeEffect.shadow && !t.isHorizontal()) { const r = a.querySelector('.swiper-cube-shadow'); r && (r.style.transitionDuration = ''.concat(e, 'ms')); } },
          recreateShadows() { const e = t.isHorizontal(); t.slides.forEach(((t) => { const a = Math.max(Math.min(t.progress, 1), -1); i(t, a, e); })); },
          getEffectParams() { return t.params.cubeEffect; },
          perspective() { return !0; },
          overwriteParams() {
            return {
              slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0,
            };
          },
        });
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; a({ flipEffect: { slideShadows: !0, limitRotation: !0 } }); const i = function (e, a) { let r = t.isHorizontal() ? e.querySelector('.swiper-slide-shadow-left') : e.querySelector('.swiper-slide-shadow-top'); let i = t.isHorizontal() ? e.querySelector('.swiper-slide-shadow-right') : e.querySelector('.swiper-slide-shadow-bottom'); r || (r = Ee('flip', e, t.isHorizontal() ? 'left' : 'top')), i || (i = Ee('flip', e, t.isHorizontal() ? 'right' : 'bottom')), r && (r.style.opacity = Math.max(-a, 0)), i && (i.style.opacity = Math.max(a, 0)); }; we({
          effect: 'flip',
          swiper: t,
          on: r,
          setTranslate() { for (let e = t.slides, a = t.rtlTranslate, r = t.params.flipEffect, s = D(t), n = 0; n < e.length; n += 1) { const o = e[n]; let l = o.progress; t.params.flipEffect.limitRotation && (l = Math.max(Math.min(o.progress, 1), -1)); const d = o.swiperSlideOffset; let c = -180 * l; let u = 0; let p = t.params.cssMode ? -d - t.translate : -d; let f = 0; t.isHorizontal() ? a && (c = -c) : (f = p, p = 0, u = -c, c = 0), o.style.zIndex = -Math.abs(Math.round(l)) + e.length, r.slideShadows && i(o, l); const m = 'translate3d('.concat(p, 'px, ').concat(f, 'px, 0px) rotateX(').concat(s(u), 'deg) rotateY(').concat(s(c), 'deg)'); be(0, o).style.transform = m; } },
          setTransition(e) { const a = t.slides.map(((e) => S(e))); a.forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'), t.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })); })), ye({ swiper: t, duration: e, transformElements: a }); },
          recreateShadows() { t.params.flipEffect, t.slides.forEach(((e) => { let a = e.progress; t.params.flipEffect.limitRotation && (a = Math.max(Math.min(e.progress, 1), -1)), i(e, a); })); },
          getEffectParams() { return t.params.flipEffect; },
          perspective() { return !0; },
          overwriteParams() {
            return {
              slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode,
            };
          },
        });
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; a({
          coverflowEffect: {
            rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0,
          },
        }), we({
          effect: 'coverflow',
          swiper: t,
          on: r,
          setTranslate() {
            for (let e = t.width, a = t.height, r = t.slides, i = t.slidesSizesGrid, s = t.params.coverflowEffect, n = t.isHorizontal(), o = t.translate, l = n ? e / 2 - o : a / 2 - o, d = n ? s.rotate : -s.rotate, c = s.depth, u = D(t), p = 0, f = r.length; p < f; p += 1) {
              const m = r[p]; const v = i[p]; const h = (l - m.swiperSlideOffset - v / 2) / v; const g = typeof s.modifier === 'function' ? s.modifier(h) : h * s.modifier; let w = n ? d * g : 0; let b = n ? 0 : d * g; let y = -c * Math.abs(g); let E = s.stretch; typeof E === 'string' && E.indexOf('%') !== -1 && (E = parseFloat(s.stretch) / 100 * v); let x = n ? 0 : E * g; let S = n ? E * g : 0; let T = 1 - (1 - s.scale) * Math.abs(g); Math.abs(S) < 0.001 && (S = 0), Math.abs(x) < 0.001 && (x = 0), Math.abs(y) < 0.001 && (y = 0), Math.abs(w) < 0.001 && (w = 0), Math.abs(b) < 0.001 && (b = 0), Math.abs(T) < 0.001 && (T = 0); const M = 'translate3d('.concat(S, 'px,').concat(x, 'px,').concat(y, 'px)  rotateX(').concat(u(b), 'deg) rotateY(')
                .concat(u(w), 'deg) scale(')
                .concat(T, ')'); if (be(0, m).style.transform = M, m.style.zIndex = 1 - Math.abs(Math.round(g)), s.slideShadows) { let C = n ? m.querySelector('.swiper-slide-shadow-left') : m.querySelector('.swiper-slide-shadow-top'); let P = n ? m.querySelector('.swiper-slide-shadow-right') : m.querySelector('.swiper-slide-shadow-bottom'); C || (C = Ee('coverflow', m, n ? 'left' : 'top')), P || (P = Ee('coverflow', m, n ? 'right' : 'bottom')), C && (C.style.opacity = g > 0 ? g : 0), P && (P.style.opacity = -g > 0 ? -g : 0); }
            }
          },
          setTransition(e) { t.slides.map(((e) => S(e))).forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'), t.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })); })); },
          perspective() { return !0; },
          overwriteParams() { return { watchSlidesProgress: !0 }; },
        });
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; a({
          creativeEffect: {
            limitProgress: 1,
            shadowPerProgress: !1,
            progressMultiplier: 1,
            perspective: !0,
            prev: {
              translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1,
            },
            next: {
              translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1,
            },
          },
        }), we({
          effect: 'creative',
          swiper: t,
          on: r,
          setTranslate() {
            const e = t.slides; const a = t.wrapperEl; const r = t.slidesSizesGrid; const i = t.params.creativeEffect; const s = i.progressMultiplier; const n = t.params.centeredSlides; const o = D(t); if (n) { const l = r[0] / 2 - t.params.slidesOffsetBefore || 0; a.style.transform = 'translateX(calc(50% - '.concat(l, 'px))'); } for (var d = function () {
                const a = e[c]; const r = a.progress; const l = Math.min(Math.max(a.progress, -i.limitProgress), i.limitProgress); let d = l; n || (d = Math.min(Math.max(a.originalProgress, -i.limitProgress), i.limitProgress)); const u = a.swiperSlideOffset; const p = [t.params.cssMode ? -u - t.translate : -u, 0, 0]; const f = [0, 0, 0]; let m = !1; t.isHorizontal() || (p[1] = p[0], p[0] = 0); let v = {
                  translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1,
                }; l < 0 ? (v = i.next, m = !0) : l > 0 && (v = i.prev, m = !0), p.forEach(((e, t) => { p[t] = 'calc('.concat(e, 'px + (').concat((function (e) { return typeof e === 'string' ? e : ''.concat(e, 'px'); }(v.translate[t])), ' * ').concat(Math.abs(l * s), '))'); })), f.forEach(((e, t) => { const a = v.rotate[t] * Math.abs(l * s); f[t] = a; })), a.style.zIndex = -Math.abs(Math.round(r)) + e.length; const h = p.join(', '); const g = 'rotateX('.concat(o(f[0]), 'deg) rotateY(').concat(o(f[1]), 'deg) rotateZ(').concat(o(f[2]), 'deg)'); const w = 'scale('.concat(d < 0 ? 1 + (1 - v.scale) * d * s : 1 - (1 - v.scale) * d * s, ')'); const b = d < 0 ? 1 + (1 - v.opacity) * d * s : 1 - (1 - v.opacity) * d * s; const y = 'translate3d('.concat(h, ') ').concat(g, ' ').concat(w); if (m && v.shadow || !m) { let E = a.querySelector('.swiper-slide-shadow'); if (!E && v.shadow && (E = Ee('creative', a)), E) { const x = i.shadowPerProgress ? l * (1 / i.limitProgress) : l; E.style.opacity = Math.min(Math.max(Math.abs(x), 0), 1); } } const S = be(0, a); S.style.transform = y, S.style.opacity = b, v.origin && (S.style.transformOrigin = v.origin);
              }, c = 0; c < e.length; c += 1)d();
          },
          setTransition(e) {
            const a = t.slides.map(((e) => S(e))); a.forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'), t.querySelectorAll('.swiper-slide-shadow').forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })); })), ye({
              swiper: t, duration: e, transformElements: a, allSlides: !0,
            });
          },
          perspective() { return t.params.creativeEffect.perspective; },
          overwriteParams() { return { watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }; },
        });
      }, function (e) {
        const t = e.swiper; const a = e.extendParams; const r = e.on; a({
          cardsEffect: {
            slideShadows: !0, rotate: !0, perSlideRotate: 2, perSlideOffset: 8,
          },
        }), we({
          effect: 'cards',
          swiper: t,
          on: r,
          setTranslate() {
            for (let e = t.slides, a = t.activeIndex, r = t.rtlTranslate, i = t.params.cardsEffect, s = t.touchEventsData, n = s.startTranslate, o = s.isTouched, l = r ? -t.translate : t.translate, d = 0; d < e.length; d += 1) {
              const c = e[d]; const u = c.progress; const p = Math.min(Math.max(u, -4), 4); let f = c.swiperSlideOffset; t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = 'translateX('.concat(t.minTranslate(), 'px)')), t.params.centeredSlides && t.params.cssMode && (f -= e[0].swiperSlideOffset); let m = t.params.cssMode ? -f - t.translate : -f; let v = 0; const h = -100 * Math.abs(p); let g = 1; let w = -i.perSlideRotate * p; let b = i.perSlideOffset - 0.75 * Math.abs(p); const y = t.virtual && t.params.virtual.enabled ? t.virtual.from + d : d; const E = (y === a || y === a - 1) && p > 0 && p < 1 && (o || t.params.cssMode) && l < n; const x = (y === a || y === a + 1) && p < 0 && p > -1 && (o || t.params.cssMode) && l > n; if (E || x) { const S = (1 - Math.abs((Math.abs(p) - 0.5) / 0.5)) ** 0.5; w += -28 * p * S, g += -0.5 * S, b += 96 * S, v = `${-25 * S * Math.abs(p)}%`; } if (m = p < 0 ? 'calc('.concat(m, 'px ').concat(r ? '-' : '+', ' (').concat(b * Math.abs(p), '%))') : p > 0 ? 'calc('.concat(m, 'px ').concat(r ? '-' : '+', ' (-').concat(b * Math.abs(p), '%))') : ''.concat(m, 'px'), !t.isHorizontal()) { const T = v; v = m, m = T; } const M = p < 0 ? `${1 + (1 - g) * p}` : `${1 - (1 - g) * p}`; const C = '\n        translate3d('.concat(m, ', ').concat(v, ', ').concat(h, 'px)\n        rotateZ(').concat(i.rotate ? r ? -w : w : 0, 'deg)\n        scale(')
                .concat(M, ')\n      '); if (i.slideShadows) { let P = c.querySelector('.swiper-slide-shadow'); P || (P = Ee('cards', c)), P && (P.style.opacity = Math.min(Math.max((Math.abs(p) - 0.5) / 0.5, 0), 1)); }c.style.zIndex = -Math.abs(Math.round(u)) + e.length, be(0, c).style.transform = C;
            }
          },
          setTransition(e) { const a = t.slides.map(((e) => S(e))); a.forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'), t.querySelectorAll('.swiper-slide-shadow').forEach(((t) => { t.style.transitionDuration = ''.concat(e, 'ms'); })); })), ye({ swiper: t, duration: e, transformElements: a }); },
          perspective() { return !0; },
          overwriteParams() { return { watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }; },
        });
      }]; return ce.use(xe), ce;
    }()); function m(e, t) { return new f(e, t); }
  },
}]);
